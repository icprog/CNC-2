<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Utilities</name>
  </assembly>
  <members>
    <member name="T:Utilities.Caching.Cache`1">
      <summary>
            Acts as a cache
            </summary>
    </member>
    <member name="T:Utilities.Caching.Interfaces.ICache`1">
      <summary>
            Cache interface
            </summary>
    </member>
    <member name="M:Utilities.Caching.Interfaces.ICache`1.Clear">
      <summary>
            Clears the cache
            </summary>
    </member>
    <member name="M:Utilities.Caching.Interfaces.ICache`1.Remove(`0)">
      <summary>
            Removes an item from the cache
            </summary>
      <param name="Key">Key to remove</param>
    </member>
    <member name="M:Utilities.Caching.Interfaces.ICache`1.Exists(`0)">
      <summary>
            Checks if a key exists in the cache
            </summary>
      <param name="Key">Key to check</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.Caching.Interfaces.ICache`1.Add(`0,System.Object)">
      <summary>
            Adds an item to the cache
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="M:Utilities.Caching.Interfaces.ICache`1.Get``1(`0)">
      <summary>
            Gets a value
            </summary>
      <typeparam name="ValueType">Value type</typeparam>
      <param name="Key">Key</param>
      <returns>The value specified by the key</returns>
    </member>
    <member name="P:Utilities.Caching.Interfaces.ICache`1.Keys">
      <summary>
            Keys used in the cache
            </summary>
    </member>
    <member name="P:Utilities.Caching.Interfaces.ICache`1.Count">
      <summary>
            Number of items in the cache
            </summary>
    </member>
    <member name="P:Utilities.Caching.Interfaces.ICache`1.Item(`0)">
      <summary>
            Gets a specific item based on the key
            </summary>
      <param name="Key">Key to use</param>
      <returns>The value associated with the key</returns>
    </member>
    <member name="M:Utilities.Caching.Cache`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Caching.Cache`1.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.Caching.Cache`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.Caching.Cache`1.Clear">
      <summary>
            Clears the cache
            </summary>
    </member>
    <member name="M:Utilities.Caching.Cache`1.Remove(`0)">
      <summary>
            Removes an item from the cache
            </summary>
      <param name="Key">Key associated with the item to remove</param>
    </member>
    <member name="M:Utilities.Caching.Cache`1.Exists(`0)">
      <summary>
            Determines if the item exists
            </summary>
      <param name="Key">The key associated with the item</param>
      <returns>True if it does, false otherwise</returns>
    </member>
    <member name="M:Utilities.Caching.Cache`1.Add(`0,System.Object)">
      <summary>
            Adds an item to the cache
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="M:Utilities.Caching.Cache`1.Get``1(`0)">
      <summary>
            Gets an item from the cache
            </summary>
      <typeparam name="ValueType">Item type</typeparam>
      <param name="Key">Key to search for</param>
      <returns>The item associated with the key</returns>
    </member>
    <member name="P:Utilities.Caching.Cache`1.InternalCache">
      <summary>
            Internal cache
            </summary>
    </member>
    <member name="P:Utilities.Caching.Cache`1.Keys">
      <summary>
            Collection of keys
            </summary>
    </member>
    <member name="P:Utilities.Caching.Cache`1.Count">
      <summary>
            The number of items in the cache
            </summary>
    </member>
    <member name="P:Utilities.Caching.Cache`1.Item(`0)">
      <summary>
            Gets the item associated with the key
            </summary>
      <param name="Key">Key</param>
      <returns>The item associated with the key</returns>
    </member>
    <member name="T:Utilities.Caching.CacheItem`1">
      <summary>
            Cache item
            </summary>
      <typeparam name="KeyType">Key type</typeparam>
    </member>
    <member name="T:Utilities.Caching.Interfaces.ICacheItem">
      <summary>
            Cache item interface
            </summary>
    </member>
    <member name="P:Utilities.Caching.Interfaces.ICacheItem.Value">
      <summary>
            Value (not strongly typed)
            </summary>
    </member>
    <member name="T:Utilities.Caching.Interfaces.ICacheItem`1">
      <summary>
            Cache item interface
            </summary>
    </member>
    <member name="P:Utilities.Caching.Interfaces.ICacheItem`1.Key">
      <summary>
            Key of the cache item
            </summary>
    </member>
    <member name="M:Utilities.Caching.CacheItem`1.#ctor(`0,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="P:Utilities.Caching.CacheItem`1.Value">
      <summary>
            Value stored in the cache item
            </summary>
    </member>
    <member name="P:Utilities.Caching.CacheItem`1.Key">
      <summary>
            Key associated with the cache item
            </summary>
    </member>
    <member name="T:Utilities.Caching.ExtensionMethods.CachingExtensions">
      <summary>
            Extension methods relating to caching of data
            </summary>
    </member>
    <member name="M:Utilities.Caching.ExtensionMethods.CachingExtensions.Cache``1(``0,System.String,Utilities.Caching.ExtensionMethods.CacheType)">
      <summary>
            Caches an object to the specified cache, using the specified key
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to cache</param>
      <param name="Type">Caching type</param>
      <param name="Key">Key to cache the item under</param>
    </member>
    <member name="M:Utilities.Caching.ExtensionMethods.CachingExtensions.GetFromCache``1(System.String,Utilities.Caching.ExtensionMethods.CacheType,``0)">
      <summary>
            Gets the specified object from the cache if it exists, otherwise the default value is returned
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Key">Key that the object is under</param>
      <param name="Type">Cache types to search</param>
      <param name="DefaultValue">Default value to return</param>
      <returns>The specified object if it exists, otherwise the default value</returns>
    </member>
    <member name="T:Utilities.Caching.ExtensionMethods.CacheType">
      <summary>
            Determines where an item is cached
            </summary>
    </member>
    <member name="F:Utilities.Caching.ExtensionMethods.CacheType.Cache">
      <summary>
            Cache (ASP.Net only)
            </summary>
    </member>
    <member name="F:Utilities.Caching.ExtensionMethods.CacheType.Item">
      <summary>
            Item (ASP.Net only)
            </summary>
    </member>
    <member name="F:Utilities.Caching.ExtensionMethods.CacheType.Session">
      <summary>
            Session (ASP.Net only)
            </summary>
    </member>
    <member name="F:Utilities.Caching.ExtensionMethods.CacheType.Cookie">
      <summary>
            Cookie (ASP.Net only)
            </summary>
    </member>
    <member name="F:Utilities.Caching.ExtensionMethods.CacheType.Internal">
      <summary>
            Internal caching
            </summary>
    </member>
    <member name="T:Utilities.AI.Anagram">
      <summary>
            Anagram finder
            </summary>
    </member>
    <member name="M:Utilities.AI.Anagram.#ctor(System.Collections.Generic.ICollection{System.String})">
      <summary>
            Constructor
            </summary>
      <param name="DictionaryOfWords">Dictionary of words to use to find anagrams</param>
      <requires description="DictionaryOfWords" exception="T:System.ArgumentNullException" csharp="DictionaryOfWords != null" vb="DictionaryOfWords &lt;&gt; Nothing">DictionaryOfWords != null</requires>
      <exception cref="T:System.ArgumentNullException">DictionaryOfWords == null</exception>
    </member>
    <member name="M:Utilities.AI.Anagram.FindAnagrams">
      <summary>
            Finds the initial set of anagrams
            </summary>
    </member>
    <member name="M:Utilities.AI.Anagram.GetAnagramKey(System.String)">
      <summary>
            Gets the anagram key associated with the word
            </summary>
      <param name="Word">Word to get the anagram key for</param>
      <returns>The anagram key</returns>
    </member>
    <member name="M:Utilities.AI.Anagram.FindAnagrams(System.String)">
      <summary>
            Returns the list of equivalent anagrams
            </summary>
      <param name="Word">Word to check</param>
      <returns>A list of words that are anagrams of the word entered</returns>
    </member>
    <member name="P:Utilities.AI.Anagram.InitialDictionary">
      <summary>
            Dictionary of words used to find anagrams
            </summary>
    </member>
    <member name="P:Utilities.AI.Anagram.DictionaryOfAnagrams">
      <summary>
            Dictionary of anagram equivalents found in the original dictionary
            </summary>
    </member>
    <member name="T:Utilities.Compression.ExtensionMethods.CompressionExtensions">
      <summary>
            Extension methods dealing with compression
            </summary>
    </member>
    <member name="M:Utilities.Compression.ExtensionMethods.CompressionExtensions.Compress(System.Byte[],Utilities.Compression.ExtensionMethods.Enums.CompressionType)">
      <summary>
            Compresses the data using the specified compression type
            </summary>
      <param name="Data">Data to compress</param>
      <param name="CompressionType">Compression type</param>
      <returns>The compressed data</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Compression.ExtensionMethods.CompressionExtensions.Compress(System.String,System.Text.Encoding,Utilities.Compression.ExtensionMethods.Enums.CompressionType)">
      <summary>
            Compresses a string of data
            </summary>
      <param name="Data">Data to Compress</param>
      <param name="EncodingUsing">Encoding that the data uses (defaults to UTF8)</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data Compressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Data)" vb="Not IsNullOrEmpty(Data)">!string.IsNullOrEmpty(Data)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Data)</exception>
    </member>
    <member name="M:Utilities.Compression.ExtensionMethods.CompressionExtensions.Decompress(System.Byte[],Utilities.Compression.ExtensionMethods.Enums.CompressionType)">
      <summary>
            Decompresses the byte array that is sent in
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data decompressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Compression.ExtensionMethods.CompressionExtensions.Decompress(System.String,System.Text.Encoding,Utilities.Compression.ExtensionMethods.Enums.CompressionType)">
      <summary>
            Decompresses a string of data
            </summary>
      <param name="Data">Data to decompress</param>
      <param name="EncodingUsing">Encoding that the result should use (defaults to UTF8)</param>
      <param name="CompressionType">The compression type used</param>
      <returns>The data decompressed</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Data)" vb="Not IsNullOrEmpty(Data)">!string.IsNullOrEmpty(Data)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Data)</exception>
    </member>
    <member name="T:Utilities.Compression.ExtensionMethods.Enums.CompressionType">
      <summary>
            Defines the various compression types that are available
            </summary>
    </member>
    <member name="F:Utilities.Compression.ExtensionMethods.Enums.CompressionType.Deflate">
      <summary>
            Deflate
            </summary>
    </member>
    <member name="F:Utilities.Compression.ExtensionMethods.Enums.CompressionType.GZip">
      <summary>
            GZip
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.ConverterBase`2">
      <summary>
            Converter class
            </summary>
      <typeparam name="T">Type of input</typeparam>
      <typeparam name="R">Type of output</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.ConverterBaseHack`1">
      <summary>
            Hack class needed since you can't inherit from interfaces twice
            </summary>
      <typeparam name="T">Object type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Interfaces.IConverter`1">
      <summary>
            Converter interface
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Interfaces.IConverter">
      <summary>
            Converter interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Interfaces.IConverter`1.CanConvert(System.Type)">
      <summary>
            Can the converter convert to the type specified
            </summary>
      <param name="type">Type to convert to</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Interfaces.IConverter`1.To(`0,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBaseHack`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBaseHack`1.CanConvert(System.Type)">
      <summary>
            Can the converter convert to the type specified
            </summary>
      <param name="type">Type to convert to</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBaseHack`1.To(`0,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBase`2.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager object</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBase`2.CanConvert(System.Type)">
      <summary>
            Can the converter convert to the type specified
            </summary>
      <param name="type">Type to convert to</param>
      <returns>True if it can, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBase`2.To(`0,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ConverterBase`2.To(`1,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.ConverterBase`2.Manager">
      <summary>
            Manager object
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter">
      <summary>
            DbType to Type converter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter.To(System.Type,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.DbTypeTypeConverter.To(System.Data.DbType,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.ExpandoConverter">
      <summary>
            Expando converter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.ExpandoConverter.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager object</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.ExpandoConverter.CanConvert(System.Type)">
      <summary>
            Always returns true as it will attempt any return type
            </summary>
      <param name="type">Type asking about</param>
      <returns>True</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.ExpandoConverter.To(System.Dynamic.ExpandoObject,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.ExpandoConverter.Manager">
      <summary>
            Manager object
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.GenericConverter">
      <summary>
            Generic converter (last ditch effort class)
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.GenericConverter.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager object</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.GenericConverter.CanConvert(System.Type)">
      <summary>
            Always returns true as it will attempt any return type
            </summary>
      <param name="type">Type asking about</param>
      <returns>True</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.GenericConverter.To(System.Object,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Converters.GenericConverter.Manager">
      <summary>
            Manager object
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToDbType">
      <summary>
            SqlDbType to DbType Converter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToDbType.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager object</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToDbType.To(System.Data.SqlDbType,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToDbType.To(System.Data.DbType,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToType">
      <summary>
            SqlDbType to Type Converter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToType.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager object</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToType.To(System.Data.SqlDbType,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Converters.SqlDbTypeToType.To(System.Type,System.Type)">
      <summary>
            Converts the object to the specified type
            </summary>
      <param name="Item">Object to convert</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Interfaces.IObjectConverter">
      <summary>
            Object Converter interface
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Interfaces.IObjectConverter.To``1(System.Object,``0)">
      <summary>
            Converts the object from type T to type R
            </summary>
      <typeparam name="R">Object type returned</typeparam>
      <param name="Item">Item to convert</param>
      <param name="DefaultValue">Default value to return if the value is not convertable</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Interfaces.IObjectConverter.To(System.Object,System.Type,System.Object)">
      <summary>
            Converts the object from type T to type R
            </summary>
      <param name="Item">Item to convert</param>
      <param name="ReturnType">Object type returned</param>
      <param name="DefaultValue">Default value to return if the value is not convertable</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Interfaces.IObjectConverter.ObjectType">
      <summary>
            Object type accepted
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.Manager">
      <summary>
            Conversion manager
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.AddConverter(System.Type,System.Type)">
      <summary>
            Adds a converter to the system
            </summary>
      <param name="ObjectConverter">Object converter</param>
      <param name="ObjectType">Object type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.To``2(``0,``1)">
      <summary>
            Converts item from type T to R
            </summary>
      <typeparam name="T">Incoming type</typeparam>
      <typeparam name="R">Resulting type</typeparam>
      <param name="Item">Incoming object</param>
      <param name="DefaultValue">Default return value if the item is null or can not be converted</param>
      <returns>The value converted to the specified type</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.Manager.To``1(``0,System.Type,System.Object)">
      <summary>
            Converts item from type T to R
            </summary>
      <typeparam name="T">Incoming type</typeparam>
      <param name="Item">Incoming object</param>
      <param name="ResultType">Result type</param>
      <param name="DefaultValue">Default return value if the item is null or can not be converted</param>
      <returns>The value converted to the specified type</returns>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.Manager.Converters">
      <summary>
            Converters
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Conversion.ObjectConverter`1">
      <summary>
            Converter class
            </summary>
      <typeparam name="T">Type of input</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ObjectConverter`1.#ctor(Utilities.DataTypes.Conversion.Manager)">
      <summary>
            Constructor
            </summary>
      <param name="Manager">Manager object</param>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ObjectConverter`1.To``1(System.Object,``0)">
      <summary>
            Converts the object from type T to type R
            </summary>
      <typeparam name="R">Return type</typeparam>
      <param name="Item">Item to convert</param>
      <param name="DefaultValue">Default value to return if the value is not convertable</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.Conversion.ObjectConverter`1.To(System.Object,System.Type,System.Object)">
      <summary>
            Converts the object from type T to type ReturnType
            </summary>
      <param name="Item">Item to convert</param>
      <param name="DefaultValue">Default value to return if the value is not convertable</param>
      <param name="ReturnType">Return type</param>
      <returns>The object as the type specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.ObjectConverter`1.Manager">
      <summary>
            Manager object
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.ObjectConverter`1.ObjectType">
      <summary>
            Object type
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Conversion.ObjectConverter`1.Converters">
      <summary>
            Converter list
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.DelegateExtensions">
      <summary>
            Extensions for Func, Action, and EventHandler
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DelegateExtensions.Async(System.Action)">
      <summary>
            Runs an action async
            </summary>
      <param name="Action">Action to run</param>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DelegateExtensions.Raise``1(System.Action{``0},``0)">
      <summary>
            Safely calls the specified action
            </summary>
      <typeparam name="T">The type of the event args</typeparam>
      <param name="Delegate">The delegate</param>
      <param name="EventArgs">The event args</param>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DelegateExtensions.Raise``1(System.EventHandler{``0},System.Object,``0)">
      <summary>
            Safely raises the event
            </summary>
      <typeparam name="T">The type of the event args</typeparam>
      <param name="Delegate">The delegate</param>
      <param name="Sender">The sender</param>
      <param name="EventArg">The event args</param>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DelegateExtensions.Raise``2(System.Func{``0,``1},``0)">
      <summary>
            Safely calls the Func
            </summary>
      <typeparam name="T1">The event arg type</typeparam>
      <typeparam name="T2">The return type</typeparam>
      <param name="Delegate">The delegate</param>
      <param name="EventArgs">The event args</param>
      <returns>The value returned by the function</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.ExceptionExtensions">
      <summary>
            Class for housing exception specific extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ExceptionExtensions.ToString(System.Exception,System.String,System.String)">
      <summary>
            Converts the exception to a string and appends the specified prefix/suffix (used for logging)
            </summary>
      <param name="Exception">Exception to convert</param>
      <param name="Prefix">Prefix</param>
      <param name="Suffix">Suffix</param>
      <returns>The exception as a string</returns>
    </member>
    <member name="T:Utilities.DataTypes.Formatters.Interfaces.IStringFormatter">
      <summary>
            String formatter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.Interfaces.IStringFormatter.Format(System.String,System.String)">
      <summary>
            Formats the string based on the pattern
            </summary>
      <param name="Input">Input string</param>
      <param name="FormatPattern">Format pattern</param>
      <returns>The formatted string</returns>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass">
      <summary>
            Base class used for disposable objects
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.#ctor">
      <summary>
            Construct
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.Dispose">
      <summary>
            Dispose function
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.Dispose(System.Boolean)">
      <summary>
            Function to override in order to dispose objects
            </summary>
      <param name="Managed">If true, managed and unmanaged objects should be disposed. Otherwise unmanaged objects only.</param>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.SafeDisposableBaseClass.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.RingBuffer`1">
      <summary>
            Implements a ring buffer
            </summary>
      <typeparam name="T">Type of the data it holds</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.#ctor(System.Int32,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="MaxCapacity">Max capacity for the circular buffer</param>
      <param name="AllowOverflow">Is overflow allowed (defaults to false)</param>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Add(`0)">
      <summary>
            Adds an item to the buffer
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Add(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a number of items to the buffer
            </summary>
      <param name="Items">Items to add</param>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Add(`0[],System.Int32,System.Int32)">
      <summary>
            Adds a number of items to the buffer
            </summary>
      <param name="buffer">Items to add</param>
      <param name="count">Number of items to add</param>
      <param name="offset">Offset to start at</param>
      <requires description="buffer" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Clear">
      <summary>
            Clears the buffer
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Contains(`0)">
      <summary>
            Determines if the buffer contains the item
            </summary>
      <param name="item">Item to check</param>
      <returns>True if the item is present, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the buffer to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Array index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the buffer to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="index">Array index to start at</param>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="array.Rank == 1" vb="array.Rank = 1">array.Rank == 1</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" inheritedFromTypeName="ICollection" csharp="index &lt;= array.Length - this.Count" vb="index &lt;= array.Length - Me.Count">index &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.GetEnumerator">
      <summary>
            Gets the enumerator for the buffer
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the buffer
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove">
      <summary>
            Reads the next item from the buffer
            </summary>
      <returns>The next item from the buffer</returns>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove(System.Int32)">
      <summary>
            Reads the next X number of items from the buffer
            </summary>
      <param name="Amount">Number of items to return</param>
      <returns>The next X items from the buffer</returns>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove(`0)">
      <summary>
            Removes an item from the buffer
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Remove(`0[],System.Int32,System.Int32)">
      <summary>
            Reads the next X number of items and places them in the array passed in
            </summary>
      <param name="array">Array to copy to</param>
      <param name="offset">Offset to start at</param>
      <param name="count">Number of items to read</param>
      <returns>The number of items that were read</returns>
      <requires description="array" exception="T:System.ArgumentOutOfRangeException" csharp="this.Count &lt;= array.Length - offset" vb="Me.Count &lt;= array.Length - offset">this.Count &lt;= array.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">this.Count &gt; array.Length - offset</exception>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.Skip(System.Int32)">
      <summary>
            Skips ahead in the buffer
            </summary>
      <param name="Count">Number of items in the buffer to skip</param>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.ToString">
      <summary>
            Returns the buffer as a string
            </summary>
      <returns>The buffer as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.RingBuffer`1.op_Implicit(Utilities.DataTypes.RingBuffer{`0})~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.Count">
      <summary>
            Item count for the circular buffer
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.AllowOverflow">
      <summary>
            Is overflow allowed?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.MaxCapacity">
      <summary>
            Maximum capacity
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.IsSynchronized">
      <summary>
            Is this synchronized?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.SyncRoot">
      <summary>
            Sync root
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.ICollection.get_SyncRoot" inheritedFromTypeName="ICollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.Buffer">
      <summary>
            Buffer that the circular buffer uses
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.ReadPosition">
      <summary>
            Read position
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.WritePosition">
      <summary>
            Write position
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.RingBuffer`1.Item(System.Int32)">
      <summary>
            Allows getting an item at a specific position in the buffer
            </summary>
      <param name="Position">Position to look at</param>
      <returns>The specified item</returns>
    </member>
    <member name="T:Utilities.DataTypes.DateSpan">
      <summary>
            Represents a date span
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.#ctor(System.DateTime,System.DateTime)">
      <summary>
            Constructor
            </summary>
      <param name="Start">Start of the date span</param>
      <param name="End">End of the date span</param>
      <requires description="Start is after End" exception="T:System.ArgumentException" csharp="Start &lt;= End" vb="Start &lt;= End ">Start &lt;= End</requires>
      <exception cref="T:System.ArgumentException">!Start &lt;= End</exception>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.Intersection(Utilities.DataTypes.DateSpan)">
      <summary>
            Returns the intersecting time span between the two values
            </summary>
      <param name="Span">Span to use</param>
      <returns>The intersection of the two time spans</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.Overlap(Utilities.DataTypes.DateSpan)">
      <summary>
            Determines if two DateSpans overlap
            </summary>
      <param name="Span">The span to compare to</param>
      <returns>True if they overlap, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Addition(Utilities.DataTypes.DateSpan,Utilities.DataTypes.DateSpan)">
      <summary>
            Addition operator
            </summary>
      <param name="Span1">Span 1</param>
      <param name="Span2">Span 2</param>
      <returns>The combined date span</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Equality(Utilities.DataTypes.DateSpan,Utilities.DataTypes.DateSpan)">
      <summary>
            Determines if two DateSpans are equal
            </summary>
      <param name="Span1">Span 1</param>
      <param name="Span2">Span 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Inequality(Utilities.DataTypes.DateSpan,Utilities.DataTypes.DateSpan)">
      <summary>
            Determines if two DateSpans are not equal
            </summary>
      <param name="Span1">Span 1</param>
      <param name="Span2">Span 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.op_Implicit(Utilities.DataTypes.DateSpan)~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.ToString">
      <summary>
            Converts the DateSpan to a string
            </summary>
      <returns>The DateSpan as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.Equals(System.Object)">
      <summary>
            Determines if two objects are equal
            </summary>
      <param name="obj">Object to check</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.DateSpan.GetHashCode">
      <summary>
            Gets the hash code for the date span
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Start">
      <summary>
            Start date
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.End">
      <summary>
            End date
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Years">
      <summary>
            Years between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Months">
      <summary>
            Months between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Days">
      <summary>
            Days between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Hours">
      <summary>
            Hours between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Minutes">
      <summary>
            Minutes between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.Seconds">
      <summary>
            Seconds between the two dates
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.DateSpan.MilliSeconds">
      <summary>
            Milliseconds between the two dates
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.ArrayExtensions">
      <summary>
            Array extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ArrayExtensions.Clear(System.Array)">
      <summary>
            Clears the array completely
            </summary>
      <param name="Array">Array to clear</param>
      <returns>The final array</returns>
      <example>
        <code>
             int[] TestObject = new int[] { 1, 2, 3, 4, 5, 6 };
             TestObject.Clear();
            </code>
      </example>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ArrayExtensions.Clear``1(``0[])">
      <summary>
            Clears the array completely
            </summary>
      <param name="Array">Array to clear</param>
      <typeparam name="ArrayType">Array type</typeparam>
      <returns>The final array</returns>
      <example>
        <code>
             int[] TestObject = new int[] { 1, 2, 3, 4, 5, 6 };
             TestObject.Clear();
            </code>
      </example>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ArrayExtensions.Concat``1(``0[],``0[][])">
      <summary>
            Combines two arrays and returns a new array containing both values
            </summary>
      <typeparam name="ArrayType">Type of the data in the array</typeparam>
      <param name="Array1">Array 1</param>
      <param name="Additions">Arrays to concat onto the first item</param>
      <returns>A new array containing both arrays' values</returns>
      <example>
        <code>
             int[] TestObject1 = new int[] { 1, 2, 3 };
             int[] TestObject2 = new int[] { 4, 5, 6 };
             int[] TestObject3 = new int[] { 7, 8, 9 };
             TestObject1 = TestObject1.Combine(TestObject2, TestObject3);
            </code>
      </example>
      <requires description="Array1" exception="T:System.ArgumentNullException" csharp="Array1 != null" vb="Array1 &lt;&gt; Nothing">Array1 != null</requires>
      <exception cref="T:System.ArgumentNullException">Array1 == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="Additions != null" vb="Additions &lt;&gt; Nothing">Additions != null</requires>
      <exception cref="T:System.ArgumentNullException">Additions == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="for all x in Additions x != null" vb="for all x in Additions x &lt;&gt; Nothing">for all x in Additions x != null</requires>
      <exception cref="T:System.ArgumentNullException">!System.Diagnostics.Contracts.Contract.ForAll&lt;ArrayType[]&gt;(Additions, (ArrayType[] x) =&gt; (x != null))</exception>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions">
      <summary>
            Generic extensions dealing with objects
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Chain``1(``0,System.Action{``0},``0)">
      <summary>
            Allows actions to be chained together with the caveat that if Object is null,
            it is replaced with the DefaultObjectValue specified.
            If the Action or Object (once replaced with the default object value) is null, it will return the object.
            </summary>
      <typeparam name="T">The type of the object</typeparam>
      <param name="Object">Object to run the action on</param>
      <param name="Action">Action to run</param>
      <param name="DefaultObjectValue">Default object value</param>
      <returns>The original object</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Chain``2(``0,System.Func{``0,``1},``1,``0)">
      <summary>
            Allows actions to be chained together. It also has a couple of checks in there:
            1) If the function is null, it returns the default return value specified.
            2) If the object is null, it will replace it with the default object value specified.
            3) If the object, once replaced with the default object value specified, is null, it will return the default return value specified.
            4) If the return value from the function is null, it returns the default return value specified.
            </summary>
      <typeparam name="T">The type of the object</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="Object">Object to run the action on</param>
      <param name="Function">Function to run</param>
      <param name="DefaultObjectValue">Default object value</param>
      <param name="DefaultReturnValue">Default return value</param>
      <returns>The result from the function</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Execute``1(System.Func{``0},System.Int32,System.Int32,System.Int32)">
      <summary>
            Executes a function, repeating it a number of times in case it fails
            </summary>
      <typeparam name="T">Return type</typeparam>
      <param name="Function">Function to run</param>
      <param name="Attempts">Number of times to attempt it</param>
      <param name="RetryDelay">The amount of milliseconds to wait between tries</param>
      <param name="TimeOut">Max amount of time to wait for the function to run (waits for the current attempt to finish before checking)</param>
      <returns>The returned value from the function</returns>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Execute(System.Action,System.Int32,System.Int32,System.Int32)">
      <summary>
            Executes an action, repeating it a number of times in case it fails
            </summary>
      <param name="Action">Action to run</param>
      <param name="Attempts">Number of times to attempt it</param>
      <param name="RetryDelay">The amount of milliseconds to wait between tries</param>
      <param name="TimeOut">Max amount of time to wait for the function to run (waits for the current attempt to finish before checking)</param>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Check``1(``0,System.Predicate{``0},``0)">
      <summary>
            Checks to see if the object meets all the criteria. If it does, it returns the object. If it does not, it returns the default object
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <param name="Predicate">Predicate to check the object against</param>
      <returns>The default object if it fails the criteria, the object otherwise</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Check``1(``0,System.Predicate{``0},System.Func{``0})">
      <summary>
            Checks to see if the object meets all the criteria. If it does, it returns the object. If it does not, it returns the default object
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <param name="Predicate">Predicate to check the object against</param>
      <returns>The default object if it fails the criteria, the object otherwise</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
      <requires description="DefaultValue" exception="T:System.ArgumentNullException" csharp="DefaultValue != null" vb="DefaultValue &lt;&gt; Nothing">DefaultValue != null</requires>
      <exception cref="T:System.ArgumentNullException">DefaultValue == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Check``1(``0,``0)">
      <summary>
            Checks to see if the object is null. If it is, it returns the default object, otherwise the object is returned.
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <returns>The default object if it is null, the object otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Check``1(``0,System.Func{``0})">
      <summary>
            Checks to see if the object is null. If it is, it returns the default object, otherwise the object is returned.
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to check</param>
      <param name="DefaultValue">The default value to return</param>
      <returns>The default object if it is null, the object otherwise</returns>
      <requires description="DefaultValue" exception="T:System.ArgumentNullException" csharp="DefaultValue != null" vb="DefaultValue &lt;&gt; Nothing">DefaultValue != null</requires>
      <exception cref="T:System.ArgumentNullException">DefaultValue == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Is``1(``0,System.Predicate{``0})">
      <summary>
            Determines if the object passes the predicate passed in
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to test</param>
      <param name="Predicate">Predicate to test</param>
      <returns>True if the object passes the predicate, false otherwise</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Is``1(``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is equal to a specific value
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Object">Object to test</param>
      <param name="ComparisonObject">Comparison object</param>
      <param name="Comparer">Comparer</param>
      <returns>True if the object passes the predicate, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIf``1(``0,System.Predicate{``0},System.Func{System.Exception})">
      <summary>
            Throws the specified exception if the predicate is true for the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIf``1(``0,System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is true for the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfDefault``1(``0,System.String,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is equal to default value and throws an ArgumentNullException if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">Equality comparer used to determine if the object is equal to default</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfDefault``1(``0,System.Exception,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is equal to default value and throws the exception that is passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">Equality comparer used to determine if the object is equal to default</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNotDefault``1(``0,System.String,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is not equal to default value and throws an ArgumentException if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">Equality comparer used to determine if the object is equal to default</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNotDefault``1(``0,System.Exception,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the object is not equal to default value and throws the exception that is passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="EqualityComparer">Equality comparer used to determine if the object is equal to default</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNot``1(``0,System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is false for the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is false</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNotNull``1(``0,System.String)">
      <summary>
            Determines if the object is not null and throws an ArgumentException if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNotNull``1(``0,System.Exception)">
      <summary>
            Determines if the object is not null and throws the exception passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNull``1(``0,System.String)">
      <summary>
            Determines if the object is null and throws an ArgumentNullException if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNull``1(``0,System.Exception)">
      <summary>
            Determines if the object is null and throws the exception passed in if it is
            </summary>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Determines if the IEnumerable is not null or empty and throws an ArgumentException if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNotNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Exception)">
      <summary>
            Determines if the IEnumerable is not null or empty and throws the exception passed in if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Determines if the IEnumerable is null or empty and throws an ArgumentNullException if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Name">Name of the argument</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.ThrowIfNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Exception)">
      <summary>
            Determines if the IEnumerable is null or empty and throws the exception passed in if it is
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Item">The object to check</param>
      <param name="Exception">Exception to throw</param>
      <returns>Returns Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Times``1(System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Runs a function based on the number of times specified and returns the results
            </summary>
      <typeparam name="T">Type that gets returned</typeparam>
      <param name="Count">Number of times the function should run</param>
      <param name="Function">The function that should run</param>
      <returns>The results from the function</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.GenericObjectExtensions.Times(System.Int32,System.Action{System.Int32})">
      <summary>
            Runs an action based on the number of times specified
            </summary>
      <param name="Count">Number of times to run the action</param>
      <param name="Action">Action to run</param>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions">
      <summary>
            ICollection extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.Add``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds a list of items to the collection
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection</param>
      <param name="Items">Items to add</param>
      <returns>The collection with the added items</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt; local_0_prime = New Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass1(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.Add``1(System.Collections.Generic.ICollection{``0},``0[])">
      <summary>
            Adds a list of items to the collection
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection</param>
      <param name="Items">Items to add</param>
      <returns>The collection with the added items</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt; local_0_prime = New Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass4(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.AddAndReturn``1(System.Collections.Generic.ICollection{``0},``0)">
      <summary>
            Adds an item to a list and returns the item
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Item">Item to add to the collection</param>
      <returns>The original item</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="Collection != null" vb="Collection &lt;&gt; Nothing">Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">Collection == null</exception>
      <requires description="Item" exception="T:System.ArgumentNullException" csharp="(object)Item != null" vb="((Object)Item) &lt;&gt; Nothing">(object)Item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)Item == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.AddIf``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0},``0[])">
      <summary>
            Adds items to the collection if it passes the predicate test
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <param name="Predicate">Predicate that an item needs to satisfy in order to be added</param>
      <returns>True if any are added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="Collection != null" vb="Collection &lt;&gt; Nothing">Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">Collection == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.AddIf``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <param name="Predicate">Predicate that an item needs to satisfy in order to be added</param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="Collection != null" vb="Collection &lt;&gt; Nothing">Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">Collection == null</exception>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.AddIfUnique``1(System.Collections.Generic.ICollection{``0},``0[])">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt; local_0_prime = New Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass7(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.AddIfUnique``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds an item to the collection if it isn't already in the collection
            </summary>
      <typeparam name="T">Collection type</typeparam>
      <param name="Collection">Collection to add to</param>
      <param name="Items">Items to add to the collection</param>
      <returns>True if it is added, false otherwise</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){&#xD;&#xA;    Collection = Collection, &#xD;&#xA;}.Collection != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt; local_0_prime = New Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassa(Of T)();&#xD;&#xA;    (local_0_prime.Collection = Collection)&#xD;&#xA;    return local_0_prime; })().Collection &lt;&gt; Nothing">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){
    Collection = Collection, 
}.Collection != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){
    Collection = Collection, 
}.Collection == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.Remove``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
      <summary>
            Removes all items that fit the predicate passed in
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection to remove items from</param>
      <param name="Predicate">Predicate used to determine what items to remove</param>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassd&lt;T&gt;().Predicate = Predicate;&#xD;&#xA;    }&#xD;&#xA;    return Collection != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassd(Of T)().Predicate = Predicate&#xD;&#xA;    return Collection &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassd&lt;T&gt;().Predicate = Predicate;
    }
    return Collection != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClassd&lt;T&gt;().Predicate = Predicate);
    }
    return (Collection != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.Remove``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Removes all items in the list from the collection
            </summary>
      <typeparam name="T">The type of the items in the collection</typeparam>
      <param name="Collection">Collection</param>
      <param name="Items">Items to remove</param>
      <returns>The collection with the items removed</returns>
      <requires description="Collection" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt;().Items = Items;&#xD;&#xA;    }&#xD;&#xA;    return Collection != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass10(Of T)().Items = Items&#xD;&#xA;    return Collection &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt;().Items = Items;
    }
    return Collection != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ExtensionMethods.ICollectionExtensions.&lt;&gt;c__DisplayClass10&lt;T&gt;().Items = Items);
    }
    return (Collection != null); })()</exception>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.IComparableExtensions">
      <summary>
            IComparable extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IComparableExtensions.Between``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Checks if an item is between two values
            </summary>
      <typeparam name="T">Type of the value</typeparam>
      <param name="Value">Value to check</param>
      <param name="Min">Minimum value</param>
      <param name="Max">Maximum value</param>
      <param name="Comparer">Comparer used to compare the values (defaults to GenericComparer)"</param>
      <returns>True if it is between the values, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IComparableExtensions.Clamp``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Clamps a value between two values
            </summary>
      <param name="Value">Value sent in</param>
      <param name="Max">Max value it can be (inclusive)</param>
      <param name="Min">Min value it can be (inclusive)</param>
      <param name="Comparer">Comparer to use (defaults to GenericComparer)</param>
      <returns>The value set between Min and Max</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IComparableExtensions.Max``1(``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the maximum value between the two
            </summary>
      <param name="InputA">Input A</param>
      <param name="InputB">Input B</param>
      <param name="Comparer">Comparer to use (defaults to GenericComparer)</param>
      <returns>The maximum value</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IComparableExtensions.Min``1(``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the minimum value between the two
            </summary>
      <param name="InputA">Input A</param>
      <param name="InputB">Input B</param>
      <param name="Comparer">Comparer to use (defaults to GenericComparer)</param>
      <returns>The minimum value</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.IDictionaryExtensions">
      <summary>
            IDictionary extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Gets the value from a dictionary or the default value if it isn't found
            </summary>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
      <param name="Dictionary">Dictionary to get the value from</param>
      <param name="Key">Key to look for</param>
      <param name="Default">Default value if the key is not found</param>
      <returns>The value associated with the key or the default value if the key is not found</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if the dictionary is null</exception>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IDictionaryExtensions.SetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Sets the value in a dictionary
            </summary>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
      <param name="Dictionary">Dictionary to set the value in</param>
      <param name="Key">Key to look for</param>
      <param name="Value">Value to add</param>
      <returns>The dictionary</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if the dictionary is null</exception>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IDictionaryExtensions.Sort``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a dictionary
            </summary>
      <typeparam name="T1">Key type</typeparam>
      <typeparam name="T2">Value type</typeparam>
      <param name="Dictionary">Dictionary to sort</param>
      <param name="Comparer">Comparer used to sort (defaults to GenericComparer)</param>
      <returns>The sorted dictionary</returns>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IDictionaryExtensions.Sort``3(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},``2},System.Collections.Generic.IComparer{``2})">
      <summary>
            Sorts a dictionary
            </summary>
      <typeparam name="T1">Key type</typeparam>
      <typeparam name="T2">Value type</typeparam>
      <typeparam name="T3">Order by type</typeparam>
      <param name="Dictionary">Dictionary to sort</param>
      <param name="OrderBy">Function used to order the dictionary</param>
      <param name="Comparer">Comparer used to sort (defaults to GenericComparer)</param>
      <returns>The sorted dictionary</returns>
      <requires description="Dictionary" exception="T:System.ArgumentNullException" csharp="Dictionary != null" vb="Dictionary &lt;&gt; Nothing">Dictionary != null</requires>
      <exception cref="T:System.ArgumentNullException">Dictionary == null</exception>
      <requires description="OrderBy" exception="T:System.ArgumentNullException" csharp="OrderBy != null" vb="OrderBy &lt;&gt; Nothing">OrderBy != null</requires>
      <exception cref="T:System.ArgumentNullException">OrderBy == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions">
      <summary>
            IEnumerable extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Combines multiple IEnumerables together and returns a new IEnumerable containing all of the values
            </summary>
      <typeparam name="T">Type of the data in the IEnumerable</typeparam>
      <param name="Enumerable1">IEnumerable 1</param>
      <param name="Additions">IEnumerables to concat onto the first item</param>
      <returns>A new IEnumerable containing all values</returns>
      <example>
        <code>
             int[] TestObject1 = new int[] { 1, 2, 3 };
             int[] TestObject2 = new int[] { 4, 5, 6 };
             int[] TestObject3 = new int[] { 7, 8, 9 };
             TestObject1 = TestObject1.Concat(TestObject2, TestObject3).ToArray();
            </code>
      </example>
      <requires description="Enumerable1" exception="T:System.ArgumentNullException" csharp="Enumerable1 != null" vb="Enumerable1 &lt;&gt; Nothing">Enumerable1 != null</requires>
      <exception cref="T:System.ArgumentNullException">Enumerable1 == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="Additions != null" vb="Additions &lt;&gt; Nothing">Additions != null</requires>
      <exception cref="T:System.ArgumentNullException">Additions == null</exception>
      <requires description="Additions" exception="T:System.ArgumentNullException" csharp="for all x in Additions x != null" vb="for all x in Additions x &lt;&gt; Nothing">for all x in Additions x != null</requires>
      <exception cref="T:System.ArgumentNullException">!System.Diagnostics.Contracts.Contract.ForAll&lt;System.Collections.Generic.IEnumerable&lt;T&gt;&gt;(Additions, (System.Collections.Generic.IEnumerable&lt;T&gt; x) =&gt; (x != null))</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ElementsBetween``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
      <summary>
            Returns elements starting at the index and ending at the end index
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">List to search</param>
      <param name="Start">Start index (inclusive)</param>
      <param name="End">End index (exclusive)</param>
      <returns>The items between the start and end index</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.For``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable between the start and end indexes
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.For``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Func{``0,``1})">
      <summary>
            Does a function for each item in the IEnumerable between the start and end indexes and returns an IEnumerable of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Function">Function to do</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Does a function for each item in the IEnumerable, returning a list of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Exception})">
      <summary>
            Does an action for each item in the IEnumerable
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="CatchAction != null" vb="CatchAction &lt;&gt; Nothing">CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``0,System.Exception})">
      <summary>
            Does a function for each item in the IEnumerable, returning a list of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="CatchAction != null" vb="CatchAction &lt;&gt; Nothing">CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForParallel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable between the start and end indexes in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt;();&#xD;&#xA;        local_0.List = List;&#xD;&#xA;        local_0.Action = Action;&#xD;&#xA;    }&#xD;&#xA;    return local_0.List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = New Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2(Of T)();&#xD;&#xA;    local_0.List = List&#xD;&#xA;    local_0.Action = Action&#xD;&#xA;    return local_0.List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt;();
        local_0.List = List;
        local_0.Action = Action;
    }
    return local_0.List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass2&lt;T&gt;();
        (local_0.List = List);
        (local_0.Action = Action);
    }
    return (local_0.List != null); })()</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="local_0.Action != null" vb="local_0.Action &lt;&gt; Nothing">local_0.Action != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForParallel``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Func{``0,``1})">
      <summary>
            Does an action for each item in the IEnumerable between the start and end indexes in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Results type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Start">Item to start with</param>
      <param name="End">Item to end with</param>
      <param name="Function">Function to do</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt;();&#xD;&#xA;        local_0.List = List;&#xD;&#xA;        local_0.Start = Start;&#xD;&#xA;        local_0.Function = Function;&#xD;&#xA;    }&#xD;&#xA;    return local_0.List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = New Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5(Of T, R)();&#xD;&#xA;    local_0.List = List&#xD;&#xA;    local_0.Start = Start&#xD;&#xA;    local_0.Function = Function&#xD;&#xA;    return local_0.List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt;();
        local_0.List = List;
        local_0.Start = Start;
        local_0.Function = Function;
    }
    return local_0.List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass5&lt;T, R&gt;();
        (local_0.List = List);
        (local_0.Start = Start);
        (local_0.Function = Function);
    }
    return (local_0.List != null); })()</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="local_0.Function != null" vb="local_0.Function &lt;&gt; Nothing">local_0.Function != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEachParallel``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Does an action for each item in the IEnumerable in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="Action != null" vb="Action &lt;&gt; Nothing">Action != null</requires>
      <exception cref="T:System.ArgumentNullException">Action == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEachParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Does an action for each item in the IEnumerable in parallel
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Results type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <returns>The results in an IEnumerable list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="Function != null" vb="Function &lt;&gt; Nothing">Function != null</requires>
      <exception cref="T:System.ArgumentNullException">Function == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEachParallel``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0,System.Exception})">
      <summary>
            Does an action for each item in the IEnumerable
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Action">Action to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The original list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;();&#xD;&#xA;        local_0.Action = Action;&#xD;&#xA;        local_0.CatchAction = CatchAction;&#xD;&#xA;    }&#xD;&#xA;    return List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = New Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8(Of T)();&#xD;&#xA;    local_0.Action = Action&#xD;&#xA;    local_0.CatchAction = CatchAction&#xD;&#xA;    return List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;();
        local_0.Action = Action;
        local_0.CatchAction = CatchAction;
    }
    return List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;();
        (local_0.Action = Action);
        (local_0.CatchAction = CatchAction);
    }
    return (List != null); })()</exception>
      <requires description="Action" exception="T:System.ArgumentNullException" csharp="local_0.Action != null" vb="local_0.Action &lt;&gt; Nothing">local_0.Action != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Action == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="local_0.CatchAction != null" vb="local_0.CatchAction &lt;&gt; Nothing">local_0.CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ForEachParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``0,System.Exception})">
      <summary>
            Does a function for each item in the IEnumerable, returning a list of the results
            </summary>
      <typeparam name="T">Object type</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Function">Function to do</param>
      <param name="CatchAction">Action that occurs if an exception occurs</param>
      <returns>The resulting list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt;();&#xD;&#xA;        local_0.Function = Function;&#xD;&#xA;        local_0.CatchAction = CatchAction;&#xD;&#xA;    }&#xD;&#xA;    return List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = New Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb(Of T, R)();&#xD;&#xA;    local_0.Function = Function&#xD;&#xA;    local_0.CatchAction = CatchAction&#xD;&#xA;    return List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt;();
        local_0.Function = Function;
        local_0.CatchAction = CatchAction;
    }
    return List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassb&lt;T, R&gt;();
        (local_0.Function = Function);
        (local_0.CatchAction = CatchAction);
    }
    return (List != null); })()</exception>
      <requires description="Function" exception="T:System.ArgumentNullException" csharp="local_0.Function != null" vb="local_0.Function &lt;&gt; Nothing">local_0.Function != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.Function == null</exception>
      <requires description="CatchAction" exception="T:System.ArgumentNullException" csharp="local_0.CatchAction != null" vb="local_0.CatchAction &lt;&gt; Nothing">local_0.CatchAction != null</requires>
      <exception cref="T:System.ArgumentNullException">local_0.CatchAction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.Last``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Returns the last X number of items from the list
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">IEnumerable to iterate over</param>
      <param name="Count">Numbers of items to return</param>
      <returns>The last X items from the list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.PositionOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines the position of an object if it is present, otherwise it returns -1
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="List">List of objects to search</param>
      <param name="Object">Object to find the position of</param>
      <param name="EqualityComparer">Equality comparer used to determine if the object is present</param>
      <returns>The position of the object if it is present, otherwise -1</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.Remove``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Removes values from a list that meet the criteria set forth by the predicate
            </summary>
      <typeparam name="T">Value type</typeparam>
      <param name="Value">List to cull items from</param>
      <param name="Predicate">Predicate that determines what items to remove</param>
      <returns>An IEnumerable with the objects that meet the criteria removed</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt;(){&#xD;&#xA;    Predicate = Predicate, &#xD;&#xA;}.Predicate != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt; local_0_prime = New Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassf(Of T)();&#xD;&#xA;    (local_0_prime.Predicate = Predicate)&#xD;&#xA;    return local_0_prime; })().Predicate &lt;&gt; Nothing">new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt;(){
    Predicate = Predicate, 
}.Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClassf&lt;T&gt;(){
    Predicate = Predicate, 
}.Predicate == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Converts a list to an array
            </summary>
      <typeparam name="Source">Source type</typeparam>
      <typeparam name="Target">Target type</typeparam>
      <param name="List">List to convert</param>
      <param name="ConvertingFunction">Function used to convert each item</param>
      <returns>The array containing the items from the list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="ConvertingFunction" exception="T:System.ArgumentNullException" csharp="ConvertingFunction != null" vb="ConvertingFunction &lt;&gt; Nothing">ConvertingFunction != null</requires>
      <exception cref="T:System.ArgumentNullException">ConvertingFunction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ToDataTable``1(System.Collections.Generic.IEnumerable{``0},System.String[])">
      <summary>
            Converts the IEnumerable to a DataTable
            </summary>
      <typeparam name="T">Type of the objects in the IEnumerable</typeparam>
      <param name="List">List to convert</param>
      <param name="Columns">Column names (if empty, uses property names)</param>
      <returns>The list as a DataTable</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Converts an IEnumerable to a list
            </summary>
      <typeparam name="Source">Source type</typeparam>
      <typeparam name="Target">Target type</typeparam>
      <param name="List">IEnumerable to convert</param>
      <param name="ConvertingFunction">Function used to convert each item</param>
      <returns>The list containing the items from the IEnumerable</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="List != null" vb="List &lt;&gt; Nothing">List != null</requires>
      <exception cref="T:System.ArgumentNullException">List == null</exception>
      <requires description="ConvertingFunction" exception="T:System.ArgumentNullException" csharp="ConvertingFunction != null" vb="ConvertingFunction &lt;&gt; Nothing">ConvertingFunction != null</requires>
      <exception cref="T:System.ArgumentNullException">ConvertingFunction == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
      <summary>
            Converts the list to a string where each item is seperated by the Seperator
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">List to convert</param>
      <param name="ItemOutput">Used to convert the item to a string (defaults to calling ToString)</param>
      <param name="Seperator">Seperator to use between items (defaults to ,)</param>
      <returns>The string version of the list</returns>
      <requires description="List" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt;();&#xD;&#xA;        local_0.ItemOutput = ItemOutput;&#xD;&#xA;        local_0.Seperator = Seperator;&#xD;&#xA;    }&#xD;&#xA;    return List != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = New Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e(Of T)();&#xD;&#xA;    local_0.ItemOutput = ItemOutput&#xD;&#xA;    local_0.Seperator = Seperator&#xD;&#xA;    return List &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt;();
        local_0.ItemOutput = ItemOutput;
        local_0.Seperator = Seperator;
    }
    return List != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt; local_0 = new Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.&lt;&gt;c__DisplayClass1e&lt;T&gt;();
        (local_0.ItemOutput = ItemOutput);
        (local_0.Seperator = Seperator);
    }
    return (List != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ThrowIfAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Func{System.Exception})">
      <summary>
            Throws the specified exception if the predicate is true for all items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ThrowIfAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is true for all items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ThrowIfAny``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Func{System.Exception})">
      <summary>
            Throws the specified exception if the predicate is true for any items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.IEnumerableExtensions.ThrowIfAny``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Exception)">
      <summary>
            Throws the specified exception if the predicate is true for any items
            </summary>
      <typeparam name="T">Item type</typeparam>
      <param name="List">The item</param>
      <param name="Predicate">Predicate to check</param>
      <param name="Exception">Exception to throw if predicate is true</param>
      <returns>the original Item</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.MatchCollectionExtensions">
      <summary>
            MatchCollection extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.MatchCollectionExtensions.Where(System.Text.RegularExpressions.MatchCollection,System.Predicate{System.Text.RegularExpressions.Match})">
      <summary>
            Gets a list of items that satisfy the predicate from the collection
            </summary>
      <param name="Collection">Collection to search through</param>
      <param name="Predicate">Predicate that the items must satisfy</param>
      <returns>The matches that satisfy the predicate</returns>
      <requires description="Predicate" exception="T:System.ArgumentNullException" csharp="Predicate != null" vb="Predicate &lt;&gt; Nothing">Predicate != null</requires>
      <exception cref="T:System.ArgumentNullException">Predicate == null</exception>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.StreamExtensions">
      <summary>
            Extension methods for Streams
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StreamExtensions.ReadAllBinary(System.IO.Stream)">
      <summary>
            Takes all of the data in the stream and returns it as an array of bytes
            </summary>
      <param name="Input">Input stream</param>
      <returns>A byte array</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StreamExtensions.ReadAll(System.IO.Stream,System.Text.Encoding)">
      <summary>
            Takes all of the data in the stream and returns it as a string
            </summary>
      <param name="Input">Input stream</param>
      <param name="EncodingUsing">Encoding that the string should be in (defaults to UTF8)</param>
      <returns>A string containing the content of the stream</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.TimeSpanExtensions">
      <summary>
            TimeSpan extension methods
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TimeSpanExtensions.DaysRemainder(System.TimeSpan)">
      <summary>
            Days in the TimeSpan minus the months and years
            </summary>
      <param name="Span">TimeSpan to get the days from</param>
      <returns>The number of days minus the months and years that the TimeSpan has</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TimeSpanExtensions.Months(System.TimeSpan)">
      <summary>
            Months in the TimeSpan
            </summary>
      <param name="Span">TimeSpan to get the months from</param>
      <returns>The number of months that the TimeSpan has</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TimeSpanExtensions.Years(System.TimeSpan)">
      <summary>
            Years in the TimeSpan
            </summary>
      <param name="Span">TimeSpan to get the years from</param>
      <returns>The number of years that the TimeSpan has</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TimeSpanExtensions.ToStringFull(System.TimeSpan)">
      <summary>
            Converts the input to a string in this format:
            (Years) years, (Months) months, (DaysRemainder) days, (Hours) hours, (Minutes) minutes, (Seconds) seconds
            </summary>
      <param name="Input">Input TimeSpan</param>
      <returns>The TimeSpan as a string</returns>
    </member>
    <member name="T:Utilities.DataTypes.Formatters.GenericStringFormatter">
      <summary>
            Generic string formatter
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.GetFormat(System.Type)">
      <summary>
            Gets the format associated with the type
            </summary>
      <param name="formatType">Format type</param>
      <returns>The appropriate formatter based on the type</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.Format(System.String,System.Object,System.IFormatProvider)">
      <summary>
            Formats the string
            </summary>
      <param name="format">Format to use</param>
      <param name="arg">Argument object to use</param>
      <param name="formatProvider">Format provider to use</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.Format(System.String,System.String)">
      <summary>
            Formats the string based on the pattern
            </summary>
      <param name="Input">Input string</param>
      <param name="FormatPattern">Format pattern</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.GetMatchingInput(System.String,System.Char,System.Char@)">
      <summary>
            Gets matching input
            </summary>
      <param name="Input">Input string</param>
      <param name="FormatChar">Current format character</param>
      <param name="MatchChar">The matching character found</param>
      <returns>The remainder of the input string left</returns>
    </member>
    <member name="M:Utilities.DataTypes.Formatters.GenericStringFormatter.IsValid(System.String)">
      <summary>
            Checks if the format pattern is valid
            </summary>
      <param name="FormatPattern">Format pattern</param>
      <returns>Returns true if it's valid, otherwise false</returns>
    </member>
    <member name="P:Utilities.DataTypes.Formatters.GenericStringFormatter.DigitChar">
      <summary>
            Represents digits (defaults to #)
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Formatters.GenericStringFormatter.AlphaChar">
      <summary>
            Represents alpha characters (defaults to @)
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Formatters.GenericStringFormatter.EscapeChar">
      <summary>
            Represents the escape character (defaults to \)
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.StringTemplate">
      <summary>
            Acts as a template for a string
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Template">Template</param>
      <param name="KeyEnd">Ending signifier of a key</param>
      <param name="KeyStart">Starting signifier of a key</param>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor
            </summary>
      <param name="Info">Serialization info</param>
      <param name="Context">Streaming context</param>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.ToString">
      <summary>
            Applies the key/values to the template and returns the resulting string
            </summary>
      <returns>The resulting string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Implements the ISerializable interface and returns the data needed to serialize the dictionary instance
            </summary>
      <param name="info">Serialization info</param>
      <param name="context">Streaming context</param>
    </member>
    <member name="M:Utilities.DataTypes.StringTemplate.op_Implicit(Utilities.DataTypes.StringTemplate)~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
    </member>
    <member name="P:Utilities.DataTypes.StringTemplate.Template">
      <summary>
            Template
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.StringTemplate.KeyStart">
      <summary>
            Beginning signifier of a key
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.StringTemplate.KeyEnd">
      <summary>
            Ending signifier of a key
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Table">
      <summary>
            Holds tabular information
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Table.#ctor(System.String[])">
      <summary>
            Constructor
            </summary>
      <param name="ColumnNames">Column names</param>
    </member>
    <member name="M:Utilities.DataTypes.Table.#ctor(System.Data.IDataReader)">
      <summary>
            Constructor
            </summary>
      <param name="Reader">Data reader to get the data from</param>
    </member>
    <member name="M:Utilities.DataTypes.Table.AddRow(System.Object[])">
      <summary>
            Adds a row using the objects passed in
            </summary>
      <param name="Objects">Objects to create the row from</param>
      <returns>This</returns>
    </member>
    <member name="P:Utilities.DataTypes.Table.ColumnNames">
      <summary>
            Column names for the table
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Table.ColumnNameHash">
      <summary>
            Column Name hash table
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Table.Rows">
      <summary>
            Rows within the table
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Table.Item(System.Int32)">
      <summary>
            Gets a specific row
            </summary>
      <param name="RowNumber">Row number</param>
      <returns>The row specified</returns>
    </member>
    <member name="T:Utilities.DataTypes.Row">
      <summary>
            Holds an individual row
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Row.#ctor(System.Collections.Hashtable,System.String[],System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="ColumnNames">Column names</param>
      <param name="ColumnValues">Column values</param>
      <param name="ColumnNameHash">Column name hash</param>
    </member>
    <member name="P:Utilities.DataTypes.Row.ColumnNameHash">
      <summary>
            Column names
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Row.ColumnNames">
      <summary>
            Column names
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Row.ColumnValues">
      <summary>
            Column values
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Row.Item(System.String)">
      <summary>
            Returns a column based on the column name specified
            </summary>
      <param name="ColumnName">Column name to search for</param>
      <returns>The value specified</returns>
    </member>
    <member name="P:Utilities.DataTypes.Row.Item(System.Int32)">
      <summary>
            Returns a column based on the value specified
            </summary>
      <param name="Column">Column number</param>
      <returns>The value specified</returns>
      <getter>
        <requires description="Column" exception="T:System.ArgumentOutOfRangeException" csharp="Column &gt;= 0" vb="Column &gt;= 0">Column &gt;= 0</requires>
      </getter>
      <exception cref="T:System.ArgumentOutOfRangeException">Column &lt; 0</exception>
    </member>
    <member name="T:Utilities.DataTypes.TagDictionary`2">
      <summary>
            Dictionary that matches multiple keys to each value
            </summary>
      <typeparam name="Key">Key type</typeparam>
      <typeparam name="Value">Value type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Add(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Adds a list of values to the key
            </summary>
      <param name="key">Key</param>
      <param name="value">Values to add</param>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Add(`1,`0[])">
      <summary>
            Adds a value to the dicionary
            </summary>
      <param name="Value">Value to add</param>
      <param name="Keys">Keys to associate the value with</param>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if a key is in the dictionary
            </summary>
      <param name="key">Key to check</param>
      <returns>True if it exists, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Remove(`0)">
      <summary>
            Removes all items that are associated with a key
            </summary>
      <param name="key">Key</param>
      <returns>Returns true if the key was found, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.TryGetValue(`0,System.Collections.Generic.IEnumerable{`1}@)">
      <summary>
            Attempts to get the values associated with a key
            </summary>
      <param name="key">Key</param>
      <param name="value">Values associated with a key</param>
      <returns>True if something is returned, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;Key, System.Collections.Generic.IEnumerable&lt;Value&gt;&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Adds an item to the dictionary
            </summary>
      <param name="item">item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Clear">
      <summary>
            Clears the dictionary
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Determines if the dictionary contains the key/value pair
            </summary>
      <param name="item">item to check</param>
      <returns>True if it is, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}}[],System.Int32)">
      <summary>
            Copies itself to an array
            </summary>
      <param name="array">Array</param>
      <param name="arrayIndex">Array index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Removes a specific key/value pair
            </summary>
      <param name="item">item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Items">
      <summary>
            Items in the dictionary
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Values">
      <summary>
            Gets the values found in the dictionary
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Keys">
      <summary>
            Gets the keys found in the dictionary
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.KeyList">
      <summary>
            List of keys that have been entered
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Item(`0)">
      <summary>
            Gets the values based on a key
            </summary>
      <param name="key">Key to get the values of</param>
      <returns>The values associated with the key</returns>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.Count">
      <summary>
            Number of items in the dictionary
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.IsReadOnly">
      <summary>
            Always false
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.TagDictionary`2.TaggedItem`2">
      <summary>
            Holds information about each value
            </summary>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.#ctor(System.Collections.Generic.IEnumerable{`2},`3)">
      <summary>
            Constructor
            </summary>
      <param name="Keys">Keys</param>
      <param name="Value">Value</param>
    </member>
    <member name="M:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.#ctor(`2,`3)">
      <summary>
            Constructor
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.Keys">
      <summary>
            The list of keys associated with the value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TagDictionary`2.TaggedItem`2.Value">
      <summary>
            Value
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Threading.TaskQueue`1">
      <summary>
            Class that helps with running tasks in parallel
            on a set of objects (that will come in on an ongoing basis, think producer/consumer situations)
            </summary>
      <typeparam name="T">Object type to process</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Threading.TaskQueue`1.#ctor(System.Int32,System.Action{`0},System.Action{System.Exception})">
      <summary>
            Constructor
            </summary>
      <param name="Capacity">Number of items that are allowed to be processed in the queue at one time</param>
      <param name="ProcessItem">Action that is used to process each item</param>
      <param name="HandleError">Handles an exception if it occurs (defaults to eating the error)</param>
    </member>
    <member name="M:Utilities.DataTypes.Threading.TaskQueue`1.Enqueue(`0)">
      <summary>
            Adds the item to the queue to be processed
            </summary>
      <param name="Item">Item to process</param>
      <requires description="TaskQueue has been stopped" exception="T:System.InvalidOperationException" csharp="!this.IsCompleted &amp;&amp; !this.IsCanceled" vb="Not Me.IsCompleted AndAlso Not Me.IsCanceled">!this.IsCompleted &amp;&amp; !this.IsCanceled</requires>
      <exception cref="T:System.InvalidOperationException">this.IsCompleted ? !false : this.IsCanceled</exception>
    </member>
    <member name="M:Utilities.DataTypes.Threading.TaskQueue`1.Cancel(System.Boolean)">
      <summary>
            Cancels the queue from processing
            </summary>
      <param name="Wait">Determines if the function should wait for the tasks to complete before returning</param>
    </member>
    <member name="M:Utilities.DataTypes.Threading.TaskQueue`1.Process">
      <summary>
            Processes the queue
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Threading.TaskQueue`1.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="P:Utilities.DataTypes.Threading.TaskQueue`1.CancellationToken">
      <summary>
            Token used to signal cancellation
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Threading.TaskQueue`1.Tasks">
      <summary>
            Group of tasks that the queue uses
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Threading.TaskQueue`1.ProcessItem">
      <summary>
            Action used to process an individual item in the queue
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Threading.TaskQueue`1.HandleError">
      <summary>
            Called when an exception occurs when processing the queue
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Threading.TaskQueue`1.IsCanceled">
      <summary>
            Determines if it has been cancelled
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Threading.TaskQueue`1.IsComplete">
      <summary>
            Determines if it has completed all tasks
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.User">
      <summary>
            Holds user data
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.User.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Computer name</param>
      <param name="Password">Password</param>
      <param name="UserName">Username</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.User.GetCurrentUser(System.String,System.String,System.String)">
      <summary>
            Gets the current user
            </summary>
      <param name="Name">Computer name</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="P:Utilities.Environment.DataTypes.User.UserNames">
      <summary>
            User names
            </summary>
    </member>
    <member name="T:Utilities.Environment.ExtensionMethods.ProcessExtensions">
      <summary>
            Process extensions
            </summary>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.ProcessExtensions.KillProcessAsync(System.Diagnostics.Process,System.Int32)">
      <summary>
            Kills a process
            </summary>
      <param name="Process">Process that should be killed</param>
      <param name="TimeToKill">Amount of time (in ms) until the process is killed.</param>
      <requires description="Process" exception="T:System.ArgumentNullException" csharp="new Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass1(){&#xD;&#xA;    Process = Process, &#xD;&#xA;    TimeToKill = TimeToKill, &#xD;&#xA;}.Process != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass1 local_0_prime = New Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass1();&#xD;&#xA;    (local_0_prime.Process = Process)&#xD;&#xA;    (local_0_prime.TimeToKill = TimeToKill)&#xD;&#xA;    return local_0_prime; })().Process &lt;&gt; Nothing">new Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass1(){
    Process = Process, 
    TimeToKill = TimeToKill, 
}.Process != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass1(){
    Process = Process, 
    TimeToKill = TimeToKill, 
}.Process == null</exception>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.ProcessExtensions.KillProcessAsync(System.Collections.Generic.IEnumerable{System.Diagnostics.Process},System.Int32)">
      <summary>
            Kills a list of processes
            </summary>
      <param name="Processes">Processes that should be killed</param>
      <param name="TimeToKill">Amount of time (in ms) until the processes are killed.</param>
      <requires description="Processes" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill;&#xD;&#xA;    }&#xD;&#xA;    return Processes != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill&#xD;&#xA;    return Processes &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill;
    }
    return Processes != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Environment.ExtensionMethods.ProcessExtensions.&lt;&gt;c__DisplayClass5().TimeToKill = TimeToKill);
    }
    return (Processes != null); })()</exception>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.ProcessExtensions.GetInformation(System.Diagnostics.Process,System.Boolean)">
      <summary>
            Gets information about all processes and returns it in an HTML formatted string
            </summary>
      <param name="Process">Process to get information about</param>
      <param name="HTMLFormat">Should this be HTML formatted?</param>
      <returns>An HTML formatted string</returns>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.ProcessExtensions.GetInformation(System.Collections.Generic.IEnumerable{System.Diagnostics.Process},System.Boolean)">
      <summary>
            Gets information about all processes and returns it in an HTML formatted string
            </summary>
      <param name="Processes">Processes to get information about</param>
      <param name="HTMLFormat">Should this be HTML formatted?</param>
      <returns>An HTML formatted string</returns>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.ProcessExtensions.KillProcessAsyncHelper(System.Diagnostics.Process,System.Int32)">
      <summary>
            Kills a process asyncronously
            </summary>
      <param name="Process">Process to kill</param>
      <param name="TimeToKill">Amount of time until the process is killed</param>
    </member>
    <member name="T:Utilities.FileFormats.BaseClasses.FormatBase`2">
      <summary>
            Format base class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.CompareTo(System.Object)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.CompareTo(`0)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="other">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.Equals(`0)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="other">Other object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.Load(System.String)">
      <summary>
            Loads the object from the location specified
            </summary>
      <param name="Location">Location of the file to load</param>
      <returns>The object specified in the location</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.InternalLoad(System.String)">
      <summary>
            Loads the object from the location specified
            </summary>
      <param name="Location">Location of the file to load</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.Save(System.String)">
      <summary>
            Saves the object
            </summary>
      <param name="Location">Location to save it to</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.Clone">
      <summary>
            Clones the object
            </summary>
      <returns>A newly cloned object</returns>
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Other object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.FormatBase`2.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="T:Utilities.FileFormats.BaseClasses.StringFormatBase`1">
      <summary>
            Format base class for objects that are string based
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.CompareTo(`0)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="other">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.Save(System.String)">
      <summary>
            Saves the object
            </summary>
      <param name="Location">Location to save it to</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.Equals(`0)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="other">Other object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.InternalLoad(System.String)">
      <summary>
            Loads the object from the location specified
            </summary>
      <param name="Location">Location of the file to load</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.Clone">
      <summary>
            Clones the object
            </summary>
      <returns>A newly cloned object</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.op_Implicit(Utilities.FileFormats.BaseClasses.StringFormatBase{`0})~System.String">
      <summary>
            Converts the format to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringFormatBase`1.op_Implicit(System.String)~Utilities.FileFormats.BaseClasses.StringFormatBase{`0}">
      <summary>
            Converts the string to the format specified
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The string as an object</returns>
    </member>
    <member name="T:Utilities.FileFormats.BaseClasses.StringListFormatBase`2">
      <summary>
            Format base class for objects that are string based and list of records
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Add(`1)">
      <summary>
            Adds a Record to the file
            </summary>
      <param name="item">Record to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Clear">
      <summary>
            Clears the file
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Contains(`1)">
      <summary>
            Determines if the file contains a Record
            </summary>
      <param name="item">Record to check for</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.CopyTo(`1[],System.Int32)">
      <summary>
            Copies the delimited file to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Remove(`1)">
      <summary>
            Removes a Record from the file
            </summary>
      <param name="item">Record to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.IndexOf(`1)">
      <summary>
            Index of a specific Record
            </summary>
      <param name="item">Record to search for</param>
      <returns>The index of a specific Record</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Insert(System.Int32,`1)">
      <summary>
            Inserts a Record at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Record to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.RemoveAt(System.Int32)">
      <summary>
            Removes a Record at a specific index
            </summary>
      <param name="index">Index of the Record to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Records">
      <summary>
            The list of records
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Item(System.Int32)">
      <summary>
            Individual records
            </summary>
      <param name="Position">The record that you want to get</param>
      <returns>The record requested</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.Count">
      <summary>
            Count of records
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.FileFormats.BaseClasses.StringListFormatBase`2.IsReadOnly">
      <summary>
            Is read only?
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.ExtensionMethods.ExtensionMethods">
      <summary>
            Extension methods pertaining to file formats
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.ExtensionMethods.ExtensionMethods.ToCSV``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts an IEnumerable to a CSV file
            </summary>
      <typeparam name="T">Type of the items within the list</typeparam>
      <param name="List">The list to convert</param>
      <returns>The CSV file containing the list</returns>
    </member>
    <member name="M:Utilities.FileFormats.ExtensionMethods.ExtensionMethods.ToDelimitedFile``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Converts an IEnumerable to a delimited file
            </summary>
      <typeparam name="T">Type of the items within the list</typeparam>
      <param name="List">The list to convert</param>
      <param name="Delimiter">Delimiter to use</param>
      <returns>The delimited file containing the list</returns>
    </member>
    <member name="M:Utilities.FileFormats.ExtensionMethods.ExtensionMethods.ToDelimitedFile(System.Data.DataTable,System.String)">
      <summary>
            Converts an IEnumerable to a delimited file
            </summary>
      <param name="Data">The DataTable to convert</param>
      <param name="Delimiter">Delimiter to use</param>
      <returns>The delimited file containing the list</returns>
    </member>
    <member name="T:Utilities.FileFormats.GenericDelimited.GenericDelimited">
      <summary>
            Generic delimited loader
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Delimited.Delimited`1">
      <summary>
            Base classs for delimited files (CSV, etc.)
            </summary>
      <typeparam name="T">Delimited</typeparam>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">File content</param>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.Parse(System.String)">
      <summary>
            Parses file content and adds it to the delimited file
            </summary>
      <param name="FileContent">File content</param>
      <requires description="FileContent" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(FileContent)" vb="Not IsNullOrEmpty(FileContent)">!string.IsNullOrEmpty(FileContent)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(FileContent)</exception>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.ToDataTable(System.Boolean,System.String[])">
      <summary>
            Converts the delimited file to a DataTable
            </summary>
      <param name="FirstRowIsHeader">Determines if the first row should be treated as a header or not</param>
      <param name="Headers">Headers for the columns if the first row is not a header</param>
      <returns>The delimited file as a DataTable</returns>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.ToString">
      <summary>
            To string function
            </summary>
      <returns>A string containing the file information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Delimited`1.op_Implicit(System.Data.DataTable)~Utilities.FileFormats.Delimited.Delimited{`0}">
      <summary>
            Converts the string to the format specified
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The string as an object</returns>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Delimited`1.Delimiter">
      <summary>
            The delimiter used to seperate values (must be overridden)
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.GenericDelimited.GenericDelimited.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.GenericDelimited.GenericDelimited.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Delimiter">Delimiter used to parse the file</param>
    </member>
    <member name="M:Utilities.FileFormats.GenericDelimited.GenericDelimited.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">File content</param>
      <param name="Delimiter">Delimiter used to parse the file</param>
    </member>
    <member name="F:Utilities.FileFormats.GenericDelimited.GenericDelimited.Delimiter_">
      <summary>
            Delimiter using
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.GenericDelimited.GenericDelimited.Delimiter">
      <summary>
            Delimiter
            </summary>
    </member>
    <member name="T:Utilities.IoC.Manager">
      <summary>
            Manager class
            </summary>
    </member>
    <member name="M:Utilities.IoC.Manager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Manager.Setup(System.Reflection.Assembly)">
      <summary>
            Loads all mapping modules found within the assembly
            </summary>
      <param name="ModuleAssembly">Module assembly</param>
    </member>
    <member name="M:Utilities.IoC.Manager.Setup(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
      <summary>
            Loads all mapping modules found within the assemblies
            </summary>
      <param name="ModuleAssemblies">Module assemblies</param>
    </member>
    <member name="M:Utilities.IoC.Manager.Setup(System.String,System.Boolean)">
      <summary>
            Loads all mapping modules found within a specific directory
            </summary>
      <param name="Directory">Directory to scan for modules</param>
      <param name="ScanSubDirectories">Determines if sub directories should be scanned</param>
    </member>
    <member name="M:Utilities.IoC.Manager.Get``1">
      <summary>
            Creates an object of the specified type
            </summary>
      <typeparam name="ServiceType">Service type</typeparam>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Manager.Get``2">
      <summary>
            Creates an object of the specified type associated with the attribute type
            </summary>
      <typeparam name="ServiceType">Service type</typeparam>
      <typeparam name="AttributeType">Attribute type</typeparam>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Manager.Get(System.Type)">
      <summary>
            Creates an object of the specified type
            </summary>
      <param name="ServiceType">Service type</param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="M:Utilities.IoC.Manager.Get(System.Type,System.Type)">
      <summary>
            Creates an object of the specified type associated with the attribute type
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <returns>An object of the specified type</returns>
    </member>
    <member name="P:Utilities.IoC.Manager.ProviderManager">
      <summary>
            Provider manager
            </summary>
    </member>
    <member name="P:Utilities.IoC.Manager.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="T:Utilities.IoC.Mappings.Attributes.Inject">
      <summary>
            Used to specify that a property or method should be set for dependency injection
            </summary>
    </member>
    <member name="T:Utilities.IoC.Mappings.BaseClasses.BaseMapping">
      <summary>
            Base mapping
            </summary>
    </member>
    <member name="T:Utilities.IoC.Mappings.Interfaces.IMapping">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.Interfaces.IMapping.To``1">
      <summary>
            Maps the service type to the specified implementation type
            </summary>
      <typeparam name="ImplementationType">Implementation type</typeparam>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.Interfaces.IMapping.To(System.Type)">
      <summary>
            Maps the service type to the specified implementation type
            </summary>
      <param name="ImplementationType">Implementation type</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.Interfaces.IMapping.To``1(System.Func{``0})">
      <summary>
            Maps the service type to the specified implementation function
            </summary>
      <param name="Implementation">Function called when type is generated</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.Interfaces.IMapping.To(Utilities.IoC.Providers.Interfaces.IImplementation)">
      <summary>
            Maps the service type to the specified implementation class
            </summary>
      <param name="Implementation">Implementation class</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.Interfaces.IMapping.SetScope(Utilities.IoC.Providers.Scope.BaseScope)">
      <summary>
            Sets the scope of the mapping
            </summary>
      <param name="Scope">Scope to use</param>
      <returns>this</returns>
    </member>
    <member name="P:Utilities.IoC.Mappings.Interfaces.IMapping.ServiceType">
      <summary>
            Service type
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.Interfaces.IMapping.AttributeType">
      <summary>
            Attribute type
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.Interfaces.IMapping.Scope">
      <summary>
            Scope used for the mapping
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.Interfaces.IMapping.Implementation">
      <summary>
            Implementation used to create this mapping
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseMapping.#ctor(System.Type,System.Type,Utilities.IoC.Providers.ProviderManager,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Constructor
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <param name="MappingManager">Mapping manager</param>
      <param name="ProviderManager">Provider manager</param>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseMapping.To``1">
      <summary>
            Maps an item to an implementation type
            </summary>
      <typeparam name="ImplementationType">Implementation type</typeparam>
      <returns>The mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseMapping.To(System.Type)">
      <summary>
            Maps an item to an implementation type
            </summary>
      <param name="ImplementationType">Implementation type</param>
      <returns>The mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseMapping.To``1(System.Func{``0})">
      <summary>
            Maps an item to an implementation function
            </summary>
      <typeparam name="ImplementationType">Implementation type</typeparam>
      <param name="Implementation">Implementation function</param>
      <returns>The mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseMapping.To(Utilities.IoC.Providers.Interfaces.IImplementation)">
      <summary>
            Maps an item to an implementation class
            </summary>
      <param name="Implementation">Implementation class</param>
      <returns>The mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseMapping.SetScope(Utilities.IoC.Providers.Scope.BaseScope)">
      <summary>
            Sets the scope for the mapping
            </summary>
      <param name="Scope">The scope to use</param>
      <returns>Mapping object</returns>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseMapping.ServiceType">
      <summary>
            Service type
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseMapping.AttributeType">
      <summary>
            Attribute type
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseMapping.Scope">
      <summary>
            Scope
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseMapping.Implementation">
      <summary>
            Implementation
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseMapping.ProviderManager">
      <summary>
            Provider manager
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseMapping.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="T:Utilities.IoC.Mappings.BaseClasses.BaseModule">
      <summary>
            Base module class
            </summary>
    </member>
    <member name="T:Utilities.IoC.Mappings.Interfaces.IModule">
      <summary>
            Mapping module interface
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.Interfaces.IModule.Setup">
      <summary>
            Called to setup the module (actual mapping occurs here)
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.Interfaces.IModule.Manager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseModule.Setup">
      <summary>
            Sets up the module
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseModule.Map``1">
      <summary>
            Creates a mapping using a specific service type
            </summary>
      <typeparam name="ServiceType">Service type</typeparam>
      <returns>A mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseModule.Map``2">
      <summary>
            Creates a mapping using a specific service type and attribute type
            </summary>
      <typeparam name="ServiceType">Service type</typeparam>
      <typeparam name="AttributeType">Attribute type</typeparam>
      <returns>A mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.BaseModule.Map(System.Type,System.Type)">
      <summary>
            Creates a mapping using a specific service type
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <returns>A mapping object</returns>
    </member>
    <member name="P:Utilities.IoC.Mappings.BaseClasses.BaseModule.Manager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="T:Utilities.IoC.Mappings.BaseClasses.MappingKey">
      <summary>
            Mapping key
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.MappingKey.#ctor(System.Type,System.Type,Utilities.IoC.Providers.ProviderManager,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Constructor
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <param name="ProviderManager">Provider manager</param>
      <param name="MappingManager">Mapping manager</param>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.MappingKey.Equals(System.Object)">
      <summary>
            Determines if the mapping keys are equal
            </summary>
      <param name="obj">The object to check against</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.BaseClasses.MappingKey.GetHashCode">
      <summary>
            Gets the hash code for this object
            </summary>
      <returns>The hash code for this object</returns>
    </member>
    <member name="T:Utilities.IoC.Mappings.Internal_Classes.Mapping">
      <summary>
            Mapping class
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.Internal_Classes.Mapping.#ctor(System.Type,Utilities.IoC.Providers.ProviderManager,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Constructor
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="MappingManager">Mapping manager</param>
      <param name="ProviderManager">Provider manager</param>
    </member>
    <member name="M:Utilities.IoC.Mappings.Internal_Classes.Mapping.#ctor(System.Type,System.Type,Utilities.IoC.Providers.ProviderManager,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Constructor
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <param name="MappingManager">Mapping manager</param>
      <param name="ProviderManager">Provider manager</param>
    </member>
    <member name="T:Utilities.IoC.Mappings.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.MappingManager.#ctor(Utilities.IoC.Providers.ProviderManager)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Mappings.MappingManager.Setup(System.Reflection.Assembly)">
      <summary>
            Scans the assembly for mapping modules and creates them
            </summary>
      <param name="ModuleAssembly" />
    </member>
    <member name="M:Utilities.IoC.Mappings.MappingManager.CreateMapping(System.Type)">
      <summary>
            Creates a mapping object
            </summary>
      <param name="ServiceType">Service type</param>
      <returns>a mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.MappingManager.CreateMapping(System.Type,System.Type)">
      <summary>
            Creates a mapping object
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <returns>A mapping object</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.MappingManager.GetMapping(System.Type)">
      <summary>
            Gets the mapping that matches this service type
            </summary>
      <param name="ServiceType">Service type</param>
      <returns>The mapping associated with this service type</returns>
    </member>
    <member name="M:Utilities.IoC.Mappings.MappingManager.GetMapping(System.Type,System.Type)">
      <summary>
            Gets the mapping that matches this service type and attribute type
            </summary>
      <param name="ServiceType">Service type</param>
      <param name="AttributeType">Attribute type</param>
      <returns>The mapping associated with this service type and attribute type</returns>
    </member>
    <member name="P:Utilities.IoC.Mappings.MappingManager.Modules">
      <summary>
            Modules listing
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.MappingManager.Mappings">
      <summary>
            Mapping listing
            </summary>
    </member>
    <member name="P:Utilities.IoC.Mappings.MappingManager.ProviderManager">
      <summary>
            Provider manager
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.BaseClasses.BaseImplementation">
      <summary>
            Base implementation class
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.Interfaces.IImplementation">
      <summary>
            Implementation interface
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.Interfaces.IImplementation.Create">
      <summary>
            Creates an object
            </summary>
      <returns>An object</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.Interfaces.IImplementation.ReturnType">
      <summary>
            Return type of the implementation
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.BaseClasses.BaseImplementation.Create">
      <summary>
            Creates an object
            </summary>
      <returns>An object</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.BaseClasses.BaseImplementation.ReturnType">
      <summary>
            Return type of the implementation
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.DefaultProviders.Standard">
      <summary>
            Standard provider
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.Interfaces.IProvider">
      <summary>
            Provider interface
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.Interfaces.IProvider.CreateImplementation(System.Type,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Creates an implementation based off of a type
            </summary>
      <param name="ImplementationType">Implementation type</param>
      <param name="MappingManager">Mapping manager</param>
      <returns>an implementation class</returns>
    </member>
    <member name="M:Utilities.IoC.Providers.Interfaces.IProvider.CreateImplementation``1(System.Func{``0})">
      <summary>
            Creates an implementation that uses a specified function
            </summary>
      <param name="Implementation">Implementation delegate</param>
      <returns>An implementation class</returns>
    </member>
    <member name="M:Utilities.IoC.Providers.Interfaces.IProvider.CreateImplementation(Utilities.IoC.Providers.Interfaces.IImplementation,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Creates an implementation based off an existing implementation
            </summary>
      <param name="Implementation">Implementation class</param>
      <param name="MappingManager">Mapping manager</param>
      <returns>Potentially a new implementation class (if appropriate)</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.Interfaces.IProvider.ProviderScope">
      <summary>
            Provider scope
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.DefaultProviders.Standard.CreateImplementation(System.Type,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Creates an implementation based off of a type
            </summary>
      <param name="ImplementationType">Implementation type</param>
      <param name="MappingManager">Mapping manager</param>
      <returns>an implementation class</returns>
    </member>
    <member name="M:Utilities.IoC.Providers.DefaultProviders.Standard.CreateImplementation(Utilities.IoC.Providers.Interfaces.IImplementation,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Creates an implementation based off an existing implementation
            </summary>
      <param name="Implementation">Implementation class</param>
      <param name="MappingManager">Mapping manager</param>
      <returns>Potentially a new implementation class (if appropriate)</returns>
    </member>
    <member name="M:Utilities.IoC.Providers.DefaultProviders.Standard.CreateImplementation``1(System.Func{``0})">
      <summary>
            Creates an implementation that uses a specified function
            </summary>
      <param name="Implementation">Implementation delegate</param>
      <returns>An implementation class</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.DefaultProviders.Standard.ProviderScope">
      <summary>
            Provider scope
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.Implementations.Delegate`1">
      <summary>
            Delegate implementation
            </summary>
      <typeparam name="T">Return type of the delegate</typeparam>
    </member>
    <member name="M:Utilities.IoC.Providers.Implementations.Delegate`1.#ctor(System.Func{`0})">
      <summary>
            Constructor
            </summary>
      <param name="Implementation">Implementation delegate</param>
    </member>
    <member name="M:Utilities.IoC.Providers.Implementations.Delegate`1.Create">
      <summary>
            Creates an object based on a delegate
            </summary>
      <returns>An object</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.Implementations.Delegate`1.Implementation">
      <summary>
            Delegate used to create objects
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.Implementations.Standard">
      <summary>
            Standard implementation class
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.Implementations.Standard.#ctor(System.Type,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Constructor
            </summary>
      <param name="ImplementationType">Implementation type</param>
      <param name="MappingManager">Mapping manager</param>
    </member>
    <member name="M:Utilities.IoC.Providers.Implementations.Standard.Create">
      <summary>
            Creates an object
            </summary>
      <returns>The object</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.Implementations.Standard.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.ProviderManager">
      <summary>
            Provider manager
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.ProviderManager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.ProviderManager.Setup(System.Reflection.Assembly)">
      <summary>
            Sets up all providers found within the assembly specified
            </summary>
      <param name="Assembly">Assembly to scan</param>
    </member>
    <member name="M:Utilities.IoC.Providers.ProviderManager.GetProvider(Utilities.IoC.Providers.Scope.BaseScope)">
      <summary>
            Gets the specified provider based on the scope specified
            </summary>
      <param name="Scope">Scope</param>
      <returns>The specified provider</returns>
    </member>
    <member name="P:Utilities.IoC.Providers.ProviderManager.Providers">
      <summary>
            List of providers
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.Scope.BaseScope">
      <summary>
            Base scope class
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.Scope.BaseScope.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.Scope.BaseScope.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to check against</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.IoC.Providers.Scope.BaseScope.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.IoC.Providers.Scope.BaseScope.ToString">
      <summary>
            Converts the scope to a string
            </summary>
      <returns>The scope as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.IoC.Providers.Scope.BaseScope.Name">
      <summary>
            Name of the scope
            </summary>
    </member>
    <member name="T:Utilities.IoC.Providers.Scope.StandardScope">
      <summary>
            Standard scope
            </summary>
    </member>
    <member name="M:Utilities.IoC.Providers.Scope.StandardScope.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.IoC.Providers.Scope.StandardScope.Name">
      <summary>
            The name of the scope
            </summary>
    </member>
    <member name="T:Utilities.IoC.Utils.ConstructorList">
      <summary>
            Utility functions that deal with constructors for an object
            </summary>
    </member>
    <member name="M:Utilities.IoC.Utils.ConstructorList.ChooseConstructor(System.Type,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Chooses a constructor
            </summary>
      <param name="ImplementationType">Type of the class</param>
      <param name="MappingManager">Mapping manager</param>
      <returns>The most appropriate constructor</returns>
    </member>
    <member name="M:Utilities.IoC.Utils.ConstructorList.GetParameterCount(System.Reflection.ConstructorInfo,Utilities.IoC.Mappings.MappingManager)">
      <summary>
            Gets the number of parameters that the system recognizes
            </summary>
      <param name="Constructor">Constructor to check</param>
      <param name="MappingManager">Mapping manager</param>
      <returns>The number of parameters that it has knoweledge of</returns>
    </member>
    <member name="T:Utilities.IO.ExtensionMethods.StringExtensions">
      <summary>
            Extension methods for strings
            </summary>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.StringExtensions.RemoveIllegalDirectoryNameCharacters(System.String,System.Char)">
      <summary>
            Removes illegal characters from a directory
            </summary>
      <param name="DirectoryName">Directory name</param>
      <param name="ReplacementChar">Replacement character</param>
      <returns>DirectoryName with all illegal characters replaced with ReplacementChar</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.StringExtensions.RemoveIllegalFileNameCharacters(System.String,System.Char)">
      <summary>
            Removes illegal characters from a file
            </summary>
      <param name="FileName">File name</param>
      <param name="ReplacementChar">Replacement character</param>
      <returns>FileName with all illegal characters replaced with ReplacementChar</returns>
    </member>
    <member name="T:Utilities.IO.Serializers.BinarySerializer">
      <summary>
            Binary serializer
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.Interfaces.ISerializer`1">
      <summary>
            Serializer interface
            </summary>
      <typeparam name="T">Type that the object is serialized to/from</typeparam>
    </member>
    <member name="M:Utilities.IO.Serializers.Interfaces.ISerializer`1.Serialize(System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="Object">Object to serialize</param>
      <returns>The serialized object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.Interfaces.ISerializer`1.Deserialize(`0,System.Type)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The resulting object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.BinarySerializer.Serialize(System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="Object">Object to serialize</param>
      <returns>The serialized object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.BinarySerializer.Deserialize(System.Byte[],System.Type)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The resulting object</returns>
    </member>
    <member name="T:Utilities.IO.Serializers.JSONSerializer">
      <summary>
            JSON serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.JSONSerializer.#ctor(System.Text.Encoding)">
      <summary>
            Constructor
            </summary>
      <param name="EncodingUsing">Encoding that the serializer should use (defaults to ASCII)</param>
    </member>
    <member name="M:Utilities.IO.Serializers.JSONSerializer.Serialize(System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="Object">Object to serialize</param>
      <returns>The serialized object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.JSONSerializer.Deserialize(System.String,System.Type)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The resulting object</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.JSONSerializer.EncodingUsing">
      <summary>
            Encoding that the serializer should use
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.SOAPSerializer">
      <summary>
            SOAP serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.SOAPSerializer.#ctor(System.Text.Encoding)">
      <summary>
            Constructor
            </summary>
      <param name="EncodingUsing">Encoding that the serializer should use (defaults to ASCII)</param>
    </member>
    <member name="M:Utilities.IO.Serializers.SOAPSerializer.Serialize(System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="Object">Object to serialize</param>
      <returns>The serialized object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.SOAPSerializer.Deserialize(System.String,System.Type)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The resulting object</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.SOAPSerializer.EncodingUsing">
      <summary>
            Encoding that the serializer should use
            </summary>
    </member>
    <member name="T:Utilities.IO.Serializers.XMLSerializer">
      <summary>
            XML serializer
            </summary>
    </member>
    <member name="M:Utilities.IO.Serializers.XMLSerializer.#ctor(System.Text.Encoding)">
      <summary>
            Constructor
            </summary>
      <param name="EncodingUsing">Encoding that the serializer should use (defaults to ASCII)</param>
    </member>
    <member name="M:Utilities.IO.Serializers.XMLSerializer.Serialize(System.Object)">
      <summary>
            Serializes the object
            </summary>
      <param name="Object">Object to serialize</param>
      <returns>The serialized object</returns>
    </member>
    <member name="M:Utilities.IO.Serializers.XMLSerializer.Deserialize(System.String,System.Type)">
      <summary>
            Deserializes the data
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Data">Data to deserialize</param>
      <returns>The resulting object</returns>
    </member>
    <member name="P:Utilities.IO.Serializers.XMLSerializer.EncodingUsing">
      <summary>
            Encoding that the serializer should use
            </summary>
    </member>
    <member name="T:Utilities.Math.ExtensionMethods.PredicateExtensions">
      <summary>
            Predicate extensions
            </summary>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.AddToSet``1(System.Predicate{``0},``0[])">
      <summary>
            Adds the given values to the predicate set
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate">Predicate to add to</param>
      <param name="Values">Values to add</param>
      <returns>The resulting predicate set</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.CartesianProduct``2(System.Predicate{``0},System.Predicate{``1})">
      <summary>
            Treats the predicates as sets and does a cartesian product of them
            </summary>
      <typeparam name="T1">Type 1</typeparam>
      <typeparam name="T2">Type 2</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The cartesian product</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.Difference``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats the predicates as sets and does a difference
            </summary>
      <typeparam name="T">Data Type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The difference of the two predicates</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.Intersect``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats predicates as sets and intersects them together
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The intersected predicate</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.RelativeComplement``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats predicates as sets and returns the relative complement
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The relative complement</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.RemoveFromSet``1(System.Predicate{``0},``0[])">
      <summary>
            Removes the values from the predicate set
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate">Predicate</param>
      <param name="Values">Values to remove</param>
      <returns>The resulting set</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PredicateExtensions.Union``1(System.Predicate{``0},System.Predicate{``0})">
      <summary>
            Treats predicates as sets and unions them together
            </summary>
      <typeparam name="T">Data type</typeparam>
      <param name="Predicate1">Predicate 1</param>
      <param name="Predicate2">Predicate 2</param>
      <returns>The unioned predicate</returns>
    </member>
    <member name="T:Utilities.Math.Fraction">
      <summary>
            Represents a fraction
            </summary>
    </member>
    <member name="M:Utilities.Math.Fraction.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.Math.Fraction.#ctor(System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.Math.Fraction.#ctor(System.Decimal,System.Decimal)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.Math.Fraction.#ctor(System.Single,System.Single)">
      <summary>
            Constructor
            </summary>
      <param name="Numerator">Numerator</param>
      <param name="Denominator">Denominator</param>
    </member>
    <member name="M:Utilities.Math.Fraction.ToString">
      <summary>
            Displays the fraction as a string
            </summary>
      <returns>The fraction as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Math.Fraction.GetHashCode">
      <summary>
            Gets the hash code of the fraction
            </summary>
      <returns>The hash code of the fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.Equals(System.Object)">
      <summary>
            Determines if the fractions are equal
            </summary>
      <param name="obj">object to check</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.Reduce">
      <summary>
            Reduces the fraction (finds the greatest common denominator and divides the numerator/denominator by it).
            </summary>
    </member>
    <member name="M:Utilities.Math.Fraction.Inverse">
      <summary>
            Returns the inverse of the fraction
            </summary>
      <returns>The inverse</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Equality(Utilities.Math.Fraction,Utilities.Math.Fraction)">
      <summary>
            Equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Equality(Utilities.Math.Fraction,System.Double)">
      <summary>
            Equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Equality(System.Double,Utilities.Math.Fraction)">
      <summary>
            Equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Inequality(Utilities.Math.Fraction,Utilities.Math.Fraction)">
      <summary>
            Not equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Inequality(Utilities.Math.Fraction,System.Double)">
      <summary>
            Not equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Inequality(System.Double,Utilities.Math.Fraction)">
      <summary>
            Not equals operator
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(Utilities.Math.Fraction)~System.Double">
      <summary>
            Converts the fraction to a double
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a double</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(Utilities.Math.Fraction)~System.Decimal">
      <summary>
            Converts the fraction to a decimal
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a decimal</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(Utilities.Math.Fraction)~System.Single">
      <summary>
            Converts the fraction to a float
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a float</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(System.Double)~Utilities.Math.Fraction">
      <summary>
            Converts the double to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The double as a fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(System.Decimal)~Utilities.Math.Fraction">
      <summary>
            Converts the decimal to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The decimal as a fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(System.Single)~Utilities.Math.Fraction">
      <summary>
            Converts the float to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The float as a fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(System.Int32)~Utilities.Math.Fraction">
      <summary>
            Converts the int to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The int as a fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(System.UInt32)~Utilities.Math.Fraction">
      <summary>
            Converts the uint to a fraction
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The uint as a fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Implicit(Utilities.Math.Fraction)~System.String">
      <summary>
            Converts the fraction to a string
            </summary>
      <param name="Fraction">Fraction</param>
      <returns>The fraction as a string</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Multiply(Utilities.Math.Fraction,Utilities.Math.Fraction)">
      <summary>
            Multiplication
            </summary>
      <param name="First">First fraction</param>
      <param name="Second">Second fraction</param>
      <returns>The resulting fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Addition(Utilities.Math.Fraction,Utilities.Math.Fraction)">
      <summary>
            Addition
            </summary>
      <param name="First">First fraction</param>
      <param name="Second">Second fraction</param>
      <returns>The added fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Subtraction(Utilities.Math.Fraction,Utilities.Math.Fraction)">
      <summary>
            Subtraction
            </summary>
      <param name="First">First fraction</param>
      <param name="Second">Second fraction</param>
      <returns>The subtracted fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_Division(Utilities.Math.Fraction,Utilities.Math.Fraction)">
      <summary>
            Division
            </summary>
      <param name="First">First item</param>
      <param name="Second">Second item</param>
      <returns>The divided fraction</returns>
    </member>
    <member name="M:Utilities.Math.Fraction.op_UnaryNegation(Utilities.Math.Fraction)">
      <summary>
            Negation of the fraction
            </summary>
      <param name="First">Fraction to negate</param>
      <returns>The negated fraction</returns>
    </member>
    <member name="P:Utilities.Math.Fraction.Numerator">
      <summary>
            Numerator of the faction
            </summary>
    </member>
    <member name="P:Utilities.Math.Fraction.Denominator">
      <summary>
            Denominator of the fraction
            </summary>
    </member>
    <member name="T:Utilities.Math.Geometry.BaseClasses.Shape">
      <summary>
            Base shape class
            </summary>
    </member>
    <member name="M:Utilities.Math.Geometry.BaseClasses.Shape.#ctor(Utilities.Math.Geometry.Point,Utilities.Math.Geometry.Point,Utilities.Math.Geometry.Point)">
      <summary>
            Constructor
            </summary>
      <param name="Max">Max X,Y value</param>
      <param name="Min">Min X,Y value</param>
      <param name="Center">Center of the shape</param>
    </member>
    <member name="M:Utilities.Math.Geometry.BaseClasses.Shape.Contains(System.Double,System.Double)">
      <summary>
            Determines if the point is within the shape and returns true if it is, false otherwise
            </summary>
      <param name="X">X Coordinate</param>
      <param name="Y">Y Coordinate</param>
      <returns>True if it is contained, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Geometry.BaseClasses.Shape.EuclideanDistance(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Determines the Euclidean distance between two points
            </summary>
      <param name="X1">X1 coordinate</param>
      <param name="Y1">Y1 coordinate</param>
      <param name="X2">X2 coordinate</param>
      <param name="Y2">Y2 coordinate</param>
      <returns>The Euclidean distance between the two points</returns>
    </member>
    <member name="P:Utilities.Math.Geometry.BaseClasses.Shape.Min">
      <summary>
            Min X,Y value
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.BaseClasses.Shape.Max">
      <summary>
            Max X,Y value
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.BaseClasses.Shape.Center">
      <summary>
            Center coordinate
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.BaseClasses.Shape.Set">
      <summary>
            The predicate/set that can be used to determine if a point is within the shape
            </summary>
    </member>
    <member name="T:Utilities.Math.Geometry.Circle">
      <summary>
            Represents a 2D circle
            </summary>
    </member>
    <member name="M:Utilities.Math.Geometry.Circle.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="X">X coordinate</param>
      <param name="Y">Y coordinate</param>
      <param name="Radius">Radius of the circle</param>
    </member>
    <member name="M:Utilities.Math.Geometry.Circle.Overlap(Utilities.Math.Geometry.Circle)">
      <summary>
            Determines if the two circles overlap
            </summary>
      <param name="Object">Object to check</param>
      <returns>True if they overlap, false otherwise</returns>
    </member>
    <member name="P:Utilities.Math.Geometry.Circle.Radius">
      <summary>
            Radius of the circle
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Circle.Diameter">
      <summary>
            Diameter of the circle
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Circle.Circumference">
      <summary>
            Circumference of the circle
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Circle.Area">
      <summary>
            Area of the circle
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Circle.Set">
      <summary>
            The predicate/set that can be used to determine if a point is within the shape
            </summary>
    </member>
    <member name="T:Utilities.Math.Geometry.Point">
      <summary>
            Contains an individual point's information
            </summary>
    </member>
    <member name="M:Utilities.Math.Geometry.Point.#ctor(System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="X">X coordinate</param>
      <param name="Y">Y coordinate</param>
    </member>
    <member name="M:Utilities.Math.Geometry.Point.Translate(System.Double,System.Double)">
      <summary>
            Translates the point by X and Y
            </summary>
      <param name="X">X direction translation</param>
      <param name="Y">Y direction translation</param>
    </member>
    <member name="P:Utilities.Math.Geometry.Point.X">
      <summary>
            X coordinate
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Point.Y">
      <summary>
            Y coordinate
            </summary>
    </member>
    <member name="T:Utilities.Math.Geometry.Rectangle">
      <summary>
            Represents a rectangle
            </summary>
    </member>
    <member name="M:Utilities.Math.Geometry.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="X">X coordinate (lower left)</param>
      <param name="Y">Y coordinate (lower left)</param>
      <param name="Width">Width of the rectangle</param>
      <param name="Height">Height of the rectangle</param>
    </member>
    <member name="M:Utilities.Math.Geometry.Rectangle.#ctor(Utilities.Math.Geometry.Point,Utilities.Math.Geometry.Point)">
      <summary>
            Constructor
            </summary>
      <param name="LowerLeft">lower left</param>
      <param name="UpperRight">upper right</param>
    </member>
    <member name="M:Utilities.Math.Geometry.Rectangle.Overlap(Utilities.Math.Geometry.BaseClasses.Shape)">
      <summary>
            Determines if the two rectangles overlap
            </summary>
      <param name="Object">Object to check</param>
      <returns>True if they overlap, false otherwise</returns>
    </member>
    <member name="P:Utilities.Math.Geometry.Rectangle.Height">
      <summary>
            Height of the rectangle
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Rectangle.Width">
      <summary>
            Width of the rectangle
            </summary>
    </member>
    <member name="P:Utilities.Math.Geometry.Rectangle.Area">
      <summary>
            Area of the rectangle
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.ExtensionMethods.BitmapExtensions">
      <summary>
            Image extensions
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.AddNoise(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            adds noise to the image
            </summary>
      <param name="OriginalImage">Image to add noise to</param>
      <param name="FileName">Location to save the image to (optional)</param>
      <param name="Amount">Amount of noise to add (defaults to 10)</param>
      <returns>New image object with the noise added</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1().Amount = Amount);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.AdjustBrightness(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Adjusts the brightness
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <param name="Value">-255 to 255</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.AdjustContrast(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Adjusts the Contrast
            </summary>
      <param name="OriginalImage">Image to change</param>
      <param name="Value">Used to set the contrast (-100 to 100)</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4().Value = Value);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.AdjustGamma(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Adjusts the Gamma
            </summary>
      <param name="OriginalImage">Image to change</param>
      <param name="Value">Used to build the gamma ramp (usually .2 to 5)</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass8().Value = Value);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.And(System.Drawing.Bitmap,System.Drawing.Bitmap,System.String)">
      <summary>
            ands two images
            </summary>
      <param name="Image1">Image to manipulate</param>
      <param name="Image2">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image1" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb();&#xD;&#xA;    }&#xD;&#xA;    return Image1 != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb();&#xD;&#xA;    return Image1 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb();
    }
    return Image1 != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClassb();
    }
    return (Image1 != null); })()</exception>
      <requires description="Image2" exception="T:System.ArgumentNullException" csharp="Image2 != null" vb="Image2 &lt;&gt; Nothing">Image2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Image2 == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.BlackAndWhite(System.Drawing.Bitmap,System.String)">
      <summary>
            Converts an image to black and white
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the black and white image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.BlueFilter(System.Drawing.Bitmap,System.String)">
      <summary>
            Gets the blue filter for an image
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.BoxBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a box blur
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="Size">Size of the aperture</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.BumpMap(System.Drawing.Bitmap,Utilities.Media.Image.ExtensionMethods.Direction,System.Boolean)">
      <summary>
            Creates the bump map
            </summary>
      <param name="Direction">Direction of the bump map</param>
      <param name="Image">Image to create a bump map from</param>
      <param name="Invert">Inverts the direction of the bump map</param>
      <returns>The resulting bump map</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Colorize(System.Drawing.Bitmap,System.Drawing.Color[],System.String)">
      <summary>
            Colorizes a black and white image
            </summary>
      <param name="OriginalImage">Black and white image</param>
      <param name="Colors">Color array to use for the image</param>
      <param name="FileName">File to save to</param>
      <returns>The colorized image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClasse().Colors = Colors);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Crop(System.Drawing.Bitmap,System.Int32,System.Int32,Utilities.Media.Image.ExtensionMethods.Align,Utilities.Media.Image.ExtensionMethods.Align,System.String)">
      <summary>
            Crops an image
            </summary>
      <param name="ImageUsing">Image to crop</param>
      <param name="Width">Width of the cropped image</param>
      <param name="Height">Height of the cropped image</param>
      <param name="VAlignment">The verticle alignment of the cropping (top or bottom)</param>
      <param name="HAlignment">The horizontal alignment of the cropping (left or right)</param>
      <param name="FileName">File to save to</param>
      <returns>A Bitmap object of the cropped image</returns>
      <requires description="ImageUsing" exception="T:System.ArgumentNullException" csharp="ImageUsing != null" vb="ImageUsing &lt;&gt; Nothing">ImageUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageUsing == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Dilate(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does dilation
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="Size">Size of the aperture</param>
      <param name="FileName">File to save to</param>
      <returns>A Bitmap object of the resulting image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass11();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.DrawRoundedRectangle(System.Drawing.Bitmap,System.Drawing.Color,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
            Draws a rounded rectangle on a bitmap
            </summary>
      <param name="Image">Image to draw on</param>
      <param name="BoxColor">The color that the box should be</param>
      <param name="XPosition">The upper right corner's x position</param>
      <param name="YPosition">The upper right corner's y position</param>
      <param name="Height">Height of the box</param>
      <param name="Width">Width of the box</param>
      <param name="CornerRadius">Radius of the corners</param>
      <param name="FileName">File to save to</param>
      <returns>The bitmap with the rounded box on it</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="BoxColor" exception="T:System.ArgumentNullException" csharp="true" vb="True">true</requires>
      <exception cref="T:System.ArgumentNullException">!true</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.DrawText(System.Drawing.Bitmap,System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.String)">
      <summary>
            Draws text on an image within the bounding box specified.
            </summary>
      <param name="Image">Image to draw on</param>
      <param name="TextToDraw">The text to draw on the image</param>
      <param name="FontToUse">Font in which to draw the text</param>
      <param name="BrushUsing">Defines the brush using</param>
      <param name="BoxToDrawWithin">Rectangle to draw the image within</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object with the text drawn on it</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="FontToUse" exception="T:System.ArgumentNullException" csharp="FontToUse != null" vb="FontToUse &lt;&gt; Nothing">FontToUse != null</requires>
      <exception cref="T:System.ArgumentNullException">FontToUse == null</exception>
      <requires description="BrushUsing" exception="T:System.ArgumentNullException" csharp="BrushUsing != null" vb="BrushUsing &lt;&gt; Nothing">BrushUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">BrushUsing == null</exception>
      <requires description="BoxToDrawWithin" exception="T:System.ArgumentNullException" csharp="true" vb="True">true</requires>
      <exception cref="T:System.ArgumentNullException">!true</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.EdgeDetection(System.Drawing.Bitmap,System.Single,System.Drawing.Color,System.String)">
      <summary>
            Does basic edge detection on an image
            </summary>
      <param name="OriginalImage">Image to do edge detection on</param>
      <param name="Threshold">Decides what is considered an edge</param>
      <param name="EdgeColor">Color of the edge</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap which has the edges drawn on it</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14();&#xD;&#xA;        local_2.Threshold = Threshold;&#xD;&#xA;        local_2.EdgeColor = EdgeColor;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14();&#xD;&#xA;    local_2.Threshold = Threshold&#xD;&#xA;    local_2.EdgeColor = EdgeColor&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14();
        local_2.Threshold = Threshold;
        local_2.EdgeColor = EdgeColor;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass14();
        (local_2.Threshold = Threshold);
        (local_2.EdgeColor = EdgeColor);
    }
    return (OriginalImage != null); })()</exception>
      <requires description="EdgeColor" exception="T:System.ArgumentNullException" csharp="true" vb="True">true</requires>
      <exception cref="T:System.ArgumentNullException">!true</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Emboss(System.Drawing.Bitmap,System.String)">
      <summary>
            Emboss function
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Equalize(System.Drawing.Bitmap,System.String)">
      <summary>
            Uses an RGB histogram to equalize the image
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>The resulting bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass17();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Flip(System.Drawing.Bitmap,System.Boolean,System.Boolean,System.String)">
      <summary>
            Flips an image
            </summary>
      <param name="Image">Image to flip</param>
      <param name="FlipX">Flips an image along the X axis</param>
      <param name="FlipY">Flips an image along the Y axis</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap which is flipped</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GaussianBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a gaussian blur
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <param name="Size">Size of the aperture</param>
      <returns>The resulting bitmap</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GetHTMLPalette(System.Drawing.Bitmap)">
      <summary>
            Gets a palette listing in HTML string format
            </summary>
      <param name="OriginalImage">Image to get the palette of</param>
      <returns>A list containing HTML color values (ex: #041845)</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Func&lt;System.Drawing.Color, bool&gt; local_3 = (System.Func&lt;System.Drawing.Color, bool&gt;)null;&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    System.Func&lt;System.Drawing.Color, bool&gt; local_3 = ((System.Func(Of System.Drawing.Color, Boolean))Nothing);&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        System.Func&lt;System.Drawing.Color, bool&gt; local_3 = (System.Func&lt;System.Drawing.Color, bool&gt;)null;
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        System.Func&lt;System.Drawing.Color, bool&gt; local_3 = (System.Func&lt;System.Drawing.Color, bool&gt;)null;
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b local_4 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1b();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GreenFilter(System.Drawing.Bitmap,System.String)">
      <summary>
            Gets the Green filter for an image
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GetImageFormat(System.String)">
      <summary>
            Returns the image format this file is using
            </summary>
      <param name="FileName" />
      <returns />
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GetPixelSize(System.Drawing.Imaging.BitmapData)">
      <summary>
            Gets the pixel size (in bytes)
            </summary>
      <param name="Data">Bitmap data</param>
      <returns>The pixel size (in bytes)</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GetPixel(System.Drawing.Imaging.BitmapData,System.Int32,System.Int32,System.Int32)">
      <summary>
            Gets a pixel from an x,y coordinate
            </summary>
      <param name="Data">Bitmap data</param>
      <param name="x">X coord</param>
      <param name="y">Y coord</param>
      <param name="PixelSizeInBytes">Pixel size in bytes</param>
      <returns>The pixel at the x,y coords</returns>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Jitter(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Causes a "Jitter" effect
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="MaxJitter">Maximum number of pixels the item can move</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass1e().MaxJitter = MaxJitter);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.KuwaharaBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a kuwahara blur
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="Size">Size of the aperture</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21 local_6 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass21();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.LaplaceEdgeDetection(System.Drawing.Bitmap,System.String)">
      <summary>
            Laplace edge detection function
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.LockImage(System.Drawing.Bitmap)">
      <summary>
            Locks an image
            </summary>
      <param name="Image">Image to lock</param>
      <returns>The bitmap data for the image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.MedianFilter(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a median filter
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <param name="Size">Size of the aperture</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass24();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.MotionDetection(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Int32,System.Drawing.Color)">
      <summary>
            Runs a simplistic motion detection algorithm
            </summary>
      <param name="NewImage">The "new" frame</param>
      <param name="OldImage">The "old" frame</param>
      <param name="Threshold">The threshold used to detect changes in the image</param>
      <param name="DetectionColor">Color to display changes in the images as</param>
      <returns>A bitmap indicating where changes between frames have occurred overlayed on top of the new image.</returns>
      <requires description="NewImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28();&#xD;&#xA;        local_1.Threshold = Threshold;&#xD;&#xA;        local_1.DetectionColor = DetectionColor;&#xD;&#xA;    }&#xD;&#xA;    return NewImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28();&#xD;&#xA;    local_1.Threshold = Threshold&#xD;&#xA;    local_1.DetectionColor = DetectionColor&#xD;&#xA;    return NewImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28();
        local_1.Threshold = Threshold;
        local_1.DetectionColor = DetectionColor;
    }
    return NewImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28 local_1 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass28();
        (local_1.Threshold = Threshold);
        (local_1.DetectionColor = DetectionColor);
    }
    return (NewImage != null); })()</exception>
      <requires description="OldImage" exception="T:System.ArgumentNullException" csharp="OldImage != null" vb="OldImage &lt;&gt; Nothing">OldImage != null</requires>
      <exception cref="T:System.ArgumentNullException">OldImage == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Negative(System.Drawing.Bitmap,System.String)">
      <summary>
            gets the negative of the image
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass2f();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.NormalMap(System.Drawing.Bitmap,System.Boolean,System.Boolean)">
      <summary>
            Creates the normal map
            </summary>
      <param name="ImageUsing">Image to create the normal map from</param>
      <param name="InvertX">Invert the X direction</param>
      <param name="InvertY">Invert the Y direction</param>
      <returns>Returns the resulting normal map</returns>
      <requires description="ImageUsing" exception="T:System.ArgumentNullException" csharp="ImageUsing != null" vb="ImageUsing &lt;&gt; Nothing">ImageUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageUsing == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Or(System.Drawing.Bitmap,System.Drawing.Bitmap,System.String)">
      <summary>
            Ors two images
            </summary>
      <param name="Image1">Image to manipulate</param>
      <param name="Image2">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image1" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35();&#xD;&#xA;    }&#xD;&#xA;    return Image1 != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35();&#xD;&#xA;    return Image1 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35();
    }
    return Image1 != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass35();
    }
    return (Image1 != null); })()</exception>
      <requires description="Image2" exception="T:System.ArgumentNullException" csharp="Image2 != null" vb="Image2 &lt;&gt; Nothing">Image2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Image2 == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.OilPainting(System.Drawing.Bitmap,System.Int32,System.Int32)">
      <summary>
            Slow but interesting function that applies an oil painting effect
            </summary>
      <param name="Image">Image to create the oil painting effect from</param>
      <param name="Seed">Randomization seed</param>
      <param name="NumberOfPoints">Number of points for the painting</param>
      <returns>The resulting bitmap</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38();&#xD;&#xA;    }&#xD;&#xA;    return Image != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38();&#xD;&#xA;    return Image &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38();
    }
    return Image != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38 local_1 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass38();
    }
    return (Image != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Pixelate(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Pixelates an image
            </summary>
      <param name="OriginalImage">Image to pixelate</param>
      <param name="PixelSize">Size of the "pixels" in pixels</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b local_4 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass3b();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.RedFilter(System.Drawing.Bitmap,System.String)">
      <summary>
            Gets the Red filter for an image
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Resize(System.Drawing.Bitmap,System.Int32,Utilities.Media.Image.ExtensionMethods.Quality,System.String)">
      <summary>
            Resizes an image to a certain height
            </summary>
      <param name="Image">Image to resize</param>
      <param name="MaxSide">Max height/width for the final image</param>
      <param name="Quality">Quality of the resizing</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the resized image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Resize(System.Drawing.Bitmap,System.Int32,System.Int32,Utilities.Media.Image.ExtensionMethods.Quality,System.String)">
      <summary>
            Resizes an image to a certain height
            </summary>
      <param name="Image">Image to resize</param>
      <param name="Width">New width for the final image</param>
      <param name="Height">New height for the final image</param>
      <param name="Quality">Quality of the resizing</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the resized image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Rotate(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Rotates an image
            </summary>
      <param name="Image">Image to rotate</param>
      <param name="DegreesToRotate">Degrees to rotate the image</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object containing the rotated image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SepiaTone(System.Drawing.Bitmap,System.String)">
      <summary>
            Converts an image to sepia tone
            </summary>
      <param name="Image">Image to change</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object of the sepia tone image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SetPixel(System.Drawing.Imaging.BitmapData,System.Int32,System.Int32,System.Drawing.Color,System.Int32)">
      <summary>
            Sets a pixel at the x,y coords
            </summary>
      <param name="Data">Bitmap data</param>
      <param name="x">X coord</param>
      <param name="y">Y coord</param>
      <param name="PixelColor">Pixel color information</param>
      <param name="PixelSizeInBytes">Pixel size in bytes</param>
      <requires description="Data" exception="T:System.ArgumentNullException" csharp="Data != null" vb="Data &lt;&gt; Nothing">Data != null</requires>
      <exception cref="T:System.ArgumentNullException">Data == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Sharpen(System.Drawing.Bitmap,System.String)">
      <summary>
            Sharpens an image
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SharpenLess(System.Drawing.Bitmap,System.String)">
      <summary>
            Sharpens an image
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SinWave(System.Drawing.Bitmap,System.Single,System.Single,System.Boolean,System.Boolean,System.String)">
      <summary>
            Does a "wave" effect on the image
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="Amplitude">Amplitude of the sine wave</param>
      <param name="Frequency">Frequency of the sine wave</param>
      <param name="XDirection">Determines if this should be done in the X direction</param>
      <param name="YDirection">Determines if this should be done in the Y direction</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap which has been modified</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40();&#xD;&#xA;        local_2.Amplitude = Amplitude;&#xD;&#xA;        local_2.Frequency = Frequency;&#xD;&#xA;        local_2.XDirection = XDirection;&#xD;&#xA;        local_2.YDirection = YDirection;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40();&#xD;&#xA;    local_2.Amplitude = Amplitude&#xD;&#xA;    local_2.Frequency = Frequency&#xD;&#xA;    local_2.XDirection = XDirection&#xD;&#xA;    local_2.YDirection = YDirection&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40();
        local_2.Amplitude = Amplitude;
        local_2.Frequency = Frequency;
        local_2.XDirection = XDirection;
        local_2.YDirection = YDirection;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass40();
        (local_2.Amplitude = Amplitude);
        (local_2.Frequency = Frequency);
        (local_2.XDirection = XDirection);
        (local_2.YDirection = YDirection);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SobelEdgeDetection(System.Drawing.Bitmap,System.String)">
      <summary>
            Sobel edge detection function
            </summary>
      <param name="Input">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SobelEmboss(System.Drawing.Bitmap,System.String)">
      <summary>
            Sobel emboss function
            </summary>
      <param name="Image">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.SNNBlur(System.Drawing.Bitmap,System.Int32,System.String)">
      <summary>
            Does smoothing using a SNN blur
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <param name="Size">Size of the aperture</param>
      <returns>The resulting bitmap</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46 local_2 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass46();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.StretchContrast(System.Drawing.Bitmap,System.String)">
      <summary>
            Stretches the contrast
            </summary>
      <param name="OriginalImage">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49();&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49();&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49();
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass49();
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Threshold(System.Drawing.Bitmap,System.Single,System.String)">
      <summary>
            Does threshold manipulation of the image
            </summary>
      <param name="OriginalImage">Image to transform</param>
      <param name="Threshold">Float defining the threshold at which to set the pixel to black vs white.</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object containing the new image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4c().Threshold = Threshold);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.ToASCIIArt(System.Drawing.Bitmap)">
      <summary>
            Converts an image to ASCII art
            </summary>
      <param name="Input">The image you wish to convert</param>
      <returns>A string containing the art</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.ToBase64(System.Drawing.Image,System.Drawing.Imaging.ImageFormat)">
      <summary>
            Converts an image to a base64 string and returns it
            </summary>
      <param name="Image">Image to convert</param>
      <param name="DesiredFormat">Desired image format (defaults to Jpeg)</param>
      <returns>The image in base64 string format</returns>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Turbulence(System.Drawing.Bitmap,System.Int32,System.Single,System.Int32,System.String)">
      <summary>
            Does turbulence manipulation of the image
            </summary>
      <param name="OriginalImage">Image to transform</param>
      <param name="Roughness">Roughness of the movement</param>
      <param name="Power">How strong the movement is</param>
      <param name="Seed">Random seed</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap object containing the new image</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power;&#xD;&#xA;    }&#xD;&#xA;    return OriginalImage != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power&#xD;&#xA;    return OriginalImage &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power;
    }
    return OriginalImage != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass4f().Power = Power);
    }
    return (OriginalImage != null); })()</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.UnlockImage(System.Drawing.Bitmap,System.Drawing.Imaging.BitmapData)">
      <summary>
            Unlocks the image's data
            </summary>
      <param name="Image">Image to unlock</param>
      <param name="ImageData">The image data</param>
      <returns>Returns the image</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="ImageData" exception="T:System.ArgumentNullException" csharp="ImageData != null" vb="ImageData &lt;&gt; Nothing">ImageData != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageData == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Watermark(System.Drawing.Bitmap,System.Drawing.Bitmap,System.Single,System.Int32,System.Int32,System.Drawing.Color,System.String)">
      <summary>
            Adds a watermark to an image
            </summary>
      <param name="Image">image to add the watermark to</param>
      <param name="WatermarkImage">Watermark image</param>
      <param name="Opacity">Opacity of the watermark (1.0 to 0.0 with 1 being completely visible and 0 being invisible)</param>
      <param name="X">X position in pixels for the watermark</param>
      <param name="Y">Y position in pixels for the watermark</param>
      <param name="KeyColor">Transparent color used in watermark image, set to null if not used</param>
      <param name="FileName">File to save to</param>
      <returns>The results in the form of a bitmap object</returns>
      <requires description="Image" exception="T:System.ArgumentNullException" csharp="Image != null" vb="Image &lt;&gt; Nothing">Image != null</requires>
      <exception cref="T:System.ArgumentNullException">Image == null</exception>
      <requires description="WatermarkImage" exception="T:System.ArgumentNullException" csharp="WatermarkImage != null" vb="WatermarkImage &lt;&gt; Nothing">WatermarkImage != null</requires>
      <exception cref="T:System.ArgumentNullException">WatermarkImage == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.Xor(System.Drawing.Bitmap,System.Drawing.Bitmap,System.String)">
      <summary>
            Xors two images
            </summary>
      <param name="Image1">Image to manipulate</param>
      <param name="Image2">Image to manipulate</param>
      <param name="FileName">File to save to</param>
      <returns>A bitmap image</returns>
      <requires description="Image1" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56();&#xD;&#xA;    }&#xD;&#xA;    return Image1 != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = New Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56();&#xD;&#xA;    return Image1 &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56();
    }
    return Image1 != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56 local_3 = new Utilities.Media.Image.ExtensionMethods.BitmapExtensions.&lt;&gt;c__DisplayClass56();
    }
    return (Image1 != null); })()</exception>
      <requires description="Image2" exception="T:System.ArgumentNullException" csharp="Image2 != null" vb="Image2 &lt;&gt; Nothing">Image2 != null</requires>
      <exception cref="T:System.ArgumentNullException">Image2 == null</exception>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.BitmapExtensions._ASCIICharacters">
      <summary>
            Characters used for ASCII art
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.ExtensionMethods.Align">
      <summary>
            Enum defining alignment
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Align.Top">
      <summary>
            Top
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Align.Bottom">
      <summary>
            Bottom
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Align.Left">
      <summary>
            Left
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Align.Right">
      <summary>
            Right
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.ExtensionMethods.Quality">
      <summary>
            Enum defining quality
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Quality.High">
      <summary>
            High
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Quality.Low">
      <summary>
            Low
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.ExtensionMethods.Direction">
      <summary>
            Direction
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Direction.TopBottom">
      <summary>
            Top to bottom
            </summary>
    </member>
    <member name="F:Utilities.Media.Image.ExtensionMethods.Direction.LeftRight">
      <summary>
            Left to right
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.ExtensionMethods.ScreenExtensions">
      <summary>
            Screen extensions
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.ScreenExtensions.TakeScreenShot(System.Windows.Forms.Screen,System.String)">
      <summary>
            Takes a screenshot of the screen as a whole
            (if multiple screens are attached, it takes an image containing them all)
            </summary>
      <param name="Screen">Screen to get the screenshot from</param>
      <param name="FileName">Name of the file to save the screenshot (optional)</param>
      <returns>Returns a bitmap containing the screen shot</returns>
      <requires description="Screen" exception="T:System.ArgumentNullException" csharp="Screen != null" vb="Screen &lt;&gt; Nothing">Screen != null</requires>
      <exception cref="T:System.ArgumentNullException">Screen == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.ScreenExtensions.TakeScreenShot(System.Collections.Generic.IEnumerable{System.Windows.Forms.Screen},System.String)">
      <summary>
            Takes a screenshot of the screen as a whole
            (if multiple screens are attached, it takes an image containing them all)
            </summary>
      <param name="Screens">Screens to get the screenshot from</param>
      <param name="FileName">Name of the file to save the screenshot (optional)</param>
      <returns>Returns a bitmap containing the screen shot</returns>
      <requires description="Screens" exception="T:System.ArgumentNullException" csharp="Screens != null" vb="Screens &lt;&gt; Nothing">Screens != null</requires>
      <exception cref="T:System.ArgumentNullException">Screens == null</exception>
    </member>
    <member name="T:Utilities.ORM.Database.DatabaseManager">
      <summary>
            Database manager (handles generation and mapping of stored procedures)
            </summary>
    </member>
    <member name="M:Utilities.ORM.Database.DatabaseManager.#ctor(Utilities.DataTypes.ListMapping{Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.ORM.Mapping.Interfaces.IMapping})">
      <summary>
            Constructor
            </summary>
      <param name="Mappings">Mappings associated with databases (provided by query provider)</param>
    </member>
    <member name="M:Utilities.ORM.Database.DatabaseManager.Setup">
      <summary>
            Sets up the databases
            </summary>
    </member>
    <member name="P:Utilities.ORM.Database.DatabaseManager.Mappings">
      <summary>
            Mappings associated to databases
            </summary>
    </member>
    <member name="P:Utilities.ORM.Database.DatabaseManager.DatabaseStructures">
      <summary>
            List of database structures
            </summary>
    </member>
    <member name="T:Utilities.ORM.ExtensionMethods.IEnumerableExtensions">
      <summary>
            IEnumerable extensions related to the ORM
            </summary>
    </member>
    <member name="M:Utilities.ORM.ExtensionMethods.IEnumerableExtensions.Save``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds a save function for any IEnumerable that contains ObjectBaseClass objects
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="IDType">ID type</typeparam>
      <param name="List">List of objects to save</param>
    </member>
    <member name="T:Utilities.ORM.Interfaces.IObject`1">
      <summary>
            Object interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.ID">
      <summary>
            ID
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.DateModified">
      <summary>
            Date last modified
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.DateCreated">
      <summary>
            Date created
            </summary>
    </member>
    <member name="P:Utilities.ORM.Interfaces.IObject`1.Active">
      <summary>
            Is this item active?
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IListManyToMany`2">
      <summary>
            Many to many interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Property data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IProperty`3">
      <summary>
            Property interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type of the property</typeparam>
      <typeparam name="ReturnType">Return type</typeparam>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.IFluentInterface">
      <summary>
            Helps in fluent interface design to hide
            ToString, Equals, and GetHashCode
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.Equals(System.Object)">
      <summary>
            Hides equals
            </summary>
      <param name="obj" />
      <returns />
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.GetHashCode">
      <summary>
            Hides GetHashCode
            </summary>
      <returns />
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.ToString">
      <summary>
            Hides ToString
            </summary>
      <returns />
    </member>
    <member name="M:Utilities.DataTypes.Patterns.IFluentInterface.GetType">
      <summary>
            Hides GetType
            </summary>
      <returns />
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.SetDefaultValue(System.Func{`1})">
      <summary>
            Sets the default value of the property
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This IProperty object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.DoNotAllowNullValues">
      <summary>
            Sets the field to not null
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.ThisShouldBeUnique">
      <summary>
            Sets the unique field to true
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.TurnOnIndexing">
      <summary>
            Turns on indexing for this property
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.TurnOnAutoIncrement">
      <summary>
            Turns on autoincrement for this property
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.SetFieldName(System.String)">
      <summary>
            Sets the name of the field in the database
            </summary>
      <param name="FieldName">Field name</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.SetTableName(System.String)">
      <summary>
            Set database table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.TurnOnCascade">
      <summary>
            Turns on cascade for saving/deleting
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.SetMaxLength(System.Int32)">
      <summary>
            Sets the max length for the string
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`3.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Allows you to load a property based on a specified command
            </summary>
      <param name="Command">Command used to load the property</param>
      <param name="CommandType">Command type</param>
      <returns>this</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IListManyToMany">
      <summary>
            Many to many interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IListManyToOne`2">
      <summary>
            Many to one interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Property data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IListManyToOne">
      <summary>
            Many to one interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2">
      <summary>
            Many to many class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3">
      <summary>
            Property base class
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IProperty`2">
      <summary>
            Property interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty`2.DefaultValue">
      <summary>
            Default value for this property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty`2.Expression">
      <summary>
            Expression pointing to the property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty`2.CompiledExpression">
      <summary>
            Compiled version of the expression
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IProperty`1">
      <summary>
            Property interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Adds to query provider
            </summary>
      <param name="Database">Database associated with mapping</param>
      <param name="Mapping">Mapping to add the property to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.GetAsParameter(`0)">
      <summary>
            Gets the property as a parameter
            </summary>
      <param name="Object">Object to get the property from</param>
      <returns>The property as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.GetAsObject(`0)">
      <summary>
            Gets the property as an object
            </summary>
      <param name="Object">Object to get the property from</param>
      <returns>The property as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascades the save
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascades the delete
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascade the deleting of joins
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM</param>
      <returns>Returns the list of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascade the saving of joins
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">MicroORM</param>
      <returns>Returns the list of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the joins
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM</param>
      <returns>Returns the list of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty`1.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the joins
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">MicroORM</param>
      <returns>Returns the list of commands</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IProperty">
      <summary>
            Property interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty.SetupLoadCommands">
      <summary>
            Sets up the various load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IProperty.GetAsObject(System.Object)">
      <summary>
            Gets the property as an object
            </summary>
      <param name="Object">Object to get the property from</param>
      <returns>The property as an object</returns>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.AutoIncrement">
      <summary>
            Auto increment
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.Cascade">
      <summary>
            Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.DerivedFieldName">
      <summary>
            Derived field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.FieldName">
      <summary>
            Field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.ForeignKey">
      <summary>
            Foreign key link
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.Index">
      <summary>
            Index
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.MaxLength">
      <summary>
            Max length (used in strings)
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.Name">
      <summary>
            Name of the property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.NotNull">
      <summary>
            Can the item be null?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.Type">
      <summary>
            Property type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.Unique">
      <summary>
            Is this a unique field?
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IProperty.CommandToLoad">
      <summary>
            Command used to load the property
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression used to point to the property</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.SetDefaultValue(System.Func{`1})">
      <summary>
            Sets the default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.DoNotAllowNullValues">
      <summary>
            Prevents null values from being saved
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.ThisShouldBeUnique">
      <summary>
            Should this be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.TurnOnAutoIncrement">
      <summary>
            Turns on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.SetFieldName(System.String)">
      <summary>
            Sets the field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.SetTableName(System.String)">
      <summary>
            Sets the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Adds to query provider
            </summary>
      <param name="Database">Database</param>
      <param name="Mapping">Mapping</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Loads the object using command
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The property as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The property as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.GetAsObject(System.Object)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The property as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascade save
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascade delete
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascade join delete
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">ORM object</param>
      <returns>List of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Cascade join save
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">ORM object</param>
      <returns>List of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Join delete
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">ORM object</param>
      <returns>List of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Join save
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">ORM object</param>
      <returns>List of commands</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.SetupLoadCommands">
      <summary>
            Setup load commands
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.DefaultValue">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Name">
      <summary>
            Name of the property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Type">
      <summary>
            Property type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Expression">
      <summary>
            Expression used to get the property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.DerivedFieldName">
      <summary>
            Derived field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.NotNull">
      <summary>
            Not null
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Unique">
      <summary>
            Unique
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.AutoIncrement">
      <summary>
            Auto increment
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Cascade">
      <summary>
            Cascade
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.FieldName">
      <summary>
            Field name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Index">
      <summary>
            Index
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.MaxLength">
      <summary>
            Max length
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.ForeignKey">
      <summary>
            Foreign key
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.CommandToLoad">
      <summary>
            Command to load
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.Mapping">
      <summary>
            Mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.BaseClasses.PropertyBase`3.CompiledExpression">
      <summary>
            Compiled expression
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{`1}}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.SetDefaultValue(System.Func{System.Collections.Generic.List{`1}})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToMany`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2">
      <summary>
            Many to one class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{`1}}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.SetDefaultValue(System.Func{System.Collections.Generic.List{`1}})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ListManyToOne`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.ObjectBaseClass`2">
      <summary>
            Object base class helper. This is not required but automatically
            sets up basic functions and properties to simplify things a bit.
            </summary>
      <typeparam name="IDType">ID type</typeparam>
      <typeparam name="ObjectType">Object type (must be the child object type)</typeparam>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Any(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the item based on the ID
            </summary>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>The specified item</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Any(Utilities.ORM.Session,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the item based on the ID
            </summary>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <returns>The specified item</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Any(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the item based on the ID
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>The specified item</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Any(Utilities.ORM.Session,System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the item based on the ID
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <returns>The specified item</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.All(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.All(Utilities.ORM.Session,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.All(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.All(Utilities.ORM.Session,System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Paged(System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="OrderBy">What the data is ordered by</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (0 based)</param>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Paged(Utilities.ORM.Session,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="OrderBy">What the data is ordered by</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (0 based)</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PagedCommand(System.String,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="OrderBy">What the data is ordered by</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (0 based)</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Command">Command to run</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PagedCommand(Utilities.ORM.Session,System.String,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads the items based on type
            </summary>
      <param name="OrderBy">What the data is ordered by</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (0 based)</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <param name="Command">Command to run</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PageCount(System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the page count based on page size
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Params">Parameters used to specify what to load</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PageCount(Utilities.ORM.Session,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the page count based on page size
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PageCount(System.String,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the page count based on page size
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Command">Command to run</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.PageCount(Utilities.ORM.Session,System.String,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the page count based on page size
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Params">Parameters used to specify what to load</param>
      <param name="Session">ORM session variable</param>
      <param name="Command">Command to run</param>
      <returns>All items that fit the specified query</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Save(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Saves a list of objects
            </summary>
      <param name="Objects">List of objects</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Save(System.Collections.Generic.IEnumerable{`0},Utilities.ORM.Session)">
      <summary>
            Saves a list of objects
            </summary>
      <param name="Objects">List of objects</param>
      <param name="Session">ORM session variable</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Scalar``1(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a supplied scalar function and returns the result
            </summary>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <typeparam name="DataType">Data type</typeparam>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Scalar``1(System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a scalar command using the specified aggregate function
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="AggregateFunction">Aggregate function</param>
      <param name="Parameters">Parameters</param>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Scalar``1(Utilities.ORM.Session,System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a supplied scalar function and returns the result
            </summary>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <param name="Session">ORM session variable</param>
      <typeparam name="DataType">Data type</typeparam>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Scalar``1(Utilities.ORM.Session,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a scalar command using the specified aggregate function
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="AggregateFunction">Aggregate function</param>
      <param name="Parameters">Parameters</param>
      <param name="Session">Session object</param>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.SetupObject">
      <summary>
            Sets up the object for saving purposes
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Save">
      <summary>
            Saves the item (if it already exists, it updates the item.
            Otherwise it inserts the item)
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Delete">
      <summary>
            Deletes the item
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Save(Utilities.ORM.Session)">
      <summary>
            Saves the item (if it already exists, it updates the item.
            Otherwise it inserts the item)
            </summary>
      <param name="Session">ORM session variable</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Delete(Utilities.ORM.Session)">
      <summary>
            Deletes the item
            </summary>
      <param name="Session">ORM session variable</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.GetHashCode">
      <summary>
            Returns the hash of this item
            </summary>
      <returns>the int hash of the item</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.Equals(System.Object)">
      <summary>
            Determines if two items are equal
            </summary>
      <param name="obj">The object to compare this to</param>
      <returns>true if they are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_LessThan(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            The &lt; operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>True if the first item is less than the second, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_GreaterThan(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            The &gt; operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>True if the first item is greater than the second, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_Equality(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            The == operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>true if the first and second item are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.op_Inequality(Utilities.ORM.ObjectBaseClass{`0,`1},Utilities.ORM.ObjectBaseClass{`0,`1})">
      <summary>
            != operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>returns true if they are not equal, false otherwise</returns>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Saved">
      <summary>
            Called when the object is saved
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnSaved(Utilities.DataTypes.EventArgs.SavedEventArgs)">
      <summary>
            Called when the item is Saved
            </summary>
      <param name="e">SavedEventArgs item</param>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Deleted">
      <summary>
            Called when the object is deleted
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnDeleted(Utilities.DataTypes.EventArgs.DeletedEventArgs)">
      <summary>
            Called when the item is Deleted
            </summary>
      <param name="e">DeletedEventArgs item</param>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Saving">
      <summary>
            Called prior to an object is saving
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnSaving(Utilities.DataTypes.EventArgs.SavingEventArgs)">
      <summary>
            Called when the item is Saving
            </summary>
      <param name="e">SavingEventArgs item</param>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Deleting">
      <summary>
            Called prior to an object is deleting
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnDeleting(Utilities.DataTypes.EventArgs.DeletingEventArgs)">
      <summary>
            Called when the item is Deleting
            </summary>
      <param name="e">DeletingEventArgs item</param>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Loading">
      <summary>
            Called prior to an object is loading
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoading(Utilities.DataTypes.EventArgs.LoadingEventArgs)">
      <summary>
            Called when the item is Loading
            </summary>
      <param name="e">LoadingEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoading(System.Object,Utilities.DataTypes.EventArgs.LoadingEventArgs)">
      <summary>
            Called when the item is Loading
            </summary>
      <param name="e">LoadingEventArgs item</param>
      <param name="sender">Sender item</param>
    </member>
    <member name="F:Utilities.ORM.ObjectBaseClass`2.Loaded">
      <summary>
            Called prior to an object being loaded
            </summary>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoaded(Utilities.DataTypes.EventArgs.LoadedEventArgs)">
      <summary>
            Called when the item is Loaded
            </summary>
      <param name="e">LoadedEventArgs item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.OnLoaded(System.Object,Utilities.DataTypes.EventArgs.LoadedEventArgs)">
      <summary>
            Called when the item is Loaded
            </summary>
      <param name="e">LoadedEventArgs item</param>
      <param name="sender">Sender item</param>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.CompareTo(System.Object)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="M:Utilities.ORM.ObjectBaseClass`2.CompareTo(`0)">
      <summary>
            Compares the object to another object
            </summary>
      <param name="other">Object to compare to</param>
      <returns>0 if they are equal, -1 if this is smaller, 1 if it is larger</returns>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.ID">
      <summary>
            ID for the object
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.DateModified">
      <summary>
            Date last modified
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.DateCreated">
      <summary>
            Date object was created
            </summary>
    </member>
    <member name="P:Utilities.ORM.ObjectBaseClass`2.Active">
      <summary>
            Is the object active?
            </summary>
    </member>
    <member name="T:Utilities.Environment.ExtensionMethods.StackTraceExtensions">
      <summary>
            Extension methods related to the stack trace
            </summary>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.StackTraceExtensions.GetMethods(System.Diagnostics.StackTrace,System.Reflection.Assembly[])">
      <summary>
            Gets the methods involved in the stack trace
            </summary>
      <param name="Stack">Stack trace to get methods from</param>
      <param name="ExcludedAssemblies">Excludes methods from the specified assemblies</param>
      <returns>A list of methods involved in the stack trace</returns>
    </member>
    <member name="M:Utilities.Environment.ExtensionMethods.StackTraceExtensions.GetMethods(System.Collections.Generic.IEnumerable{System.Diagnostics.StackFrame},System.Reflection.Assembly[])">
      <summary>
            Gets the methods involved in the individual frames
            </summary>
      <param name="Frames">Frames to get the methods from</param>
      <param name="ExcludedAssemblies">Excludes methods from the specified assemblies</param>
      <returns>The list of methods involved</returns>
    </member>
    <member name="T:Utilities.Profiler.ExtensionMethods.TimerExtensions">
      <summary>
            Holds timing/profiling related extensions
            </summary>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time(System.Action,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``1(System.Action{``0},``0,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <typeparam name="T">Action input type</typeparam>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``2(System.Action{``0,``1},``0,``1,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <typeparam name="T1">Action input type 1</typeparam>
      <typeparam name="T2">Action input type 2</typeparam>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``3(System.Action{``0,``1,``2},``0,``1,``2,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <typeparam name="T1">Action input type 1</typeparam>
      <typeparam name="T2">Action input type 2</typeparam>
      <typeparam name="T3">Action input type 3</typeparam>
      <param name="ActionToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
      <param name="Object3">Object 3</param>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``1(System.Func{``0},System.String)">
      <summary>
            Times an action and places 
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``2(System.Func{``0,``1},``0,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <typeparam name="T1">Object type 1</typeparam>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``3(System.Func{``0,``1,``2},``0,``1,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
      <typeparam name="T1">Object type 1</typeparam>
      <typeparam name="T2">Object type 2</typeparam>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="M:Utilities.Profiler.ExtensionMethods.TimerExtensions.Time``4(System.Func{``0,``1,``2,``3},``0,``1,``2,System.String)">
      <summary>
            Times an action and places 
            </summary>
      <param name="FuncToTime">Action to time</param>
      <param name="FunctionName">Name to associate with the action</param>
      <param name="Object1">Object 1</param>
      <param name="Object2">Object 2</param>
      <param name="Object3">Object 3</param>
      <typeparam name="T1">Object type 1</typeparam>
      <typeparam name="T2">Object type 2</typeparam>
      <typeparam name="T3">Object type 3</typeparam>
      <typeparam name="R">Type of the value to return</typeparam>
      <returns>The value returned by the Func</returns>
    </member>
    <member name="T:Utilities.Profiler.SQLProfiler">
      <summary>
            Profiler designed to hold SQL related information
            </summary>
    </member>
    <member name="T:Utilities.Profiler.Profiler">
      <summary>
            Object class used to profile a function.
            Create at the beginning of a function in a using statement and it will automatically record the time.
            Note that this isn't exact and is based on when the object is destroyed
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FunctionName">Function/identifier</param>
    </member>
    <member name="M:Utilities.Profiler.Profiler.#ctor(System.Collections.Generic.IEnumerable{Utilities.Profiler.Profiler})">
      <summary>
            Constructor
            </summary>
      <param name="Profiles">Profiles to copy data from</param>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Stop">
      <summary>
            Stops the timer and registers the information
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Start">
      <summary>
            Starts the timer
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Setup(System.String)">
      <summary>
            Sets up the profiler
            </summary>
      <param name="Function">Function/Identification name</param>
    </member>
    <member name="M:Utilities.Profiler.Profiler.StartProfiling">
      <summary>
            Starts profiling
            </summary>
      <returns>The root profiler</returns>
    </member>
    <member name="M:Utilities.Profiler.Profiler.StopProfiling">
      <summary>
            Stops profiling
            </summary>
      <returns>The root profiler</returns>
    </member>
    <member name="M:Utilities.Profiler.Profiler.CompileData">
      <summary>
            Compiles data, combining instances where appropriate
            </summary>
    </member>
    <member name="M:Utilities.Profiler.Profiler.ToString">
      <summary>
            Outputs the information to a table
            </summary>
      <returns>an html string containing the information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Profiler.Profiler.Equals(System.Object)">
      <summary>
            Equals
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.Profiler.op_Equality(Utilities.Profiler.Profiler,Utilities.Profiler.Profiler)">
      <summary>
            Compares the profilers and determines if they are equal
            </summary>
      <param name="First">First</param>
      <param name="Second">Second</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.Profiler.op_Inequality(Utilities.Profiler.Profiler,Utilities.Profiler.Profiler)">
      <summary>
            Compares the profilers and determines if they are not equal
            </summary>
      <param name="First">First</param>
      <param name="Second">Second</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.Profiler.GetHashCode">
      <summary>
            Gets the hash code for the profiler
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.Profiler.Profiler.ToHTML">
      <summary>
            Outputs the profiler information as an HTML table
            </summary>
      <returns>Table containing profiler information</returns>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Times">
      <summary>
            Total time that the profiler has taken (in milliseconds)
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Children">
      <summary>
            Children profiler items
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Parent">
      <summary>
            Parent profiler item
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Function">
      <summary>
            Function name
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Running">
      <summary>
            Determines if it is running
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Level">
      <summary>
            Level of the profiler
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.CalledFrom">
      <summary>
            Where the profiler was started at
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.StopWatch">
      <summary>
            Stop watch
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Root">
      <summary>
            Contains the root profiler
            </summary>
    </member>
    <member name="P:Utilities.Profiler.Profiler.Current">
      <summary>
            Contains the current profiler
            </summary>
    </member>
    <member name="M:Utilities.Profiler.SQLProfiler.#ctor(System.String,System.String,System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="FunctionName">Function name/Identifier</param>
      <param name="Query">Query used</param>
      <param name="Parameters">Parameters used</param>
    </member>
    <member name="M:Utilities.Profiler.SQLProfiler.ToHTML">
      <summary>
            Outputs the profiler information as an HTML table
            </summary>
      <returns>Table containing profiler information</returns>
    </member>
    <member name="M:Utilities.Profiler.SQLProfiler.Equals(System.Object)">
      <summary>
            Equals
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.SQLProfiler.op_Equality(Utilities.Profiler.SQLProfiler,Utilities.Profiler.SQLProfiler)">
      <summary>
            Compares the profilers and determines if they are equal
            </summary>
      <param name="First">First</param>
      <param name="Second">Second</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.SQLProfiler.op_Inequality(Utilities.Profiler.SQLProfiler,Utilities.Profiler.SQLProfiler)">
      <summary>
            Compares the profilers and determines if they are not equal
            </summary>
      <param name="First">First</param>
      <param name="Second">Second</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Profiler.SQLProfiler.GetHashCode">
      <summary>
            Gets the hash code for the profiler
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="P:Utilities.Profiler.SQLProfiler.Query">
      <summary>
            Query that was called
            </summary>
    </member>
    <member name="P:Utilities.Profiler.SQLProfiler.Parameters">
      <summary>
            Parameters used by the call
            </summary>
    </member>
    <member name="T:Utilities.Random.BaseClasses.GeneratorAttributeBase">
      <summary>
            Attribute base class for generators
            </summary>
    </member>
    <member name="T:Utilities.Random.Interfaces.IGenerator">
      <summary>
            Generator interface
            </summary>
    </member>
    <member name="M:Utilities.Random.Interfaces.IGenerator.NextObj(System.Random)">
      <summary>
            Generates a random value and returns it as an object
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="M:Utilities.Random.BaseClasses.GeneratorAttributeBase.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Minimum value</param>
      <param name="Max">Maximum value</param>
    </member>
    <member name="M:Utilities.Random.BaseClasses.GeneratorAttributeBase.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.BaseClasses.GeneratorAttributeBase.Min">
      <summary>
            Minimum allowed
            </summary>
    </member>
    <member name="P:Utilities.Random.BaseClasses.GeneratorAttributeBase.Max">
      <summary>
            Maximum allowed
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.AddressGenerator">
      <summary>
            Generates a random address
            </summary>
    </member>
    <member name="T:Utilities.Random.Interfaces.IGenerator`1">
      <summary>
            Generator interface
            </summary>
      <typeparam name="T">Type it generates</typeparam>
    </member>
    <member name="M:Utilities.Random.Interfaces.IGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.Interfaces.IGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.AddressGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.CityGenerator">
      <summary>
            Generates a random city
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.CityGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.DomainNameGenerator">
      <summary>
            Generates a random domain name
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.#ctor(System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="CommonEndings">Common endings to domain names should be used (.com,.org,.net,etc.)</param>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.ContactInfoGenerators.DomainNameGenerator.CommonEndings">
      <summary>
            Should common domain name endings be used
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator">
      <summary>
            Generates a random email address
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.#ctor(System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="CommonEndings">Common endings to domain names should be used (.com,.org,.net,etc.)</param>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.ContactInfoGenerators.EmailAddressGenerator.CommonEndings">
      <summary>
            Should common domain name endings be used?
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.PhoneNumberGenerator">
      <summary>
            Generates a random phone number
            </summary>
    </member>
    <member name="T:Utilities.Random.StringGenerators.PatternGenerator">
      <summary>
            Randomly generates strings based on a pattern
            </summary>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Pattern">
            Pattern to use:
            # = Number
            @ = Alpha character
            </param>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.PatternGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.StringGenerators.PatternGenerator.Pattern">
      <summary>
            Pattern to use
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.PhoneNumberGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator">
      <summary>
            Generates a random state abbreviation
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateAbbreviationGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.StateGenerator">
      <summary>
            Generates a random state
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StateGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator">
      <summary>
            Generates a random street address
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.StreetAddressGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.ContactInfoGenerators.ZipCodeGenerator">
      <summary>
            Generates a random zip code
            </summary>
    </member>
    <member name="M:Utilities.Random.ContactInfoGenerators.ZipCodeGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.BoolGenerator">
      <summary>
            Randomly generates bools
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.Next(System.Random,System.Boolean,System.Boolean)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.BoolGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ColorGenerator">
      <summary>
            Randomly generates Colors
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.Next(System.Random,System.Drawing.Color,System.Drawing.Color)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ColorGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DateTimeGenerator">
      <summary>
            Randomly generates DateTimes
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.Next(System.Random,System.DateTime,System.DateTime)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DateTimeGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DecimalGenerator`1">
      <summary>
            Randomly generates decimals
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator`1.NextObj(System.Random)">
      <summary>
            Randomly generates an object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DecimalGenerator">
      <summary>
            Decimal generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator.#ctor(System.Decimal,System.Decimal)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DecimalGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.DoubleGenerator">
      <summary>
            Double generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DoubleGenerator.#ctor(System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DoubleGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.DoubleGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.FloatGenerator">
      <summary>
            Float generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.FloatGenerator.#ctor(System.Single,System.Single)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.FloatGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.FloatGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.EnumGenerator`1">
      <summary>
            Randomly generates Enum
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.EnumGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.EnumGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.EnumGenerator`1.NextObj(System.Random)">
      <summary>
            Randomly generates an object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.IntegerGenerator`1">
      <summary>
            Randomly generates ints
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntegerGenerator`1.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntegerGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntegerGenerator`1.NextObj(System.Random)">
      <summary>
            Randomly generates an object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ByteGenerator">
      <summary>
            Byte generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ByteGenerator.#ctor(System.Byte,System.Byte)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ByteGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ByteGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.CharGenerator">
      <summary>
            Char generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.CharGenerator.#ctor(System.Char,System.Char)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.CharGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.CharGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.IntGenerator">
      <summary>
            Int generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntGenerator.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.IntGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.LongGenerator">
      <summary>
            Long generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.LongGenerator.#ctor(System.Int64,System.Int64)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.LongGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.LongGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.SByteGenerator">
      <summary>
            sbyte generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.SByteGenerator.#ctor(System.SByte,System.SByte)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.SByteGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.SByteGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ShortGenerator">
      <summary>
            Short generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ShortGenerator.#ctor(System.Int16,System.Int16)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ShortGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ShortGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.UIntGenerator">
      <summary>
            uint generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UIntGenerator.#ctor(System.UInt32,System.UInt32)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UIntGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UIntGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ULongGenerator">
      <summary>
            ulong generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ULongGenerator.#ctor(System.UInt64,System.UInt64)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ULongGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ULongGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.UShortGenerator">
      <summary>
            ushort generator
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UShortGenerator.#ctor(System.UInt16,System.UInt16)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value</param>
      <param name="Max">Max value</param>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UShortGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.UShortGenerator.NextObj(System.Random)">
      <summary>
            Creates the next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.StringGenerator">
      <summary>
            Randomly generates strings
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.StringGenerator.NextString(System.Random,System.Int32,System.String,System.Int32)">
      <summary>
            Returns a randomly generated string of a specified length, containing
            only a set of characters, and at max a specified number of non alpha numeric characters.
            </summary>
      <param name="Length">Length of the string</param>
      <param name="AllowedCharacters">Characters allowed in the string</param>
      <param name="NumberOfNonAlphaNumericsAllowed">Number of non alpha numeric characters allowed.</param>
      <param name="Rand">Random number generator</param>
      <returns>A randomly generated string of a specified length, containing only a set of characters, and at max a specified number of non alpha numeric characters.</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.TimeSpanGenerator">
      <summary>
            Randomly generates TimeSpans
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.Next(System.Random,System.TimeSpan,System.TimeSpan)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.TimeSpanGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.DefaultClasses.ClassGenerator`1">
      <summary>
            Randomly generates a class
            </summary>
      <typeparam name="T">Class type to generate</typeparam>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ClassGenerator`1.Next(System.Random)">
      <summary>
            Generates a random version of the class
            </summary>
      <param name="Rand">Random generator to use</param>
      <returns>The randomly generated class</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ClassGenerator`1.Next(System.Random,`0,`0)">
      <summary>
            Generates a random version of the class
            </summary>
      <param name="Rand">Random generator to use</param>
      <param name="Min">Min value (not used)</param>
      <param name="Max">Max value (not used)</param>
      <returns>The randomly generated class</returns>
    </member>
    <member name="M:Utilities.Random.DefaultClasses.ClassGenerator`1.NextObj(System.Random)">
      <summary>
            Gets a random version of the class
            </summary>
      <param name="Rand">Random generator used</param>
      <returns>The randonly generated class</returns>
    </member>
    <member name="T:Utilities.Random.ExtensionMethods.RandomExtensions">
      <summary>
            Extension methods for the Random class
            </summary>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.Next``1(System.Random,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.NextClass``1(System.Random,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.Next``1(System.Random,``0,``0,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Max">Maximum value (inclusive)</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.Next``1(System.Random,System.Int32,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt; local_0_prime = New Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass1(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass1&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.NextClass``1(System.Random,System.Int32,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt; local_0_prime = New Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass4(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass4&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.Next``1(System.Random,System.Int32,``0,``0,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Max">Maximum value (inclusive)</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Min = Min, &#xD;&#xA;    Max = Max, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt; local_0_prime = New Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass7(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Min = Min)&#xD;&#xA;    (local_0_prime.Max = Max)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Random = Random, 
    Min = Min, 
    Max = Max, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClass7&lt;T&gt;(){
    Random = Random, 
    Min = Min, 
    Max = Max, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.Next``1(System.Random,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Picks a random item from the list
            </summary>
      <typeparam name="T">Type of object in the list</typeparam>
      <param name="Random">Random number generator</param>
      <param name="List">List to pick from</param>
      <returns>Item that is returned</returns>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.NextEnum``1(System.Random,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a value of the specified enum type
            </summary>
      <typeparam name="T">Type to generate</typeparam>
      <param name="Random">Random object</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="Random != null" vb="Random &lt;&gt; Nothing">Random != null</requires>
      <exception cref="T:System.ArgumentNullException">Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.NextEnum``1(System.Random,System.Int32,Utilities.Random.Interfaces.IGenerator{``0})">
      <summary>
            Randomly generates a list of values of the specified enum type
            </summary>
      <typeparam name="T">Type to the be generated</typeparam>
      <param name="Random">Random object</param>
      <param name="Amount">Number of items to generate</param>
      <param name="Generator">Generator to be used (if not included, default generator is used)</param>
      <returns>The randomly generated value</returns>
      <requires description="Random" exception="T:System.ArgumentNullException" csharp="new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){&#xD;&#xA;    Random = Random, &#xD;&#xA;    Generator = Generator, &#xD;&#xA;}.Random != null" vb="(() =&gt; {&#xD;&#xA;    Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt; local_0_prime = New Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClassa(Of T)();&#xD;&#xA;    (local_0_prime.Random = Random)&#xD;&#xA;    (local_0_prime.Generator = Generator)&#xD;&#xA;    return local_0_prime; })().Random &lt;&gt; Nothing">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random != null</requires>
      <exception cref="T:System.ArgumentNullException">new Utilities.Random.ExtensionMethods.RandomExtensions.&lt;&gt;c__DisplayClassa&lt;T&gt;(){
    Random = Random, 
    Generator = Generator, 
}.Random == null</exception>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.RegisterGenerator``1(System.Random,Utilities.Random.Interfaces.IGenerator)">
      <summary>
            Registers a generator with a type
            </summary>
      <typeparam name="T">Type to associate with the generator</typeparam>
      <param name="Rand">Random number generator</param>
      <param name="Generator">Generator to associate with the type</param>
      <returns>The random number generator</returns>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.RegisterGenerator(System.Random,System.Type,Utilities.Random.Interfaces.IGenerator)">
      <summary>
            Registers a generator with a type
            </summary>
      <param name="Rand">Random number generator</param>
      <param name="Generator">Generator to associate with the type</param>
      <param name="Type">Type to associate with the generator</param>
      <returns>The random number generator</returns>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.ResetGenerators(System.Random)">
      <summary>
            Resets the generators to the defaults
            </summary>
      <param name="Random">Random object</param>
      <returns>The random object sent in</returns>
    </member>
    <member name="M:Utilities.Random.ExtensionMethods.RandomExtensions.Shuffle``1(System.Random,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Shuffles a list randomly
            </summary>
      <typeparam name="T">Object type</typeparam>
      <param name="Random">Random object</param>
      <param name="List">List of objects to shuffle</param>
      <returns>The shuffled list</returns>
    </member>
    <member name="T:Utilities.Random.Interfaces.IStringGenerator">
      <summary>
            String generator interface
            </summary>
    </member>
    <member name="M:Utilities.Random.Interfaces.IStringGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.CompanyGenerator">
      <summary>
            Company name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.CompanyGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.FemaleFirstNameGenerator">
      <summary>
            Female first name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleFirstNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.FemaleNameGenerator">
      <summary>
            Female name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Prefix">Should a prefix be generated</param>
      <param name="MiddleName">Should a middle name be generated</param>
      <param name="LastName">Should a last name be generated</param>
      <param name="Suffix">Should a suffix be generated</param>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.Prefix">
      <summary>
            Should a prefix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.MiddleName">
      <summary>
            Should a middle name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.Suffix">
      <summary>
            Should a suffix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.FemaleNameGenerator.LastName">
      <summary>
            Should a last name be generated?
            </summary>
    </member>
    <member name="T:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator">
      <summary>
            Female name prefix generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.FemaleNamePrefixGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.LastNameGenerator">
      <summary>
            Last name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.LastNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.MaleNameGenerator">
      <summary>
            Male name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Prefix">Should a prefix be generated</param>
      <param name="MiddleName">Should a middle name be generated</param>
      <param name="LastName">Should a last name be generated</param>
      <param name="Suffix">Should a suffix be generated</param>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.Prefix">
      <summary>
            Should a prefix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.MiddleName">
      <summary>
            Should a middle name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.Suffix">
      <summary>
            Should a suffix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.MaleNameGenerator.LastName">
      <summary>
            Should a last name be generated?
            </summary>
    </member>
    <member name="T:Utilities.Random.NameGenerators.NameGenerator">
      <summary>
            Name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Prefix">Should a prefix be generated</param>
      <param name="MiddleName">Should a middle name be generated</param>
      <param name="LastName">Should a last name be generated</param>
      <param name="Suffix">Should a suffix be generated</param>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.Prefix">
      <summary>
            Should a prefix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.MiddleName">
      <summary>
            Should a middle name be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.Suffix">
      <summary>
            Should a suffix be generated?
            </summary>
    </member>
    <member name="P:Utilities.Random.NameGenerators.NameGenerator.LastName">
      <summary>
            Should a last name be generated?
            </summary>
    </member>
    <member name="T:Utilities.Random.StringGenerators.LoremIpsumGenerator">
      <summary>
            Lorem Ipsum Generator
            </summary>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="NumberOfParagraphs">Number of paragraphs</param>
      <param name="MaxSentenceLength">Maximum sentence length</param>
      <param name="MinSentenceLength">Minimum sentence length</param>
      <param name="NumberOfSentences">Number of sentences per paragraph</param>
      <param name="HTMLFormatting">Determines if this should use HTML formatting or not</param>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.NextSentence(System.Random,System.Int32)">
      <summary>
            Creates a Lorem Ipsum sentence.
            </summary>
      <param name="NumberOfWords">Number of words for the sentence</param>
      <param name="Rand">Random number generator using</param>
      <returns>A string containing Lorem Ipsum text</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.LoremIpsumGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.NumberOfParagraphs">
      <summary>
            Number of paragraphs
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.NumberOfSentences">
      <summary>
            Number of sentences
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.MinSentenceLength">
      <summary>
            Minimum sentence length
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.MaxSentenceLength">
      <summary>
            Maximum sentence length
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.LoremIpsumGenerator.HTMLFormatting">
      <summary>
            Should the sentence use HTML formatting?
            </summary>
    </member>
    <member name="T:Utilities.Random.NameGenerators.MaleFirstNameGenerator">
      <summary>
            Male first name generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleFirstNameGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.MaleNamePrefixGenerator">
      <summary>
            Male name prefix generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.MaleNamePrefixGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.NameGenerators.NameSuffixGenerator">
      <summary>
            Name suffix generator
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.NameGenerators.NameSuffixGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="T:Utilities.Random.StringGenerators.RegexStringGenerator">
      <summary>
            Randomly generates strings based on a Regex
            </summary>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.#ctor(System.Int32,System.String,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Length">Length of the string to generate</param>
      <param name="AllowedCharacters">Characters that are allowed</param>
      <param name="NumberOfNonAlphaNumericsAllowed">Number of non alphanumeric characters to allow</param>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.Next(System.Random)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.Next(System.Random,System.String,System.String)">
      <summary>
            Generates a random value of the specified type
            </summary>
      <param name="Rand">Random number generator that it can use</param>
      <param name="Min">Minimum value (inclusive)</param>
      <param name="Max">Maximum value (inclusive)</param>
      <returns>A randomly generated object of the specified type</returns>
    </member>
    <member name="M:Utilities.Random.StringGenerators.RegexStringGenerator.NextObj(System.Random)">
      <summary>
            Generates next object
            </summary>
      <param name="Rand">Random number generator</param>
      <returns>The next object</returns>
    </member>
    <member name="P:Utilities.Random.StringGenerators.RegexStringGenerator.Length">
      <summary>
            Length to generate
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.RegexStringGenerator.AllowedCharacters">
      <summary>
            Characters allowed
            </summary>
    </member>
    <member name="P:Utilities.Random.StringGenerators.RegexStringGenerator.NumberOfNonAlphaNumericsAllowed">
      <summary>
            Number of non alpha numeric characters allowed
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions">
      <summary>
            Reflection oriented extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Attribute``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
      <summary>
            Gets the attribute from the item
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="Provider">Attribute provider</param>
      <param name="Inherit">When true, it looks up the heirarchy chain for the inherited custom attributes</param>
      <returns>Attribute specified if it exists</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Attributes``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
      <summary>
            Gets the attributes from the item
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="Provider">Attribute provider</param>
      <param name="Inherit">When true, it looks up the heirarchy chain for the inherited custom attributes</param>
      <returns>Array of attributes</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Call``1(System.Object,System.String,System.Object[])">
      <summary>
            Calls a method on an object
            </summary>
      <param name="MethodName">Method name</param>
      <param name="Object">Object to call the method on</param>
      <param name="InputVariables">(Optional)input variables for the method</param>
      <typeparam name="ReturnType">Return type expected</typeparam>
      <returns>The returned value of the method</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="MethodName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(MethodName)" vb="Not IsNullOrEmpty(MethodName)">!string.IsNullOrEmpty(MethodName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(MethodName)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Create``1(System.Type,System.Object[])">
      <summary>
            Creates an instance of the type and casts it to the specified type
            </summary>
      <typeparam name="ClassType">Class type to return</typeparam>
      <param name="Type">Type to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the type</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Create(System.Type,System.Object[])">
      <summary>
            Creates an instance of the type
            </summary>
      <param name="Type">Type to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the type</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Create``1(System.Collections.Generic.IEnumerable{System.Type},System.Object[])">
      <summary>
            Creates an instance of the types and casts it to the specified type
            </summary>
      <typeparam name="ClassType">Class type to return</typeparam>
      <param name="Types">Types to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the types</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;().args = args;&#xD;&#xA;    }&#xD;&#xA;    return Types != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass2(Of ClassType)().args = args&#xD;&#xA;    return Types &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;().args = args;
    }
    return Types != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;().args = args);
    }
    return (Types != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Create(System.Collections.Generic.IEnumerable{System.Type},System.Object[])">
      <summary>
            Creates an instance of the types specified
            </summary>
      <param name="Types">Types to create an instance of</param>
      <param name="args">Arguments sent into the constructor</param>
      <returns>The newly created instance of the types</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args;&#xD;&#xA;    }&#xD;&#xA;    return Types != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args&#xD;&#xA;    return Types &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args;
    }
    return Types != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass5().args = args);
    }
    return (Types != null); })()</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.GetName(System.Type)">
      <summary>
            Returns the type's name (Actual C# name, not the funky version from
            the Name property)
            </summary>
      <param name="ObjectType">Type to get the name of</param>
      <returns>string name of the type</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.HasDefaultConstructor(System.Type)">
      <summary>
            Determines if the type has a default constructor
            </summary>
      <param name="Type">Type to check</param>
      <returns>True if it does, false otherwise</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Is(System.Object,System.Type)">
      <summary>
            Determines if an object is of a specific type
            </summary>
      <param name="Object">Object</param>
      <param name="Type">Type</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="Type != (System.Type)null" vb="Type &lt;&gt; ((System.Type)Nothing) ">Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Is(System.Type,System.Type)">
      <summary>
            Determines if an object is of a specific type
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Type">Type</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Type" exception="T:System.ArgumentNullException" csharp="new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClassa(){&#xD;&#xA;    Type = Type, &#xD;&#xA;}.Type != (System.Type)null" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClassa local_0_prime = New Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClassa();&#xD;&#xA;    local_0_prime.Type = Type&#xD;&#xA;    return local_0_prime; })().Type &lt;&gt; ((System.Type)Nothing) ">new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClassa(){
    Type = Type, 
}.Type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClassa(){
    Type = Type, 
}.Type != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Load(System.Reflection.AssemblyName)">
      <summary>
            Loads an assembly by its name
            </summary>
      <param name="Name">Name of the assembly to return</param>
      <returns>The assembly specified if it exists</returns>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="Name != null" vb="Name &lt;&gt; Nothing">Name != null</requires>
      <exception cref="T:System.ArgumentNullException">Name == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.LoadAssemblies(System.IO.DirectoryInfo,System.Boolean)">
      <summary>
            Loads assemblies within a directory and returns them in an array.
            </summary>
      <param name="Directory">The directory to search in</param>
      <param name="Recursive">Determines whether to search recursively or not</param>
      <returns>Array of assemblies in the directory</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.MarkedWith``1(System.Collections.Generic.IEnumerable{System.Type},System.Boolean)">
      <summary>
            Goes through a list of types and determines if they're marked with a specific attribute
            </summary>
      <typeparam name="T">Attribute type</typeparam>
      <param name="Types">Types to check</param>
      <param name="Inherit">When true, it looks up the heirarchy chain for the inherited custom attributes</param>
      <returns>The list of types that are marked with an attribute</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.MakeShallowCopy``1(``0,System.Boolean)">
      <summary>
            Makes a shallow copy of the object
            </summary>
      <param name="Object">Object to copy</param>
      <param name="SimpleTypesOnly">If true, it only copies simple types (no classes, only items like int, string, etc.), false copies everything.</param>
      <returns>A copy of the object</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Objects``1(System.Reflection.Assembly)">
      <summary>
            Returns an instance of all classes that it finds within an assembly
            that are of the specified base type/interface.
            </summary>
      <typeparam name="ClassType">Base type/interface searching for</typeparam>
      <param name="Assembly">Assembly to search within</param>
      <returns>A list of objects that are of the type specified</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != (System.Reflection.Assembly)null" vb="Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">Assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!Assembly != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Objects``1(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
      <summary>
            Returns an instance of all classes that it finds within a group of assemblies
            that are of the specified base type/interface.
            </summary>
      <typeparam name="ClassType">Base type/interface searching for</typeparam>
      <param name="Assemblies">Assemblies to search within</param>
      <returns>A list of objects that are of the type specified</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="Assemblies != null" vb="Assemblies &lt;&gt; Nothing">Assemblies != null</requires>
      <exception cref="T:System.ArgumentNullException">Assemblies == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Objects``1(System.IO.DirectoryInfo,System.Boolean)">
      <summary>
            Returns an instance of all classes that it finds within a directory
            that are of the specified base type/interface.
            </summary>
      <typeparam name="ClassType">Base type/interface searching for</typeparam>
      <param name="Directory">Directory to search within</param>
      <param name="Recursive">Should this be recursive</param>
      <returns>A list of objects that are of the type specified</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="Directory != null" vb="Directory &lt;&gt; Nothing">Directory != null</requires>
      <exception cref="T:System.ArgumentNullException">Directory == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Property(System.Object,System.Reflection.PropertyInfo)">
      <summary>
            Gets the value of property
            </summary>
      <param name="Object">The object to get the property of</param>
      <param name="Property">The property to get</param>
      <returns>Returns the property's value</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != (System.Reflection.PropertyInfo)null" vb="Property &lt;&gt; ((System.Reflection.PropertyInfo)Nothing) ">Property != (System.Reflection.PropertyInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Property != (System.Reflection.PropertyInfo)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Property(System.Object,System.String)">
      <summary>
            Gets the value of property
            </summary>
      <param name="Object">The object to get the property of</param>
      <param name="Property">The property to get</param>
      <returns>Returns the property's value</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Property)" vb="Not IsNullOrEmpty(Property)">!string.IsNullOrEmpty(Property)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Property)</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Property(System.Object,System.Reflection.PropertyInfo,System.Object,System.String)">
      <summary>
            Sets the value of destination property
            </summary>
      <param name="Object">The object to set the property of</param>
      <param name="Property">The property to set</param>
      <param name="Value">Value to set the property to</param>
      <param name="Format">Allows for formatting if the destination is a string</param>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != (System.Reflection.PropertyInfo)null" vb="Property &lt;&gt; ((System.Reflection.PropertyInfo)Nothing) ">Property != (System.Reflection.PropertyInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Property != (System.Reflection.PropertyInfo)null</exception>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Property(System.Object,System.String,System.Object,System.String)">
      <summary>
            Sets the value of destination property
            </summary>
      <param name="Object">The object to set the property of</param>
      <param name="Property">The property to set</param>
      <param name="Value">Value to set the property to</param>
      <param name="Format">Allows for formatting if the destination is a string</param>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Property)" vb="Not IsNullOrEmpty(Property)">!string.IsNullOrEmpty(Property)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Property)</exception>
      <requires description="Value" exception="T:System.ArgumentNullException" csharp="Value != null" vb="Value &lt;&gt; Nothing">Value != null</requires>
      <exception cref="T:System.ArgumentNullException">Value == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertyGetter``2(System.Reflection.PropertyInfo)">
      <summary>
            Gets a lambda expression that calls a specific property's getter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type expecting</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's getter function</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertyGetter``1(System.Reflection.PropertyInfo)">
      <summary>
            Gets a lambda expression that calls a specific property's getter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's getter function</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertyName(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Gets a property name
            </summary>
      <param name="Expression">LINQ expression</param>
      <returns>The name of the property</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertyName(System.Linq.Expressions.Expression)">
      <summary>
            Gets a property name
            </summary>
      <param name="Expression">LINQ expression</param>
      <returns>The name of the property</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertySetter``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Gets a lambda expression that calls a specific property's setter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type expecting</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's setter function</returns>
      <requires description="Property" exception="T:System.ArgumentNullException" csharp="Property != null" vb="Property &lt;&gt; Nothing">Property != null</requires>
      <exception cref="T:System.ArgumentNullException">Property == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertySetter``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
      <summary>
            Gets a lambda expression that calls a specific property's setter function
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Property">Property</param>
      <returns>A lambda expression that calls a specific property's setter function</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertyType(System.Object,System.String)">
      <summary>
            Gets a property's type
            </summary>
      <param name="Object">object who contains the property</param>
      <param name="PropertyPath">Path of the property (ex: Prop1.Prop2.Prop3 would be
            the Prop1 of the source object, which then has a Prop2 on it, which in turn
            has a Prop3 on it.)</param>
      <returns>The type of the property specified or null if it can not be reached.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.PropertyType(System.Type,System.String)">
      <summary>
            Gets a property's type
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="PropertyPath">Path of the property (ex: Prop1.Prop2.Prop3 would be
            the Prop1 of the source object, which then has a Prop2 on it, which in turn
            has a Prop3 on it.)</param>
      <returns>The type of the property specified or null if it can not be reached.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.ToString(System.Reflection.Assembly,Utilities.DataTypes.ExtensionMethods.VersionInfo)">
      <summary>
            Gets the version information in a string format
            </summary>
      <param name="Assembly">Assembly to get version information from</param>
      <param name="InfoType">Version info type</param>
      <returns>The version information as a string</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != (System.Reflection.Assembly)null" vb="Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">Assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!Assembly != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.ToString(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Utilities.DataTypes.ExtensionMethods.VersionInfo)">
      <summary>
            Gets the version information in a string format
            </summary>
      <param name="Assemblies">Assemblies to get version information from</param>
      <param name="InfoType">Version info type</param>
      <returns>The version information as a string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.ToString(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Boolean)">
      <summary>
            Gets assembly information for all currently loaded assemblies
            </summary>
      <param name="Assemblies">Assemblies to dump information from</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>An HTML formatted string containing the assembly information</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.ToString(System.Object,System.Boolean)">
      <summary>
            Dumps the property names and current values from an object
            </summary>
      <param name="Object">Object to dunp</param>
      <param name="HTMLOutput">Determines if the output should be HTML or not</param>
      <returns>An HTML formatted table containing the information about the object</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.ToString(System.Type,System.Boolean)">
      <summary>
            Dumps the properties names and current values
            from an object type (used for static classes)
            </summary>
      <param name="ObjectType">Object type to dunp</param>
      <param name="HTMLOutput">Should this be output as an HTML string</param>
      <returns>An HTML formatted table containing the information about the object type</returns>
      <requires description="ObjectType" exception="T:System.ArgumentNullException" csharp="ObjectType != (System.Type)null" vb="ObjectType &lt;&gt; ((System.Type)Nothing) ">ObjectType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!ObjectType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Types``1(System.Reflection.Assembly)">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assembly">Assembly to check</param>
      <typeparam name="BaseType">Class type to search for</typeparam>
      <returns>List of types that use the interface</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != (System.Reflection.Assembly)null" vb="Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">Assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!Assembly != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Types(System.Reflection.Assembly,System.Type)">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assembly">Assembly to check</param>
      <param name="BaseType">Base type to look for</param>
      <returns>List of types that use the interface</returns>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Func&lt;System.Type, bool&gt; local_1 = (System.Func&lt;System.Type, bool&gt;)null;&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_2 = new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();&#xD;&#xA;        local_2.BaseType = BaseType;&#xD;&#xA;    }&#xD;&#xA;    return Assembly != (System.Reflection.Assembly)null; })()" vb="(() =&gt; {&#xD;&#xA;    System.Func&lt;System.Type, bool&gt; local_1 = ((System.Func(Of System.Type, Boolean))Nothing);&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_2 = New Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();&#xD;&#xA;    local_2.BaseType = BaseType&#xD;&#xA;    return Assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ; })()">(() =&gt; {
    {
        System.Func&lt;System.Type, bool&gt; local_1 = (System.Func&lt;System.Type, bool&gt;)null;
        Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_2 = new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();
        local_2.BaseType = BaseType;
    }
    return Assembly != (System.Reflection.Assembly)null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        System.Func&lt;System.Type, bool&gt; local_1 = (System.Func&lt;System.Type, bool&gt;)null;
        Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f local_2 = new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass1f();
        (local_2.BaseType = BaseType);
    }
    return Assembly != (System.Reflection.Assembly)null; })()</exception>
      <requires description="BaseType" exception="T:System.ArgumentNullException" csharp="local_2.BaseType != (System.Type)null" vb="local_2.BaseType &lt;&gt; ((System.Type)Nothing) ">local_2.BaseType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!local_2.BaseType != (System.Type)null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Types``1(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assemblies">Assemblies to check</param>
      <typeparam name="BaseType">Class type to search for</typeparam>
      <returns>List of types that use the interface</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="Assemblies != null" vb="Assemblies &lt;&gt; Nothing">Assemblies != null</requires>
      <exception cref="T:System.ArgumentNullException">Assemblies == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.Types(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Type)">
      <summary>
            Gets a list of types based on an interface
            </summary>
      <param name="Assemblies">Assemblies to check</param>
      <param name="BaseType">Base type to look for</param>
      <returns>List of types that use the interface</returns>
      <requires description="Assemblies" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24 local_0 = new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24();&#xD;&#xA;        local_0.BaseType = BaseType;&#xD;&#xA;    }&#xD;&#xA;    return Assemblies != null; })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24 local_0 = New Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24();&#xD;&#xA;    local_0.BaseType = BaseType&#xD;&#xA;    return Assemblies &lt;&gt; Nothing; })()">(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24 local_0 = new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24();
        local_0.BaseType = BaseType;
    }
    return Assemblies != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24 local_0 = new Utilities.DataTypes.ExtensionMethods.ReflectionExtensions.&lt;&gt;c__DisplayClass24();
        (local_0.BaseType = BaseType);
    }
    return (Assemblies != null); })()</exception>
      <requires description="BaseType" exception="T:System.ArgumentNullException" csharp="local_0.BaseType != (System.Type)null" vb="local_0.BaseType &lt;&gt; ((System.Type)Nothing) ">local_0.BaseType != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!local_0.BaseType != (System.Type)null</exception>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.VersionInfo">
      <summary>
            Version info
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.VersionInfo.ShortVersion">
      <summary>
            Short version
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.VersionInfo.LongVersion">
      <summary>
            Long version
            </summary>
    </member>
    <member name="T:Utilities.Encryption.ExtensionMethods.HashExtensions">
      <summary>
            Hash based extensions
            </summary>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.HashExtensions.GenerateSalt(System.Random,System.Int32)">
      <summary>
            Generates salt
            </summary>
      <param name="Random">Randomization object</param>
      <param name="Size">Size of the salt byte array</param>
      <returns>A byte array as salt</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.HashExtensions.Hash(System.Byte[],System.Security.Cryptography.HashAlgorithm)">
      <summary>
            Computes the hash of a byte array
            </summary>
      <param name="Data">Byte array to hash</param>
      <param name="Algorithm">Hash algorithm to use (defaults to SHA1)</param>
      <returns>The hash of the byte array</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.HashExtensions.Hash(System.String,System.Security.Cryptography.HashAlgorithm,System.Text.Encoding)">
      <summary>
            Computes the hash of a string
            </summary>
      <param name="Data">string to hash</param>
      <param name="Algorithm">Algorithm to use (defaults to SHA1)</param>
      <param name="EncodingUsing">Encoding used by the string (defaults to UTF8)</param>
      <returns>The hash of the string</returns>
    </member>
    <member name="T:Utilities.Encryption.ExtensionMethods.ShiftExtensions">
      <summary>
            Extensions that deal with bit xoring
            </summary>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.ShiftExtensions.Encrypt(System.Byte[],System.Byte[],System.Boolean)">
      <summary>
            Encrypts the data using a basic xor of the key (not very secure unless doing a one time pad)
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <param name="OneTimePad">Is this a one time pad?</param>
      <returns>The encrypted data</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="Key != null" vb="Key &lt;&gt; Nothing">Key != null</requires>
      <exception cref="T:System.ArgumentNullException">Key == null</exception>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.ShiftExtensions.Encrypt(System.String,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Encrypts the data using a basic xor of the key (not very secure unless doing a one time pad)
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <param name="OneTimePad">Is this a one time pad?</param>
      <param name="EncodingUsing">Encoding that the Data uses (defaults to UTF8)</param>
      <returns>The encrypted data</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="Key != null" vb="Key &lt;&gt; Nothing">Key != null</requires>
      <exception cref="T:System.ArgumentNullException">Key == null</exception>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.ShiftExtensions.Decrypt(System.Byte[],System.Byte[],System.Boolean)">
      <summary>
            Decrypts the data using a basic xor of the key (not very secure unless doing a one time pad)
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use</param>
      <param name="OneTimePad">Is this a one time pad?</param>
      <returns>The decrypted data</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="Key != null" vb="Key &lt;&gt; Nothing">Key != null</requires>
      <exception cref="T:System.ArgumentNullException">Key == null</exception>
      <requires description="Key is not long enough" exception="T:System.ArgumentException" csharp="OneTimePad ⇒ Key.Length &gt;= Data.Length" vb="OneTimePad Implies Key.Length &gt;= Data.Length">!OneTimePad || Key.Length &gt;= Data.Length</requires>
      <exception cref="T:System.ArgumentException">OneTimePad ? Key.Length &lt; Data.Length : !true</exception>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.ShiftExtensions.Decrypt(System.String,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Decrypts the data using a basic xor of the key (not very secure unless doing a one time pad)
            </summary>
      <param name="Data">Data to decrypt</param>
      <param name="Key">Key to use</param>
      <param name="OneTimePad">Is this a one time pad?</param>
      <param name="EncodingUsing">Encoding that the Data uses (defaults to UTF8)</param>
      <returns>The encrypted data</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="Key != null" vb="Key &lt;&gt; Nothing">Key != null</requires>
      <exception cref="T:System.ArgumentNullException">Key == null</exception>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.ShiftExtensions.Process(System.Byte[],System.Byte[])">
      <summary>
            Actually does the encryption/decryption
            </summary>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.ShiftExtensions.XOr(System.String,System.String,System.Text.Encoding)">
      <summary>
            XOrs two strings together, returning the result
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to use</param>
      <param name="EncodingUsing">Encoding that the data uses (defaults to UTF8)</param>
      <returns>The XOred string</returns>
    </member>
    <member name="T:Utilities.Encryption.ExtensionMethods.SymmetricExtensions">
      <summary>
            Symmetric key extensions
            </summary>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Encrypt(System.String,System.String,System.Text.Encoding,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Encrypts a string
            </summary>
      <param name="Data">Text to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="Salt">Salt to encrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <param name="EncodingUsing">Encoding that the original string is using (defaults to UTF8)</param>
      <returns>An encrypted string (Base 64 string)</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Encrypt(System.String,System.Security.Cryptography.DeriveBytes,System.Text.Encoding,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc. Really anything that implements DeriveBytes)</param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <param name="EncodingUsing">Encoding that the original string is using (defaults to UTF8)</param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Encrypt(System.Byte[],System.String,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to be encrypted</param>
      <param name="Key">Password to encrypt with</param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="Salt">Salt to encrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <returns>An encrypted byte array</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Encrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.Int32)">
      <summary>
            Encrypts a byte array
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc. Really anything that implements DeriveBytes)</param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <returns>An encrypted byte array</returns>
      <requires description="InitialVector" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(InitialVector)" vb="Not IsNullOrEmpty(InitialVector)">!string.IsNullOrEmpty(InitialVector)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(InitialVector)</exception>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Decrypt(System.String,System.Security.Cryptography.DeriveBytes,System.Text.Encoding,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.Int32)">
      <summary>
            Decrypts a string
            </summary>
      <param name="Data">Text to be decrypted (Base 64 string)</param>
      <param name="Key">Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc. Really anything that implements DeriveBytes)</param>
      <param name="EncodingUsing">Encoding that the output string should use (defaults to UTF8)</param>
      <param name="AlgorithmUsing">Algorithm to use for decryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <returns>A decrypted string</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Decrypt(System.String,System.String,System.Text.Encoding,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Decrypts a string
            </summary>
      <param name="Data">Text to be decrypted (Base 64 string)</param>
      <param name="Key">Password to decrypt with</param>
      <param name="EncodingUsing">Encoding that the output string should use (defaults to UTF8)</param>
      <param name="AlgorithmUsing">Algorithm to use for decryption (defaults to AES)</param>
      <param name="Salt">Salt to decrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <returns>A decrypted string</returns>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Decrypt(System.Byte[],System.Security.Cryptography.DeriveBytes,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to encrypt</param>
      <param name="Key">Key to use to encrypt the data (can use PasswordDeriveBytes, Rfc2898DeriveBytes, etc. Really anything that implements DeriveBytes)</param>
      <param name="AlgorithmUsing">Algorithm to use for encryption (defaults to AES)</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <returns>An encrypted byte array</returns>
      <requires description="InitialVector" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(InitialVector)" vb="Not IsNullOrEmpty(InitialVector)">!string.IsNullOrEmpty(InitialVector)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(InitialVector)</exception>
    </member>
    <member name="M:Utilities.Encryption.ExtensionMethods.SymmetricExtensions.Decrypt(System.Byte[],System.String,System.Security.Cryptography.SymmetricAlgorithm,System.String,System.String,System.Int32,System.String,System.Int32)">
      <summary>
            Decrypts a byte array
            </summary>
      <param name="Data">Data to be decrypted</param>
      <param name="Key">Password to decrypt with</param>
      <param name="AlgorithmUsing">Algorithm to use for decryption</param>
      <param name="Salt">Salt to decrypt with</param>
      <param name="HashAlgorithm">Can be either SHA1 or MD5</param>
      <param name="PasswordIterations">Number of iterations to do</param>
      <param name="InitialVector">Needs to be 16 ASCII characters long</param>
      <param name="KeySize">Can be 64 (DES only), 128 (AES), 192 (AES and Triple DES), or 256 (AES)</param>
      <returns>A decrypted byte array</returns>
    </member>
    <member name="T:Utilities.Math.ExtensionMethods.MathExtensions">
      <summary>
            Extension methods that add basic math functions
            </summary>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Absolute(System.Decimal)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Absolute(System.Double)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Absolute(System.Single)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Absolute(System.Int32)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Absolute(System.Int64)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Absolute(System.Int16)">
      <summary>
            Returns the absolute value
            </summary>
      <param name="Value">Value</param>
      <returns>The absolute value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Exp(System.Double)">
      <summary>
            Returns E raised to the specified power
            </summary>
      <param name="Value">Power to raise E by</param>
      <returns>E raised to the specified power</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Factorial(System.Int32)">
      <summary>
            Calculates the factorial for a number
            </summary>
      <param name="Input">Input value (N!)</param>
      <returns>The factorial specified</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.GreatestCommonDenominator(System.Int32,System.Int32)">
      <summary>
            Returns the greatest common denominator between value1 and value2
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The greatest common denominator if one exists</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.GreatestCommonDenominator(System.Int32,System.UInt32)">
      <summary>
            Returns the greatest common denominator between value1 and value2
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The greatest common denominator if one exists</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.GreatestCommonDenominator(System.UInt32,System.UInt32)">
      <summary>
            Returns the greatest common denominator between value1 and value2
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The greatest common denominator if one exists</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Log(System.Double)">
      <summary>
            Returns the natural (base e) logarithm of a specified number
            </summary>
      <param name="Value">Specified number</param>
      <returns>The natural logarithm of the specified number</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Log(System.Double,System.Double)">
      <summary>
            Returns the logarithm of a specified number in a specified base
            </summary>
      <param name="Value">Value</param>
      <param name="Base">Base</param>
      <returns>The logarithm of a specified number in a specified base</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Log10(System.Double)">
      <summary>
            Returns the base 10 logarithm of a specified number
            </summary>
      <param name="Value">Value</param>
      <returns>The base 10 logarithm of the specified number</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Median``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets the median from the list
            </summary>
      <typeparam name="T">The data type of the list</typeparam>
      <param name="Values">The list of values</param>
      <returns>The median value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Mode``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets the mode (item that occurs the most) from the list
            </summary>
      <typeparam name="T">The data type of the list</typeparam>
      <param name="Values">The list of values</param>
      <returns>The mode value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Pow(System.Double,System.Double)">
      <summary>
            Raises Value to the power of Power
            </summary>
      <param name="Value">Value to raise</param>
      <param name="Power">Power</param>
      <returns>The resulting value</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Round(System.Double,System.Int32,System.MidpointRounding)">
      <summary>
            Rounds the value to the number of digits
            </summary>
      <param name="Value">Value to round</param>
      <param name="Digits">Digits to round to</param>
      <param name="Rounding">Rounding mode to use</param>
      <returns />
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.StandardDeviation(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Gets the standard deviation
            </summary>
      <param name="Values">List of values</param>
      <returns>The standard deviation</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Sqrt(System.Double)">
      <summary>
            Returns the square root of a value
            </summary>
      <param name="Value">Value to take the square root of</param>
      <returns>The square root</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Variance(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Calculates the variance of a list of values
            </summary>
      <param name="Values">List of values</param>
      <returns>The variance</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Variance(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Calculates the variance of a list of values
            </summary>
      <param name="Values">List of values</param>
      <returns>The variance</returns>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.MathExtensions.Variance(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>
            Calculates the variance of a list of values
            </summary>
      <param name="Values">List of values</param>
      <returns>The variance</returns>
    </member>
    <member name="T:Utilities.Math.ExtensionMethods.PermutationExtensions">
      <summary>
            Permutation extensions
            </summary>
    </member>
    <member name="M:Utilities.Math.ExtensionMethods.PermutationExtensions.Permute``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds all permutations of the items within the list
            </summary>
      <typeparam name="T">Object type in the list</typeparam>
      <param name="Input">Input list</param>
      <returns>The list of permutations</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.SQL.MicroORM.BatchCommand">
      <summary>
            Holds information for a set of commands
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Interfaces.ICommand">
      <summary>
            Command interface
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.AddParameter``1(System.String,``0,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="ID">Parameter ID</param>
      <param name="Parameter">Parameter value</param>
      <typeparam name="DataType">Data type of the parameter</typeparam>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.AddParameter(System.String,System.String,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="ID">Parameter ID</param>
      <param name="Parameter">Parameter value</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.AddParameter(System.String,System.Object[])">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="Parameters">Parameter values</param>
      <param name="ParameterStarter">Parameter starter to use</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.AddParameter(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.AddParameter(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.AddParameter(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="Parameters">Parameter values</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.ICommand.ClearParameters">
      <summary>
            Clears the parameters for the command
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Interfaces.ICommand.SQLCommand">
      <summary>
            Actual SQL command
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Interfaces.ICommand.CommandType">
      <summary>
            Command type
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Interfaces.ICommand.Parameters">
      <summary>
            Parameters associated with the command
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Interfaces.IBatchCommand">
      <summary>
            Batch command interface
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.IBatchCommand.AddCommands(Utilities.SQL.MicroORM.Command[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Commands">Commands to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.IBatchCommand.AddCommand(System.String,System.Data.CommandType,System.String,System.Object[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="ParameterPrefix">Parameter prefix to use</param>
      <param name="Parameters">Parameters to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.IBatchCommand.AddCommand(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to add</param>
      <returns>This</returns>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Interfaces.IBatchCommand.CommandCount">
      <summary>
            Number of commands being batched
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.#ctor(Utilities.SQL.MicroORM.Command[])">
      <summary>
            Constructor
            </summary>
      <param name="Commands">Commands that are being merged for batching</param>
    </member>
    <member name="F:Utilities.SQL.MicroORM.BatchCommand.ParameterRegex">
      <summary>
            Used to parse SQL commands to find parameters (when batching)
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddCommand(System.String,System.Data.CommandType,System.String,System.Object[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="ParameterPrefix">Parameter prefix to use</param>
      <param name="Parameters">Parameters to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddCommand(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Command">Command (SQL or stored procedure) to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddCommands(Utilities.SQL.MicroORM.Command[])">
      <summary>
            Adds a command to be batched
            </summary>
      <param name="Commands">Commands to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddParameter``1(System.String,``0,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="ID">Parameter ID</param>
      <param name="Parameter">Parameter value</param>
      <typeparam name="DataType">Data type of the parameter</typeparam>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddParameter(System.String,System.String,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="ID">Parameter ID</param>
      <param name="Parameter">Parameter value</param>
      <param name="Direction">Parameter direction</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddParameter(System.String,System.Object[])">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="Parameters">Parameter values</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddParameter(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddParameter(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.AddParameter(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="Parameters">Parameter values</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.ClearParameters">
      <summary>
            Clears the parameters for the command
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.Batch">
      <summary>
            Batches the data
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>Determines if the commands are equal</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.GetHashCode">
      <summary>
            Returns the hash code for the command
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.BatchCommand.ToString">
      <summary>
            Returns the string representation of the command
            </summary>
      <returns>The string representation of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.CommandCount">
      <summary>
            Number of commands being batched
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.SQLCommand">
      <summary>
            Actual SQL command
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.SQLCommand_">
      <summary>
            Batched SQL Command
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.CommandType">
      <summary>
            Command type
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.Parameters">
      <summary>
            Parameters associated with the command
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.Parameters_">
      <summary>
            Batched parameter list
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.Commands">
      <summary>
            Commands to batch
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.BatchCommand.Batched">
      <summary>
            Has this been batched?
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.CacheTables">
      <summary>
            Holds a set of tablular info for caching purposes
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.#ctor(System.Data.IDataReader)">
      <summary>
            Constructor
            </summary>
      <param name="Reader">Reader to copy from</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.NextResult">
      <summary>
            Goes to the next result set
            </summary>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.Read">
      <summary>
            Goes to the next row of the result set
            </summary>
      <returns>True if there is another row, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetName(System.Int32)">
      <summary>
            Gets the name of the column at a specific position
            </summary>
      <param name="i">Specific position</param>
      <returns>Name of the column</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetValue(System.Int32)">
      <summary>
            Gets the specified value
            </summary>
      <param name="i">Position to get the value from</param>
      <returns>The value at the position specified</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.Close">
      <summary>
            Not implemented
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetSchemaTable">
      <summary>
            Not implemented
            </summary>
      <returns>Null</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.Dispose">
      <summary>
            Not implemented
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetBoolean(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetByte(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <param name="fieldOffset" />
      <param name="buffer" />
      <param name="bufferoffset" />
      <param name="length" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetChar(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <param name="fieldoffset" />
      <param name="buffer" />
      <param name="bufferoffset" />
      <param name="length" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetData(System.Int32)">
      <summary>
            Not implemtned
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetDataTypeName(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetDateTime(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetDecimal(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetDouble(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetFieldType(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetFloat(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetGuid(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetInt16(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetInt32(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetInt64(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetOrdinal(System.String)">
      <summary>
            Not implemented
            </summary>
      <param name="name" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetString(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.GetValues(System.Object[])">
      <summary>
            Not implemented
            </summary>
      <param name="values" />
      <returns />
    </member>
    <member name="M:Utilities.SQL.MicroORM.CacheTables.IsDBNull(System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="i" />
      <returns />
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.Tables">
      <summary>
            List of tables being held
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.CurrentRow">
      <summary>
            Current row
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.CurrentTable">
      <summary>
            Current table to get info from
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.CurrentTablePosition">
      <summary>
            Position of the current table
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.RowPosition">
      <summary>
            Row position
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.FieldCount">
      <summary>
            Field count
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.Item(System.String)">
      <summary>
            Gets the value specified
            </summary>
      <param name="name">Name of the column</param>
      <returns>The value specified</returns>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.Item(System.Int32)">
      <summary>
            Gets the value specified
            </summary>
      <param name="i">Column to get the value from</param>
      <returns>The value specified</returns>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.Depth">
      <summary>
            Not implemented
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.IsClosed">
      <summary>
            Not implemented
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.CacheTables.RecordsAffected">
      <summary>
            Not implemented
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Command">
      <summary>
            Holds information for an individual SQL command
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.#ctor(System.String,System.Data.CommandType,System.String,System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="SQLCommand">Actual SQL command</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.#ctor(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Constructor
            </summary>
      <param name="SQLCommand">Actual SQL command</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.AddParameter``1(System.String,``0,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="ID">Parameter ID</param>
      <param name="Parameter">Parameter value</param>
      <typeparam name="DataType">Data type of the parameter</typeparam>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter prefix</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.AddParameter(System.String,System.String,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="ID">Parameter ID</param>
      <param name="Parameter">Parameter value</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.AddParameter(System.String,System.Object[])">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="Parameters">Parameter values</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.AddParameter(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.AddParameter(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.AddParameter(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Adds a parameter to the command
            </summary>
      <param name="Parameters">Parameter values</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.ClearParameters">
      <summary>
            Clears the parameters for the command
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>Determines if the commands are equal</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.GetHashCode">
      <summary>
            Returns the hash code for the command
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Command.ToString">
      <summary>
            Returns the string representation of the command
            </summary>
      <returns>The string representation of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Command.SQLCommand">
      <summary>
            Actual SQL command
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Command.CommandType">
      <summary>
            Command type
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Command.Parameters">
      <summary>
            Parameters associated with the command
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Interfaces.IColumn">
      <summary>
            Column interface
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Interfaces.IColumn.AddForeignKey(System.String,System.String)">
      <summary>
            Add foreign key
            </summary>
      <param name="ForeignKeyTable">Table of the foreign key</param>
      <param name="ForeignKeyColumn">Column of the foreign key</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Interfaces.IColumn.SetupForeignKeys">
      <summary>
            Sets up the foreign key list
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.OnDeleteCascade">
      <summary>
            On Delete Cascade
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.OnUpdateCascade">
      <summary>
            On Update Cascade
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.OnDeleteSetNull">
      <summary>
            On Delete Set Null
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.DataType">
      <summary>
            Data type
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.Length">
      <summary>
            Data length
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.ForeignKey">
      <summary>
            Foreign keys
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.PrimaryKey">
      <summary>
            Primary key?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.Nullable">
      <summary>
            Nullable?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.Unique">
      <summary>
            Unique?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.Index">
      <summary>
            Index?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.AutoIncrement">
      <summary>
            Auto increment?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.Default">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.IColumn.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="T:Utilities.SQL.ExtensionMethods.DbCommandExtensions">
      <summary>
            Extension methods for DbCommand objects
            </summary>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.AddParameter(System.Data.Common.DbCommand,System.String,System.String,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for strings only)
            </summary>
      <param name="Command">Command object</param>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.AddParameter(System.Data.Common.DbCommand,System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <param name="Command">Command object</param>
      <param name="Type">SQL type of the parameter</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.AddParameter``1(System.Data.Common.DbCommand,System.String,``0,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
      <param name="ID">Name of the parameter</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <param name="Command">Command object</param>
      <param name="Value">Value to add</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.AddParameter(System.Data.Common.DbCommand,System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Direction">Direction that the parameter goes (in or out)</param>
      <param name="Command">Command object</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <returns>The DbCommand object</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="Command != null" vb="Command &lt;&gt; Nothing">Command != null</requires>
      <exception cref="T:System.ArgumentNullException">Command == null</exception>
      <requires description="ID" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ID)" vb="Not IsNullOrEmpty(ID)">!string.IsNullOrEmpty(ID)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ID)</exception>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.BeginTransaction(System.Data.Common.DbCommand)">
      <summary>
            Begins a transaction
            </summary>
      <param name="Command">Command object</param>
      <returns>A transaction object</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.ClearParameters(System.Data.Common.DbCommand)">
      <summary>
            Clears the parameters
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.Close(System.Data.Common.DbCommand)">
      <summary>
            Closes the connection
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.Commit(System.Data.Common.DbCommand)">
      <summary>
            Commits a transaction
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.ExecuteDataSet(System.Data.Common.DbCommand,System.Data.Common.DbProviderFactory)">
      <summary>
            Executes the query and returns a data set
            </summary>
      <param name="Command">Command object</param>
      <param name="Factory">DbProviderFactory being used</param>
      <returns>A dataset filled with the results of the query</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.ExecuteScalar``1(System.Data.Common.DbCommand,``0)">
      <summary>
            Executes the stored procedure as a scalar query
            </summary>
      <param name="Command">Command object</param>
      <param name="Default">Default value if there is an issue</param>
      <returns>The object of the first row and first column</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.GetOrCreateParameter(System.Data.Common.DbCommand,System.String)">
      <summary>
            Gets a parameter or creates it, if it is not found
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Command">Command object</param>
      <returns>The DbParameter associated with the ID</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.GetOutputParameter``1(System.Data.Common.DbCommand,System.String,``0)">
      <summary>
            Returns an output parameter's value
            </summary>
      <typeparam name="DataType">Data type of the object</typeparam>
      <param name="ID">Parameter name</param>
      <param name="Command">Command object</param>
      <param name="Default">Default value for the parameter</param>
      <returns>if the parameter exists (and isn't null or empty), it returns the parameter's value. Otherwise the default value is returned.</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.Open(System.Data.Common.DbCommand)">
      <summary>
            Opens the connection
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.DbCommandExtensions.Rollback(System.Data.Common.DbCommand)">
      <summary>
            Rolls back a transaction
            </summary>
      <param name="Command">Command object</param>
      <returns>The DBCommand object</returns>
    </member>
    <member name="T:Utilities.SQL.ExtensionMethods.IDataReaderExtensions">
      <summary>
            Extension methods for DbDataReader objects
            </summary>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.IDataReaderExtensions.GetParameter``1(System.Data.IDataRecord,System.String,``0)">
      <summary>
            Returns a parameter's value
            </summary>
      <param name="Reader">Reader object</param>
      <param name="ID">Parameter name</param>
      <param name="Default">Default value for the parameter</param>
      <returns>if the parameter exists (and isn't null or empty), it returns the parameter's value. Otherwise the default value is returned.</returns>
    </member>
    <member name="M:Utilities.SQL.ExtensionMethods.IDataReaderExtensions.GetParameter``1(System.Data.IDataRecord,System.Int32,``0)">
      <summary>
            Returns a parameter's value
            </summary>
      <param name="Reader">Reader object</param>
      <param name="Position">Position in the reader row</param>
      <param name="Default">Default value for the parameter</param>
      <returns>if the parameter exists (and isn't null or empty), it returns the parameter's value. Otherwise the default value is returned.</returns>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Parameter`1">
      <summary>
            Holds parameter information
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
    </member>
    <member name="T:Utilities.SQL.Interfaces.ParameterBase`1">
      <summary>
            Parameter base class
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
    </member>
    <member name="T:Utilities.SQL.Interfaces.IParameter">
      <summary>
            Parameter interface
            </summary>
    </member>
    <member name="M:Utilities.SQL.Interfaces.IParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.SQL.Interfaces.IParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="P:Utilities.SQL.Interfaces.IParameter.ID">
      <summary>
            The Name that the parameter goes by
            </summary>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.#ctor(System.String,`0,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.#ctor(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.#ctor(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to compare to</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.ToString">
      <summary>
            Returns the string version of the parameter
            </summary>
      <returns>The string representation of the parameter</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.op_Equality(Utilities.SQL.Interfaces.ParameterBase{`0},Utilities.SQL.Interfaces.ParameterBase{`0})">
      <summary>
            The == operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>true if the first and second item are the same, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.Interfaces.ParameterBase`1.op_Inequality(Utilities.SQL.Interfaces.ParameterBase{`0},Utilities.SQL.Interfaces.ParameterBase{`0})">
      <summary>
            != operator
            </summary>
      <param name="first">First item</param>
      <param name="second">Second item</param>
      <returns>returns true if they are not equal, false otherwise</returns>
    </member>
    <member name="P:Utilities.SQL.Interfaces.ParameterBase`1.ID">
      <summary>
            The Name that the parameter goes by
            </summary>
    </member>
    <member name="P:Utilities.SQL.Interfaces.ParameterBase`1.BatchID">
      <summary>
            Batch ID
            </summary>
    </member>
    <member name="P:Utilities.SQL.Interfaces.ParameterBase`1.Value">
      <summary>
            Parameter value
            </summary>
    </member>
    <member name="P:Utilities.SQL.Interfaces.ParameterBase`1.Direction">
      <summary>
            Direction of the parameter
            </summary>
    </member>
    <member name="P:Utilities.SQL.Interfaces.ParameterBase`1.DatabaseType">
      <summary>
            Database type
            </summary>
    </member>
    <member name="P:Utilities.SQL.Interfaces.ParameterBase`1.ParameterStarter">
      <summary>
            Starting string of the parameter
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Parameter`1.#ctor(System.String,`0,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Parameter`1.#ctor(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Parameter`1.#ctor(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Type">Database type</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Parameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Parameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="T:Utilities.SQL.MicroORM.StringParameter">
      <summary>
            Holds parameter information
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.StringParameter.#ctor(System.String,System.String,System.Data.ParameterDirection,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ID">ID of the parameter</param>
      <param name="Value">Value of the parameter</param>
      <param name="Direction">Direction of the parameter</param>
      <param name="ParameterStarter">Parameter starter</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.StringParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds this parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.StringParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.AndParameter">
      <summary>
            Parameter class that ANDs two other parameters together
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.AndParameter.#ctor(Utilities.SQL.Interfaces.IParameter,Utilities.SQL.Interfaces.IParameter)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.AndParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.AndParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.AndParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.AndParameter.Left">
      <summary>
            Left parameter
            </summary>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.AndParameter.Right">
      <summary>
            Right parameter
            </summary>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.BetweenParameter`1">
      <summary>
            Parameter class that checks if a value is between two other values
            </summary>
      <typeparam name="DataType">Type of the parameter</typeparam>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.BetweenParameter`1.#ctor(`0,`0,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Min">Min value of the parameter</param>
      <param name="Max">Max value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.BetweenParameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.BetweenParameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.BetweenParameter`1.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.BetweenParameter`1.Min">
      <summary>
            Min value of the parameter
            </summary>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.BetweenParameter`1.Max">
      <summary>
            Max value of the parameter
            </summary>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.LikeParameter">
      <summary>
            Parameter class handling strings that instead of looking for equality, uses the SQL Like command
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.LikeParameter.#ctor(System.String,System.String,System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
      <param name="Length">Max length allowed for the string</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.LikeParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.LikeParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.LikeParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.LikeParameter.Length">
      <summary>
            Max length of the string
            </summary>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.NotEqualParameter`1">
      <summary>
            Parameter class that checks for inequality
            </summary>
      <typeparam name="DataType">Type of the parameter</typeparam>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.NotEqualParameter`1.#ctor(`0,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.NotEqualParameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.NotEqualParameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.NotEqualParameter`1.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.OrParameter">
      <summary>
            Parameter class that ORs two other parameters together
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.OrParameter.#ctor(Utilities.SQL.Interfaces.IParameter,Utilities.SQL.Interfaces.IParameter)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.OrParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.OrParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.OrParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.OrParameter.Left">
      <summary>
            Left parameter
            </summary>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.OrParameter.Right">
      <summary>
            Right parameter
            </summary>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.EqualParameter`1">
      <summary>
            Parameter class that checks for equality
            </summary>
      <typeparam name="DataType">Type of the parameter</typeparam>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.EqualParameter`1.#ctor(`0,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.EqualParameter`1.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.EqualParameter`1.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.EqualParameter`1.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.StringNotEqualParameter">
      <summary>
            Parameter class handling strings, checking for inequality
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringNotEqualParameter.#ctor(System.String,System.String,System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
      <param name="Length">Max length allowed for the string</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringNotEqualParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringNotEqualParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringNotEqualParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.StringNotEqualParameter.Length">
      <summary>
            Max length of the string
            </summary>
    </member>
    <member name="T:Utilities.SQL.ParameterTypes.StringEqualParameter">
      <summary>
            Parameter class handling strings
            </summary>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringEqualParameter.#ctor(System.String,System.String,System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the parameter</param>
      <param name="ID">Name of the parameter</param>
      <param name="ParameterStarter">What the database expects as the
            parameter starting string ("@" for SQL Server, ":" for Oracle, etc.)</param>
      <param name="Length">Max length allowed for the string</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringEqualParameter.AddParameter(System.Data.Common.DbCommand)">
      <summary>
            Adds the parameter to the SQLHelper
            </summary>
      <param name="Helper">SQLHelper to add the parameter to</param>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringEqualParameter.CreateCopy(System.String)">
      <summary>
            Creates a copy of the parameter
            </summary>
      <param name="Suffix">Suffix to add to the parameter (for batching purposes)</param>
      <returns>A copy of the parameter</returns>
    </member>
    <member name="M:Utilities.SQL.ParameterTypes.StringEqualParameter.ToString">
      <summary>
            Outputs the param as a string
            </summary>
      <returns>The param as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.ParameterTypes.StringEqualParameter.Length">
      <summary>
            Max length of the string
            </summary>
    </member>
    <member name="T:Utilities.SQL.SQLCommand">
      <summary>
            SQL command builder
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.#ctor(System.String,System.String,System.String[])">
      <summary>
            Constructor
            </summary>
      <param name="CommandType">Command type</param>
      <param name="Columns">Columns</param>
      <param name="Table">Table name</param>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Select(System.String,System.String[])">
      <summary>
            Creates a select command
            </summary>
      <param name="Columns">Columns to return</param>
      <param name="Table">Base table name</param>
      <returns>An SQLCommand object</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Build">
      <summary>
            Builds a command
            </summary>
      <returns>The resulting command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Distinct">
      <summary>
            Sets the command to return distinct rows
            </summary>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Join(System.String,System.String,System.String)">
      <summary>
            Joins another table to the command
            </summary>
      <param name="Table">Table name</param>
      <param name="Type">Type of join</param>
      <param name="ONClause">ON Clause</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.OrderBy(System.String[])">
      <summary>
            Sets up the order by clause
            </summary>
      <param name="Columns">Columns to order by</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Top(System.Int32)">
      <summary>
            Limits the number of items to the top X items
            </summary>
      <param name="Amount">The number of items to limit it to</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Where(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Generates the where clause based on the parameters passed in
            </summary>
      <param name="Parameters">Parameters to use</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Where(System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets the where clause
            </summary>
      <param name="WhereClause">Where clause</param>
      <param name="Parameters">Parameters to use</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.Where(System.String,System.String,System.Object[])">
      <summary>
            Sets the where clause
            </summary>
      <param name="WhereClause">Where clause</param>
      <param name="ParameterStarter">Parameter starter</param>
      <param name="Parameters">Parameters to use</param>
      <returns>this</returns>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.CommandType">
      <summary>
            Command type (SELECT, DELETE, UPDATE, INSERT)
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.Columns">
      <summary>
            Columns
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.Joins">
      <summary>
            Joins
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.Table">
      <summary>
            Base table name
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.Parameters">
      <summary>
            Parameters
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.WhereClause">
      <summary>
            Where clause
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.OrderByColumns">
      <summary>
            Order by
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.TopNumber">
      <summary>
            Limits the results to the top X amount
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.IsDistinct">
      <summary>
            Determines if the items should be distinct
            </summary>
    </member>
    <member name="T:Utilities.SQL.SQLCommand.SQLJoin">
      <summary>
            Handles join information
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.SQLJoin.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Table">Table name</param>
      <param name="Type">Type of join</param>
      <param name="ONClause">ON Clause</param>
    </member>
    <member name="M:Utilities.SQL.SQLCommand.SQLJoin.ToString">
      <summary>
            returns the join as a string
            </summary>
      <returns>The join as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.SQLJoin.Table">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.SQLJoin.Type">
      <summary>
            Join type
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLCommand.SQLJoin.ONClause">
      <summary>
            ON Clause
            </summary>
    </member>
    <member name="T:Utilities.Validation.ExtensionMethods.ObjectExtensions">
      <summary>
            Object extensions
            </summary>
    </member>
    <member name="M:Utilities.Validation.ExtensionMethods.ObjectExtensions.TryValidate``1(``0,System.Collections.Generic.ICollection{System.ComponentModel.DataAnnotations.ValidationResult})">
      <summary>
            Determines if the object is valid
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to validate</param>
      <param name="Results">Results list</param>
      <returns>True if valid, false otherwise</returns>
    </member>
    <member name="M:Utilities.Validation.ExtensionMethods.ObjectExtensions.Validate``1(``0)">
      <summary>
            Determines if the object is valid
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to validate</param>
      <exception cref="T:System.ComponentModel.DataAnnotations.ValidationException" />
    </member>
    <member name="T:Utilities.Validation.Rules.BetweenAttribute">
      <summary>
            Between attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.BetweenAttribute.#ctor(System.Object,System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Max">Max value</param>
      <param name="Min">Min value</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.BetweenAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.BetweenAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.BetweenAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.BetweenAttribute.Min">
      <summary>
            Min value to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.Rules.BetweenAttribute.Max">
      <summary>
            Max value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.CompareAttribute">
      <summary>
            Compare attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareAttribute.#ctor(System.Object,Utilities.Validation.Rules.Enums.ComparisonType,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to compare to</param>
      <param name="Type">Comparison type to use</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.CompareAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.Rules.CompareAttribute.Type">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.ContainsAttribute">
      <summary>
            Contains attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.ContainsAttribute.#ctor(System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check for</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.ContainsAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.ContainsAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.ContainsAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.DoesNotContainAttribute">
      <summary>
            Does not contain attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.DoesNotContainAttribute.#ctor(System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check for</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.DoesNotContainAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.DoesNotContainAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.DoesNotContainAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.EmptyAttribute">
      <summary>
            Empty attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.EmptyAttribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.EmptyAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.EmptyAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="T:Utilities.Validation.Rules.CompareToAttribute">
      <summary>
            CompareTo attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareToAttribute.#ctor(System.String,Utilities.Validation.Rules.Enums.ComparisonType,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="PropertyName">Property to compare to</param>
      <param name="Type">Comparison type to use</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareToAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareToAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.CompareToAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.CompareToAttribute.PropertyName">
      <summary>
            Property to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.Rules.CompareToAttribute.Type">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.Enums.ComparisonType">
      <summary>
            Comparison types
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.ComparisonType.Equal">
      <summary>
            Equal
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.ComparisonType.NotEqual">
      <summary>
            Not equal
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.ComparisonType.GreaterThan">
      <summary>
            Greater than
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.ComparisonType.GreaterThanOrEqual">
      <summary>
            Greater than or equal
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.ComparisonType.LessThan">
      <summary>
            Less than
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.ComparisonType.LessThanOrEqual">
      <summary>
            Less than or equal
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.Enums.IsValid">
      <summary>
            IsValid types
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.IsValid.CreditCard">
      <summary>
            Credit card
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.IsValid.Decimal">
      <summary>
            Decimal
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.IsValid.Domain">
      <summary>
            Domain
            </summary>
    </member>
    <member name="F:Utilities.Validation.Rules.Enums.IsValid.Integer">
      <summary>
            Integer
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.IsAttribute">
      <summary>
            Is attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.IsAttribute.#ctor(Utilities.Validation.Rules.Enums.IsValid,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Type">Validation type enum</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.IsAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.IsAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.IsAttribute.GetClientValidationRules(System.Web.Mvc.ModelMetadata,System.Web.Mvc.ControllerContext)">
      <summary>
            Gets the client side validation rules
            </summary>
      <param name="metadata">Model meta data</param>
      <param name="context">Controller context</param>
      <returns>The list of client side validation rules</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.IsAttribute.Type">
      <summary>
            Type of validation to do
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions">
      <summary>
            DateTime extension methods
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.AddWeeks(System.DateTime,System.Int32)">
      <summary>
            Adds the number of weeks to the date
            </summary>
      <param name="Date">Date input</param>
      <param name="NumberOfWeeks">Number of weeks to add</param>
      <returns>The date after the number of weeks are added</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.Age(System.DateTime,System.DateTime)">
      <summary>
            Calculates age based on date supplied
            </summary>
      <param name="Date">Birth date</param>
      <param name="CalculateFrom">Date to calculate from</param>
      <returns>The total age in years</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.BeginningOf(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            Beginning of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <returns>The beginning of a specific time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.BeginningOf(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            Beginning of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The beginning of a specific time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.DaysIn(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days from</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <returns>The number of days in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.DaysIn(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days from</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The number of days in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.DaysLeftIn(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days left in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days left</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <returns>The number of days left in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.DaysLeftIn(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            Gets the number of days left in the time frame specified based on the date
            </summary>
      <param name="Date">Date</param>
      <param name="TimeFrame">Time frame to calculate the number of days left</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The number of days left in the time frame</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.EndOf(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.Globalization.CultureInfo)">
      <summary>
            End of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <returns>The end of a specific time frame (TimeFrame.Day is the only one that sets the time to 12:59:59 PM, all else are the beginning of the day)</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.EndOf(System.DateTime,Utilities.DataTypes.ExtensionMethods.TimeFrame,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
            End of a specific time frame
            </summary>
      <param name="Date">Date to base off of</param>
      <param name="TimeFrame">Time frame to use</param>
      <param name="Culture">Culture to use for calculating (defaults to the current culture)</param>
      <param name="StartOfQuarter1">Start of the first quarter</param>
      <returns>The end of a specific time frame (TimeFrame.Day is the only one that sets the time to 12:59:59 PM, all else are the beginning of the day)</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.Is(System.DateTime,Utilities.DataTypes.ExtensionMethods.DateCompare)">
      <summary>
            Determines if the date fulfills the comparison
            </summary>
      <param name="Date">Date to check</param>
      <param name="Comparison">Comparison type (can be combined, so you can do weekday in the future, etc)</param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.LocalTimeZone(System.DateTime)">
      <summary>
            Gets the local time zone
            </summary>
      <param name="Date">Date object</param>
      <returns>The local time zone</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.SetTime(System.DateTime,System.Int32,System.Int32,System.Int32)">
      <summary>
            Sets the time portion of a specific date
            </summary>
      <param name="Date">Date input</param>
      <param name="Hour">Hour to set</param>
      <param name="Minutes">Minutes to set</param>
      <param name="Seconds">Seconds to set</param>
      <returns>Sets the time portion of the specified date</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.SetTime(System.DateTime,System.TimeSpan)">
      <summary>
            Sets the time portion of a specific date
            </summary>
      <param name="Date">Date input</param>
      <param name="Time">Time to set</param>
      <returns>Sets the time portion of the specified date</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.To(System.DateTime,System.TimeZoneInfo)">
      <summary>
            Converts a DateTime to a specific time zone
            </summary>
      <param name="Date">DateTime to convert</param>
      <param name="TimeZone">Time zone to convert to</param>
      <returns>The converted DateTime</returns>
      <requires description="TimeZone" exception="T:System.ArgumentNullException" csharp="TimeZone != null" vb="TimeZone &lt;&gt; Nothing">TimeZone != null</requires>
      <exception cref="T:System.ArgumentNullException">TimeZone == null</exception>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.To(System.DateTime,System.DateTime)">
      <summary>
            Returns the date in int format based on an Epoch (defaults to unix epoch of 1/1/1970)
            </summary>
      <param name="Date">Date to convert</param>
      <param name="Epoch">Epoch to use (defaults to unix epoch of 1/1/1970)</param>
      <returns>The date in Unix format</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.To(System.Int32,System.DateTime)">
      <summary>
            Returns the date in DateTime format based on an Epoch (defaults to unix epoch of 1/1/1970)
            </summary>
      <param name="Date">Date to convert</param>
      <param name="Epoch">Epoch to use (defaults to unix epoch of 1/1/1970)</param>
      <returns>The Unix Date in DateTime format</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.To(System.Int64,System.DateTime)">
      <summary>
            Returns the date in DateTime format based on an Epoch (defaults to unix epoch of 1/1/1970)
            </summary>
      <param name="Date">Date to convert</param>
      <param name="Epoch">Epoch to use (defaults to unix epoch of 1/1/1970)</param>
      <returns>The Unix Date in DateTime format</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.ToString(System.DateTime,System.DateTime)">
      <summary>
            Converts the DateTime object to string describing, relatively how long ago or how far in the future
            the input is based off of another DateTime object specified.
            ex: 
            Input=March 21, 2013
            Epoch=March 22, 2013
            returns "1 day ago"
            Input=March 22, 2013
            Epoch=March 21, 2013
            returns "1 day from now"
            </summary>
      <param name="Input">Input</param>
      <param name="Epoch">DateTime object that the input is comparred to</param>
      <returns>The difference between the input and epoch expressed as a string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.DateTimeExtensions.UTCOffset(System.DateTime)">
      <summary>
            Gets the UTC offset
            </summary>
      <param name="Date">Date to get the offset of</param>
      <returns>UTC offset</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.DateCompare">
      <summary>
            Date comparison type
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.DateCompare.InFuture">
      <summary>
            In the future
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.DateCompare.InPast">
      <summary>
            In the past
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.DateCompare.Today">
      <summary>
            Today
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.DateCompare.WeekDay">
      <summary>
            Weekday
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.DateCompare.WeekEnd">
      <summary>
            Weekend
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.TimeFrame">
      <summary>
            Time frame
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.TimeFrame.Day">
      <summary>
            Day
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.TimeFrame.Week">
      <summary>
            Week
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.TimeFrame.Month">
      <summary>
            Month
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.TimeFrame.Quarter">
      <summary>
            Quarter
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.TimeFrame.Year">
      <summary>
            Year
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.StringExtensions">
      <summary>
            String and StringBuilder extensions
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.AppendLineFormat(System.Text.StringBuilder,System.String,System.Object[])">
      <summary>
            Does an AppendFormat and then an AppendLine on the StringBuilder
            </summary>
      <param name="Builder">Builder object</param>
      <param name="Format">Format string</param>
      <param name="Objects">Objects to format</param>
      <returns>The StringBuilder passed in</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Center(System.String,System.Int32,System.String)">
      <summary>
            Centers the input string (if it's longer than the length) and pads it using the padding string
            </summary>
      <param name="Input" />
      <param name="Length" />
      <param name="Padding" />
      <returns>The centered string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Encode(System.String,System.Text.Encoding,System.Text.Encoding)">
      <summary>
            Converts a string to a string of another encoding
            </summary>
      <param name="Input">input string</param>
      <param name="OriginalEncodingUsing">The type of encoding the string is currently using (defaults to ASCII)</param>
      <param name="EncodingUsing">The type of encoding the string is converted into (defaults to UTF8)</param>
      <returns>string of the byte array</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.FromBase64(System.String,System.Text.Encoding)">
      <summary>
            Converts base 64 string based on the encoding passed in
            </summary>
      <param name="Input">Input string</param>
      <param name="EncodingUsing">The type of encoding the string is using (defaults to UTF8)</param>
      <returns>string in the encoding format</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.FromBase64(System.String)">
      <summary>
            Converts base 64 string to a byte array
            </summary>
      <param name="Input">Input string</param>
      <returns>A byte array equivalent of the base 64 string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Is(System.String,Utilities.DataTypes.ExtensionMethods.StringCompare)">
      <summary>
            Is this value of the specified type
            </summary>
      <param name="Value">Value to compare</param>
      <param name="ComparisonType">Comparison type</param>
      <returns>True if it is of the type specified, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Is(System.String,System.String,Utilities.DataTypes.ExtensionMethods.StringCompare)">
      <summary>
            Is this value of the specified type
            </summary>
      <param name="Value1">Value 1 to compare</param>
      <param name="Value2">Value 2 to compare</param>
      <param name="ComparisonType">Comparison type</param>
      <returns>True if it is of the type specified, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Keep(System.String,System.String)">
      <summary>
            Removes everything that is not in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Regex expression of text to keep</param>
      <returns>The input text minus everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Keep(System.String,Utilities.DataTypes.ExtensionMethods.StringFilter)">
      <summary>
            Removes everything that is not in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Predefined filter to use (can be combined as they are flags)</param>
      <returns>The input text minus everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Left(System.String,System.Int32)">
      <summary>
            Gets the first x number of characters from the left hand side
            </summary>
      <param name="Input">Input string</param>
      <param name="Length">x number of characters to return</param>
      <returns>The resulting string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.LevenshteinDistance(System.String,System.String)">
      <summary>
            Calculates the Levenshtein distance
            </summary>
      <param name="Value1">Value 1</param>
      <param name="Value2">Value 2</param>
      <returns>The Levenshtein distance</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.MaskLeft(System.String,System.Int32,System.Char)">
      <summary>
            Masks characters to the left ending at a specific character
            </summary>
      <param name="Input">Input string</param>
      <param name="EndPosition">End position (counting from the left)</param>
      <param name="Mask">Mask character to use</param>
      <returns>The masked string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.MaskRight(System.String,System.Int32,System.Char)">
      <summary>
            Masks characters to the right starting at a specific character
            </summary>
      <param name="Input">Input string</param>
      <param name="StartPosition">Start position (counting from the left)</param>
      <param name="Mask">Mask character to use</param>
      <returns>The masked string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.NumberTimesOccurs(System.String,System.String)">
      <summary>
            returns the number of times a string occurs within the text
            </summary>
      <param name="Input">input text</param>
      <param name="Match">The string to match (can be regex)</param>
      <returns>The number of times the string occurs</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Pluralize(System.String,System.Globalization.CultureInfo)">
      <summary>
            Pluralizes a word
            </summary>
      <param name="Word">Word to pluralize</param>
      <param name="Culture">Culture info used to pluralize the word (defaults to current culture)</param>
      <returns>The word pluralized</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Remove(System.String,System.String)">
      <summary>
            Removes everything that is in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Regex expression of text to remove</param>
      <returns>Everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Remove(System.String,Utilities.DataTypes.ExtensionMethods.StringFilter)">
      <summary>
            Removes everything that is in the filter text from the input.
            </summary>
      <param name="Input">Input text</param>
      <param name="Filter">Predefined filter to use (can be combined as they are flags)</param>
      <returns>Everything not in the filter text.</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Replace(System.String,Utilities.DataTypes.ExtensionMethods.StringFilter,System.String)">
      <summary>
            Replaces everything that is in the filter text with the value specified.
            </summary>
      <param name="Input">Input text</param>
      <param name="Value">Value to fill in</param>
      <param name="Filter">Predefined filter to use (can be combined as they are flags)</param>
      <returns>The input text with the various items replaced</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Reverse(System.String)">
      <summary>
            Reverses a string
            </summary>
      <param name="Input">Input string</param>
      <returns>The reverse of the input string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Right(System.String,System.Int32)">
      <summary>
            Gets the last x number of characters from the right hand side
            </summary>
      <param name="Input">Input string</param>
      <param name="Length">x number of characters to return</param>
      <returns>The resulting string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.Singularize(System.String,System.Globalization.CultureInfo)">
      <summary>
            Singularizes a word
            </summary>
      <param name="Word">Word to singularize</param>
      <param name="Culture">Culture info used to singularize the word (defaults to current culture)</param>
      <returns>The word singularized</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.StripLeft(System.String,System.String)">
      <summary>
            Strips out any of the characters specified starting on the left side of the input string (stops when a character not in the list is found)
            </summary>
      <param name="Input">Input string</param>
      <param name="Characters">Characters to strip (defaults to a space)</param>
      <returns>The Input string with specified characters stripped out</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.StripRight(System.String,System.String)">
      <summary>
            Strips out any of the characters specified starting on the right side of the input string (stops when a character not in the list is found)
            </summary>
      <param name="Input">Input string</param>
      <param name="Characters">Characters to strip (defaults to a space)</param>
      <returns>The Input string with specified characters stripped out</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.StripIllegalXML(System.String)">
      <summary>
            Strips illegal characters for XML content
            </summary>
      <param name="Content">Content</param>
      <returns>The stripped string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToBase64(System.String,System.Text.Encoding)">
      <summary>
            Converts from the specified encoding to a base 64 string
            </summary>
      <param name="Input">Input string</param>
      <param name="OriginalEncodingUsing">The type of encoding the string is using (defaults to UTF8)</param>
      <returns>Bas64 string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToByteArray(System.String,System.Text.Encoding)">
      <summary>
            Converts a string to a byte array
            </summary>
      <param name="Input">input string</param>
      <param name="EncodingUsing">The type of encoding the string is using (defaults to UTF8)</param>
      <returns>the byte array representing the string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToString(System.String,Utilities.DataTypes.ExtensionMethods.StringCase)">
      <summary>
            Formats the string based on the capitalization specified
            </summary>
      <param name="Input">Input string</param>
      <param name="Case">Capitalization type to use</param>
      <returns>Capitalizes the string based on the case specified</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToString(System.String,System.String,Utilities.DataTypes.Formatters.Interfaces.IStringFormatter)">
      <summary>
            Formats a string based on a format string passed in.
            The default formatter uses the following format:
            # = digits
            @ = alpha characters
            \ = escape char
            </summary>
      <param name="Input">Input string</param>
      <param name="Format">Format of the output string</param>
      <param name="Provider">String formatter provider (defaults to GenericStringFormatter)</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToString(System.String,System.Object,System.String,System.String)">
      <summary>
            Formats a string based on the object's properties
            </summary>
      <param name="Input">Input string</param>
      <param name="Object">Object to use to format the string</param>
      <param name="StartSeperator">Seperator character/string to use to describe the start of the property name</param>
      <param name="EndSeperator">Seperator character/string to use to describe the end of the property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToString(System.String,System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
      <summary>
            Formats a string based on the key/value pairs that are sent in
            </summary>
      <param name="Input">Input string</param>
      <param name="Pairs">Key/value pairs. Replaces the key with the corresponding value.</param>
      <returns>The string after the changes have been made</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.StringExtensions.ToString(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
      <summary>
            Uses a regex to format the input string
            </summary>
      <param name="Input">Input string</param>
      <param name="Format">Regex string used to</param>
      <param name="OutputFormat">Output format</param>
      <param name="Options">Regex options</param>
      <returns>The input string formatted by using the regex string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.StringCase">
      <summary>
            What sort of string capitalization should be used?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringCase.SentenceCapitalize">
      <summary>
            Sentence capitalization
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringCase.FirstCharacterUpperCase">
      <summary>
            First character upper case
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringCase.TitleCase">
      <summary>
            Title case
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.StringCompare">
      <summary>
            What type of string comparison are we doing?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringCompare.CreditCard">
      <summary>
            Is this a credit card number?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringCompare.Anagram">
      <summary>
            Is this an anagram?
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringCompare.Unicode">
      <summary>
            Is this Unicode
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.StringFilter">
      <summary>
            Predefined filters
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringFilter.Alpha">
      <summary>
            Alpha characters
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringFilter.Numeric">
      <summary>
            Numeric characters
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringFilter.FloatNumeric">
      <summary>
            Numbers with period, basically allows for decimal point
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.StringFilter.ExtraSpaces">
      <summary>
            Multiple spaces
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.TypeConversionExtensions">
      <summary>
            Extensions converting between types, checking if something is null, etc.
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TypeConversionExtensions.FormatToString(System.Object,System.String)">
      <summary>
            Calls the object's ToString function passing in the formatting
            </summary>
      <param name="Input">Input object</param>
      <param name="Format">Format of the output string</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TypeConversionExtensions.ToList``1(System.Data.DataTable,System.Func{``0})">
      <summary>
            Attempts to convert the DataTable to a list of objects
            </summary>
      <typeparam name="T">Type the objects should be in the list</typeparam>
      <param name="Data">DataTable to convert</param>
      <param name="Creator">Function used to create each object</param>
      <returns>The DataTable converted to a list of objects</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TypeConversionExtensions.To``2(``0,``1)">
      <summary>
            Attempts to convert the object to another type and returns the value
            </summary>
      <typeparam name="T">Type to convert from</typeparam>
      <typeparam name="R">Return type</typeparam>
      <param name="Object">Object to convert</param>
      <param name="DefaultValue">Default value to return if there is an issue or it can't be converted</param>
      <returns>The object converted to the other type or the default value if there is an error or can't be converted</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.TypeConversionExtensions.To``1(``0,System.Type,System.Object)">
      <summary>
            Attempts to convert the object to another type and returns the value
            </summary>
      <typeparam name="T">Type to convert from</typeparam>
      <param name="ResultType">Result type</param>
      <param name="Object">Object to convert</param>
      <param name="DefaultValue">Default value to return if there is an issue or it can't be converted</param>
      <returns>The object converted to the other type or the default value if there is an error or can't be converted</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.ValueTypeExtensions">
      <summary>
            Value type extension methods
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ValueTypeExtensions.ToString(System.Byte[],System.Base64FormattingOptions,System.Int32,System.Int32)">
      <summary>
            Converts a byte array into a base 64 string
            </summary>
      <param name="Input">Input array</param>
      <param name="Count">Number of bytes starting at the index to convert (use -1 for the entire array starting at the index)</param>
      <param name="Index">Index to start at</param>
      <param name="Options">Base 64 formatting options</param>
      <returns>The equivalent byte array in a base 64 string</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ValueTypeExtensions.ToString(System.Byte[],System.Text.Encoding,System.Int32,System.Int32)">
      <summary>
            Converts a byte array to a string
            </summary>
      <param name="Input">input array</param>
      <param name="EncodingUsing">The type of encoding the string is using (defaults to UTF8)</param>
      <param name="Count">Number of bytes starting at the index to convert (use -1 for the entire array starting at the index)</param>
      <param name="Index">Index to start at</param>
      <returns>string of the byte array</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ValueTypeExtensions.Is(System.Char,Utilities.DataTypes.ExtensionMethods.CharIs)">
      <summary>
            Is the character of a specific type
            </summary>
      <param name="Value">Value to check</param>
      <param name="CharacterType">Character type</param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ExtensionMethods.ValueTypeExtensions.IsUnicode(System.Byte[])">
      <summary>
            Determines if a byte array is unicode
            </summary>
      <param name="Input">Input array</param>
      <returns>True if it's unicode, false otherwise</returns>
    </member>
    <member name="T:Utilities.DataTypes.ExtensionMethods.CharIs">
      <summary>
            What type of character is this
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.WhiteSpace">
      <summary>
            White space
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Upper">
      <summary>
            Upper case
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Symbol">
      <summary>
            Symbol
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Surrogate">
      <summary>
            Surrogate
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Punctuation">
      <summary>
            Punctuation
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Number">
      <summary>
            Number
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.LowSurrogate">
      <summary>
            Low surrogate
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Lower">
      <summary>
            Lower
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.LetterOrDigit">
      <summary>
            letter or digit
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Letter">
      <summary>
            Letter
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.HighSurrogate">
      <summary>
            High surrogate
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Digit">
      <summary>
            Digit
            </summary>
    </member>
    <member name="F:Utilities.DataTypes.ExtensionMethods.CharIs.Control">
      <summary>
            Control
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Directory">
      <summary>
            Directory class
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Interfaces.IDisplay">
      <summary>
            Displayable item interface
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Interfaces.IDisplay.SoftKeys">
      <summary>
            Softkey items
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Directory.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Directory.ToString">
      <summary>
            The formatted string version of the directory
            </summary>
      <returns>The formatted string output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Directory.DirectoryEntries">
      <summary>
            Directory entries
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Directory.Prompt">
      <summary>
            Prompt
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Directory.SoftKeys">
      <summary>
            Soft keys
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Directory.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.DirectoryEntry">
      <summary>
            Directory entry
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.DirectoryEntry.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.DirectoryEntry.ToString">
      <summary>
            Exports the directory entry to a formatted string
            </summary>
      <returns>Formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.DirectoryEntry.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.DirectoryEntry.Telephone">
      <summary>
            Telephone
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Error">
      <summary>
            Error class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Error.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Error.ToString">
      <summary>
            Exports the error as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Error.Text">
      <summary>
            Error text
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Error.Number">
      <summary>
            Error Number
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Execute">
      <summary>
            Execute class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Execute.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Execute.ToString">
      <summary>
            Exports the properly formatted version of the execute object
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Execute.ExecuteItems">
      <summary>
            Execute items
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.ExecuteItem">
      <summary>
            Execute item
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.ExecuteItem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.ExecuteItem.ToString">
      <summary>
            Exports the execute item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.ExecuteItem.Priority">
      <summary>
            Priority
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.ExecuteItem.URL">
      <summary>
            URL
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.GraphicMenuItem">
      <summary>
            Graphic menu item
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Interfaces.IMenuItem">
      <summary>
            Menu item interface
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.GraphicMenuItem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.GraphicMenuItem.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.GraphicMenuItem.Name">
      <summary>
            Name of the Graphic menu
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.GraphicMenuItem.URL">
      <summary>
            Invoked when area touched
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.GraphicMenuItem.X1">
      <summary>
            Left
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.GraphicMenuItem.X2">
      <summary>
            Right
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.GraphicMenuItem.Y1">
      <summary>
            Top
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.GraphicMenuItem.Y2">
      <summary>
            Bottom
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Image">
      <summary>
            Image class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Image.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Image.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Image.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Image.Prompt">
      <summary>
            Prompt
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Image.X">
      <summary>
            X location
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Image.Y">
      <summary>
            Y location
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Image.URL">
      <summary>
            URL to the image
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Image.SoftKeys">
      <summary>
            Soft keys
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Input">
      <summary>
            Input class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Input.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Input.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Input.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Input.Prompt">
      <summary>
            Prompt
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Input.URL">
      <summary>
            URL
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Input.InputItems">
      <summary>
            Input items
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Input.SoftKeys">
      <summary>
            Soft keys
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.InputFlag">
      <summary>
            Input type flags
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.ASCII">
      <summary>
            ASCII
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.TelephoneNumber">
      <summary>
            Telephone number
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.Numeric">
      <summary>
            Numeric
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.Equation">
      <summary>
            Equation
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.Uppercase">
      <summary>
            Uppercase
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.Lowercase">
      <summary>
            Lowercase
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Cisco.InputFlag.Password">
      <summary>
            Password
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.InputItem">
      <summary>
            Input item
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.InputItem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.InputItem.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.InputItem.DisplayName">
      <summary>
            Display name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.InputItem.QueryStringParam">
      <summary>
            Query string parameter
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.InputItem.DefaultValue">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.InputItem.InputFlags">
      <summary>
            input flags
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.MenuItem">
      <summary>
            Menu item class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.MenuItem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.MenuItem.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.MenuItem.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.MenuItem.URL">
      <summary>
            URL
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Menu">
      <summary>
            Phone menu class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Menu.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Menu.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.Title">
      <summary>
            Title of the menu
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.Prompt">
      <summary>
            Prompt of the menu
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.MenuItems">
      <summary>
            Menu items for the menu
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.X">
      <summary>
            X location of backgroun image (if present)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.Y">
      <summary>
            Y location of backgroun image (if present)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.ImageURL">
      <summary>
            URL for background image (if needed)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Menu.SoftKeys">
      <summary>
            Soft keys
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.SoftKeyItem">
      <summary>
            Softkey class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.SoftKeyItem.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.SoftKeyItem.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.SoftKeyItem.Name">
      <summary>
            Name of the softkey
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.SoftKeyItem.URL">
      <summary>
            URL action for release event
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.SoftKeyItem.URLDown">
      <summary>
            URL action for press event
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.SoftKeyItem.Position">
      <summary>
            position of softkey
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Status">
      <summary>
            Status class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Status.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Status.ToString">
      <summary>
            Converts the status to a formatted string
            </summary>
      <returns>The formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Status.Text">
      <summary>
            Text
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Status.Timer">
      <summary>
            Timer value in seconds
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Status.X">
      <summary>
            X location
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Status.Y">
      <summary>
            Y location
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Status.URL">
      <summary>
            Location of the image
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Status.SoftKeys">
      <summary>
            Soft keys
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Cisco.Text">
      <summary>
            Text class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Text.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Cisco.Text.ToString">
      <summary>
            Exports the item as a properly formatted string
            </summary>
      <returns>The properly formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Text.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Text.Prompt">
      <summary>
            Prompt
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Text.Content">
      <summary>
            Text
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Cisco.Text.SoftKeys">
      <summary>
            Soft keys
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Config`1">
      <summary>
            Config object
            </summary>
    </member>
    <member name="T:Utilities.Configuration.Interfaces.IConfig">
      <summary>
            Config interface
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Interfaces.IConfig.Load">
      <summary>
            Loads the config file
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Interfaces.IConfig.Save">
      <summary>
            Saves the config file
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Interfaces.IConfig.Name">
      <summary>
            Name of the config file
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Config`1.#ctor(System.Func{System.String,`0},System.Func{Utilities.Configuration.Interfaces.IConfig,System.String})">
      <summary>
            Constructor
            </summary>
      <param name="StringToObject">String to object</param>
      <param name="ObjectToString">Object to string</param>
    </member>
    <member name="M:Utilities.Configuration.Config`1.Load">
      <summary>
            Loads the config
            </summary>
    </member>
    <member name="M:Utilities.Configuration.Config`1.Save">
      <summary>
            Saves the config
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Config`1.ConfigFileLocation">
      <summary>
            Location to save/load the config file from.
            If blank, it does not save/load but uses any defaults specified.
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Config`1.EncryptionPassword">
      <summary>
            Encryption password for properties/fields. Used only if set.
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Config`1.StringToObject">
      <summary>
            Gets the object
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Config`1.ObjectToString">
      <summary>
            Gets a string representation of the object
            </summary>
    </member>
    <member name="P:Utilities.Configuration.Config`1.Name">
      <summary>
            Name of the config object
            </summary>
    </member>
    <member name="T:Utilities.Configuration.ConfigurationManager">
      <summary>
            Config manager
            </summary>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.RegisterConfigFile``1">
      <summary>
            Registers a config file
            </summary>
      <typeparam name="ConfigType">The config object type to register</typeparam>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.RegisterConfigFile(Utilities.Configuration.Interfaces.IConfig)">
      <summary>
            Registers a config file
            </summary>
      <param name="ConfigObject">Config object to register</param>
      <requires description="ConfigObject" exception="T:System.ArgumentNullException" csharp="ConfigObject != null" vb="ConfigObject &lt;&gt; Nothing">ConfigObject != null</requires>
      <exception cref="T:System.ArgumentNullException">ConfigObject == null</exception>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.RegisterConfigFile(System.Collections.Generic.IEnumerable{Utilities.Configuration.Interfaces.IConfig})">
      <summary>
            Registers a set of config file
            </summary>
      <param name="ConfigObjects">Config objects to register</param>
      <requires description="ConfigObjects" exception="T:System.ArgumentNullException" csharp="ConfigObjects != null" vb="ConfigObjects &lt;&gt; Nothing">ConfigObjects != null</requires>
      <exception cref="T:System.ArgumentNullException">ConfigObjects == null</exception>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.RegisterConfigFile(System.Reflection.Assembly)">
      <summary>
            Registers all config files in an assembly
            </summary>
      <param name="AssemblyContainingConfig">Assembly to search</param>
      <requires description="AssemblyContainingConfig" exception="T:System.ArgumentNullException" csharp="AssemblyContainingConfig != (System.Reflection.Assembly)null" vb="AssemblyContainingConfig &lt;&gt; ((System.Reflection.Assembly)Nothing) ">AssemblyContainingConfig != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!AssemblyContainingConfig != (System.Reflection.Assembly)null</exception>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.GetConfigFile``1(System.String)">
      <summary>
            Gets a specified config file
            </summary>
      <typeparam name="T">Type of the config object</typeparam>
      <param name="Name">Name of the config object</param>
      <returns>The config object specified</returns>
      <requires description="The config object was not found or was not of the type specified." exception="T:System.ArgumentException" csharp="ContainsConfigFile&lt;T&gt;(Name)" vb="ContainsConfigFile(Name)">Utilities.Configuration.ConfigurationManager.ContainsConfigFile&lt;T&gt;(Name)</requires>
      <exception cref="T:System.ArgumentException">!Utilities.Configuration.ConfigurationManager.ContainsConfigFile&lt;T&gt;(Name)</exception>
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.ContainsConfigFile``1(System.String)">
      <summary>
            Determines if a specified config file is registered
            </summary>
      <typeparam name="T">Type of the config object</typeparam>
      <param name="Name">Name of the config object</param>
      <returns>The config object specified</returns>
      <pure />
    </member>
    <member name="M:Utilities.Configuration.ConfigurationManager.ToString">
      <summary>
            Outputs all of the configuration items as an HTML list
            </summary>
      <returns>All configs as a string list</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.DataMapper.Interfaces.ITypeMapping">
      <summary>
            Type mapping interface
            </summary>
    </member>
    <member name="T:Utilities.DataMapper.Mapping`2">
      <summary>
            Mapping class
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Constructor
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightExpression">Right expression</param>
      <requires description="LeftExpression" csharp="LeftExpression != null" vb="LeftExpression &lt;&gt; Nothing">LeftExpression != null</requires>
      <requires description="RightExpression" csharp="RightExpression != null" vb="RightExpression &lt;&gt; Nothing">RightExpression != null</requires>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.#ctor(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Constructor
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set action</param>
      <param name="RightExpression">Right expression</param>
      <requires description="LeftGet" csharp="LeftGet != null" vb="LeftGet &lt;&gt; Nothing">LeftGet != null</requires>
      <requires description="LeftSet" csharp="LeftSet != null" vb="LeftSet &lt;&gt; Nothing">LeftSet != null</requires>
      <requires description="RightExpression" csharp="RightExpression != null" vb="RightExpression &lt;&gt; Nothing">RightExpression != null</requires>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Constructor
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
      <requires description="LeftExpression" csharp="LeftExpression != null" vb="LeftExpression &lt;&gt; Nothing">LeftExpression != null</requires>
      <requires description="RightGet" csharp="RightGet != null" vb="RightGet &lt;&gt; Nothing">RightGet != null</requires>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.#ctor(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Constructor
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set function</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
      <requires description="LeftGet" csharp="LeftGet != null" vb="LeftGet &lt;&gt; Nothing">LeftGet != null</requires>
      <requires description="LeftSet" csharp="LeftSet != null" vb="LeftSet &lt;&gt; Nothing">LeftSet != null</requires>
      <requires description="RightGet" csharp="RightGet != null" vb="RightGet &lt;&gt; Nothing">RightGet != null</requires>
      <requires description="RightSet" csharp="RightSet != null" vb="RightSet &lt;&gt; Nothing">RightSet != null</requires>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.Copy(`0,`1)">
      <summary>
            Copies the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.Copy(`1,`0)">
      <summary>
            Copies the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.CopyLeftToRight(`0,`1)">
      <summary>
            Copies from the source to the destination (used in 
            instances when both Left and Right are the same type
            and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataMapper.Mapping`2.CopyRightToLeft(`1,`0)">
      <summary>
            Copies from the source to the destination (used in 
            instances when both Left and Right are the same type
            and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="P:Utilities.DataMapper.Mapping`2.LeftGet">
      <summary>
            Left get function
            </summary>
    </member>
    <member name="P:Utilities.DataMapper.Mapping`2.RightGet">
      <summary>
            Right get function
            </summary>
    </member>
    <member name="P:Utilities.DataMapper.Mapping`2.LeftSet">
      <summary>
            Left set function
            </summary>
    </member>
    <member name="P:Utilities.DataMapper.Mapping`2.RightSet">
      <summary>
            Right set function
            </summary>
    </member>
    <member name="T:Utilities.DataMapper.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="M:Utilities.DataMapper.MappingManager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataMapper.MappingManager.Map``2">
      <summary>
            Adds or returns a mapping between two types
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
      <returns>A mapping object for the two types specified</returns>
    </member>
    <member name="P:Utilities.DataMapper.MappingManager.Mappings">
      <summary>
            Mappings
            </summary>
    </member>
    <member name="T:Utilities.DataMapper.TypeMapping`2">
      <summary>
            Maps two types together
            </summary>
      <typeparam name="Left">Left type</typeparam>
      <typeparam name="Right">Right type</typeparam>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.AutoMap">
      <summary>
            Automatically maps properties that are named the same thing
            </summary>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightExpression">Right expression</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set action</param>
      <param name="RightExpression">Right expression</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.AddMapping(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftExpression">Left expression</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.AddMapping(System.Func{`0,System.Object},System.Action{`0,System.Object},System.Func{`1,System.Object},System.Action{`1,System.Object})">
      <summary>
            Adds a mapping
            </summary>
      <param name="LeftGet">Left get function</param>
      <param name="LeftSet">Left set function</param>
      <param name="RightGet">Right get function</param>
      <param name="RightSet">Right set function</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.Copy(`0,`1)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.Copy(`1,`0)">
      <summary>
            Copies from the source to the destination
            </summary>
      <param name="Source">Source object</param>
      <param name="Destination">Destination object</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.CopyLeftToRight(`0,`1)">
      <summary>
            Copies from the source to the destination (used in 
            instances when both Left and Right are the same type
            and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="M:Utilities.DataMapper.TypeMapping`2.CopyRightToLeft(`1,`0)">
      <summary>
            Copies from the source to the destination (used in 
            instances when both Left and Right are the same type
            and thus Copy is ambiguous)
            </summary>
      <param name="Source">Source</param>
      <param name="Destination">Destination</param>
    </member>
    <member name="P:Utilities.DataMapper.TypeMapping`2.Mappings">
      <summary>
            List of mappings
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Zip.ZipFile">
      <summary>
            Helper class for dealing with zip files
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.#ctor(System.String,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="FilePath">Path to the zip file</param>
      <param name="Overwrite">Should the zip file be overwritten?</param>
      <requires description="FilePath" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(FilePath)" vb="Not IsNullOrEmpty(FilePath)">!string.IsNullOrEmpty(FilePath)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(FilePath)</exception>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.AddFolder(System.String)">
      <summary>
            Adds a folder to the zip file
            </summary>
      <param name="Folder">Folder to add</param>
      <requires description="Folder" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(new Utilities.FileFormats.Zip.ZipFile.&lt;&gt;c__DisplayClass1(){&#xD;&#xA;    Folder = Folder, &#xD;&#xA;    &lt;&gt;4__this = this, &#xD;&#xA;}.Folder)" vb="Not IsNullOrEmpty((() =&gt; {&#xD;&#xA;    Utilities.FileFormats.Zip.ZipFile.&lt;&gt;c__DisplayClass1 local_0_prime = New Utilities.FileFormats.Zip.ZipFile.&lt;&gt;c__DisplayClass1();&#xD;&#xA;    local_0_prime.Folder = Folder&#xD;&#xA;    local_0_prime.&lt;&gt;4__this = Me&#xD;&#xA;    return local_0_prime; })().Folder)">!string.IsNullOrEmpty(new Utilities.FileFormats.Zip.ZipFile.&lt;&gt;c__DisplayClass1(){
    Folder = Folder, 
    &lt;&gt;4__this = this, 
}.Folder)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(new Utilities.FileFormats.Zip.ZipFile.&lt;&gt;c__DisplayClass1(){
    Folder = Folder, 
    &lt;&gt;4__this = this, 
}.Folder)</exception>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.AddFile(System.String)">
      <summary>
            Adds a file to the zip file
            </summary>
      <param name="File">File to add</param>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(File)" vb="Not IsNullOrEmpty(File)">!string.IsNullOrEmpty(File)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(File)</exception>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.UncompressFile(System.String)">
      <summary>
            Uncompresses the zip file to the specified folder
            </summary>
      <param name="Folder">Folder to uncompress the file in</param>
      <requires description="Folder" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Folder)" vb="Not IsNullOrEmpty(Folder)">!string.IsNullOrEmpty(Folder)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Folder)</exception>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.Extract(System.IO.Packaging.PackagePart,System.String)">
      <summary>
            Extracts an individual file
            </summary>
      <param name="Document">Document to extract</param>
      <param name="Folder">Folder to extract it into</param>
      <requires description="Folder" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Folder)" vb="Not IsNullOrEmpty(Folder)">!string.IsNullOrEmpty(Folder)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Folder)</exception>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.AddFile(System.String,System.IO.FileInfo,System.IO.Packaging.Package)">
      <summary>
            Adds a file to the zip file
            </summary>
      <param name="File">File to add</param>
      <param name="FileInfo">File information</param>
      <param name="Package">Package to add the file to</param>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(File)" vb="Not IsNullOrEmpty(File)">!string.IsNullOrEmpty(File)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(File)</exception>
      <requires description="FileInfo does not exist" exception="T:System.IO.FileNotFoundException" csharp="FileInfo.Exists" vb="FileInfo.Exists">FileInfo.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!FileInfo.Exists</exception>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="M:Utilities.FileFormats.Zip.ZipFile.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Zip.ZipFile.ZipFileStream">
      <summary>
            Zip file's FileStream
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Bag`1">
      <summary>
            Used to count the number of times something is added to the list
            </summary>
      <typeparam name="T">Type of data within the bag</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Add(`0)">
      <summary>
            Adds an item to the bag
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Clear">
      <summary>
            Clears the bag
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Contains(`0)">
      <summary>
            Determines if the bag contains an item
            </summary>
      <param name="item">Item to check</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the bag to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.Remove(`0)">
      <summary>
            Removes an item from the bag
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.Bag`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.Count">
      <summary>
            Number of items in the bag
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.Item(`0)">
      <summary>
            Gets a specified item
            </summary>
      <param name="index">Item to get</param>
      <returns>The number of this item in the bag</returns>
    </member>
    <member name="P:Utilities.DataTypes.Bag`1.Items">
      <summary>
            Actual internal container
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Comparison.GenericComparer`1">
      <summary>
            Generic IComparable class
            </summary>
      <typeparam name="T">Data type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Comparison.GenericComparer`1.Compare(`0,`0)">
      <summary>
            Compares the two objects
            </summary>
      <param name="x">Object 1</param>
      <param name="y">Object 2</param>
      <returns>0 if they're equal, any other value they are not</returns>
    </member>
    <member name="T:Utilities.DataTypes.Comparison.GenericEqualityComparer`1">
      <summary>
            Generic equality comparer
            </summary>
      <typeparam name="T">Data type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Comparison.GenericEqualityComparer`1.Equals(`0,`0)">
      <summary>
            Determines if the two items are equal
            </summary>
      <param name="x">Object 1</param>
      <param name="y">Object 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.Comparison.GenericEqualityComparer`1.GetHashCode(`0)">
      <summary>
            Get hash code
            </summary>
      <param name="obj">Object to get the hash code of</param>
      <returns>The object's hash code</returns>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.Factory`2">
      <summary>
            Factory class
            </summary>
      <typeparam name="Key">The "message" type</typeparam>
      <typeparam name="T">The class type that you want created</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Register(`0,`1)">
      <summary>
            Registers an item
            </summary>
      <param name="Key">Item to register</param>
      <param name="Result">The object to be returned</param>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Register(`0,System.Func{`1})">
      <summary>
            Registers an item
            </summary>
      <param name="Key">Item to register</param>
      <param name="Constructor">The function to call when creating the item</param>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Create(`0)">
      <summary>
            Creates an instance associated with the key
            </summary>
      <param name="Key">Registered item</param>
      <returns>The type returned by the initializer</returns>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.Factory`2.Exists(`0)">
      <summary>
            Determines if a key has been registered
            </summary>
      <param name="Key">Key to check</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="P:Utilities.DataTypes.Patterns.Factory`2.Constructors">
      <summary>
            List of constructors/initializers
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.Patterns.BaseClasses.Singleton`1">
      <summary>
            Base class used for singletons
            </summary>
      <typeparam name="T">The class type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.Patterns.BaseClasses.Singleton`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.Patterns.BaseClasses.Singleton`1.Instance">
      <summary>
            Gets the instance of the singleton
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.ListMapping`2">
      <summary>
            Maps a key to a list of data
            </summary>
      <typeparam name="T1">Key value</typeparam>
      <typeparam name="T2">Type that the list should contain</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Add(`0,`1)">
      <summary>
            Adds an item to the mapping
            </summary>
      <param name="Key">Key value</param>
      <param name="Value">The value to add</param>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Adds a key value pair
            </summary>
      <param name="item">Key value pair to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Add(`0,System.Collections.Generic.ICollection{`1})">
      <summary>
            Adds a list of items to the mapping
            </summary>
      <param name="Key">Key value</param>
      <param name="Value">The values to add</param>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.ContainsKey(`0)">
      <summary>
            Determines if a key exists
            </summary>
      <param name="key">Key to check on</param>
      <returns>True if it exists, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result ⇒ this.Count &gt; 0; })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = Me;&#xD;&#xA;    return result Implies Me.Count &gt; 0; })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;
    }
    return !result || this.Count &gt; 0; })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Remove(`0)">
      <summary>
            Remove a list of items associated with a key
            </summary>
      <param name="key">Key to use</param>
      <returns>True if the key is found, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Removes a key value pair from the list mapping
            </summary>
      <param name="item">items to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Remove(`0,`1)">
      <summary>
            Removes a key value pair from the list mapping
            </summary>
      <param name="Key">Key to remove</param>
      <param name="Value">Value to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Clear">
      <summary>
            Clears all items from the listing
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
      <summary>
            Tries to get the value associated with the key
            </summary>
      <param name="Key">Key value</param>
      <param name="Value">The values getting</param>
      <returns>True if it was able to get the value, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" inheritedFromTypeName="IDictionary" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;&#xD;&#xA;    }&#xD;&#xA;    return result == this.ContainsKey(key); })()" vb="(() =&gt; {&#xD;&#xA;    System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = Me;&#xD;&#xA;    return result = Me.ContainsKey(key); })()">(() =&gt; {
    {
        System.Collections.Generic.IDictionary&lt;T1, System.Collections.Generic.ICollection&lt;T2&gt;&gt; local_0 = this;
    }
    return result == this.ContainsKey(key); })()</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Does this contain the key value pairs?
            </summary>
      <param name="item">Key value pair to check</param>
      <returns>True if it exists, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Contains(`0,System.Collections.Generic.ICollection{`1})">
      <summary>
            Does the list mapping contain the key value pairs?
            </summary>
      <param name="Key">Key value</param>
      <param name="Values">Value</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.Contains(`0,`1)">
      <summary>
            Does the list mapping contain the key value pair?
            </summary>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}}[],System.Int32)">
      <summary>
            Not implemented
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">array index</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator for this object</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.ListMapping`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator for this object</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Items">
      <summary>
            Container holding the data
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Values">
      <summary>
            List that contains the list of values
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Values" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Count">
      <summary>
            The number of items in the listing
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Item(`0)">
      <summary>
            Gets a list of values associated with a key
            </summary>
      <param name="key">Key to look for</param>
      <returns>The list of values</returns>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.Keys">
      <summary>
            The list of keys within the mapping
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.IDictionary`2.get_Keys" inheritedFromTypeName="IDictionary" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.ListMapping`2.IsReadOnly">
      <summary>
            Not read only
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.BinaryTree`1">
      <summary>
            Binary tree
            </summary>
      <typeparam name="T">The type held by the nodes</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.#ctor(Utilities.DataTypes.TreeNode{`0})">
      <summary>
            Constructor
            </summary>
      <param name="Root">Root of the binary tree</param>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Add(`0)">
      <summary>
            Adds an item to a binary tree
            </summary>
      <param name="item">Item to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Clear">
      <summary>
            Clears all items from the tree
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Contains(`0)">
      <summary>
            Determines if the tree contains an item
            </summary>
      <param name="item">Item to check</param>
      <returns>True if it is, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the tree to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Remove(`0)">
      <summary>
            Removes an item from the tree
            </summary>
      <param name="item">Item to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Find(`0)">
      <summary>
            Finds a specific object
            </summary>
      <param name="item">The item to find</param>
      <returns>The node if it is found</returns>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Traversal(Utilities.DataTypes.TreeNode{`0})">
      <summary>
            Traverses the list
            </summary>
      <param name="Node">The node to start the search from</param>
      <returns>The individual items from the tree</returns>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.Insert(`0)">
      <summary>
            Inserts a value
            </summary>
      <param name="item">item to insert</param>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.ToString">
      <summary>
            Outputs the tree as a string
            </summary>
      <returns>The string representation of the tree</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.DataTypes.BinaryTree`1.op_Implicit(Utilities.DataTypes.BinaryTree{`0})~System.String">
      <summary>
            Converts the object to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.Root">
      <summary>
            The root value
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.NumberOfNodes">
      <summary>
            The number of nodes in the tree
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.IsEmpty">
      <summary>
            Is the tree empty
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.MinValue">
      <summary>
            Gets the minimum value of the tree
            </summary>
      <getter>
        <requires description="The tree is empty" exception="T:System.InvalidOperationException" csharp="!this.IsEmpty" vb="Not Me.IsEmpty">!this.IsEmpty</requires>
      </getter>
      <exception cref="T:System.InvalidOperationException">this.IsEmpty</exception>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.MaxValue">
      <summary>
            Gets the maximum value of the tree
            </summary>
      <getter>
        <requires description="The tree is empty" exception="T:System.InvalidOperationException" csharp="!this.IsEmpty" vb="Not Me.IsEmpty">!this.IsEmpty</requires>
      </getter>
      <exception cref="T:System.InvalidOperationException">this.IsEmpty</exception>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.Count">
      <summary>
            Number of items in the tree
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.DataTypes.BinaryTree`1.IsReadOnly">
      <summary>
            Is this read only?
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.TreeNode`1">
      <summary>
            Node class for the Binary tree
            </summary>
      <typeparam name="T">The value type</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.TreeNode`1.#ctor(`0,Utilities.DataTypes.TreeNode{`0},Utilities.DataTypes.TreeNode{`0},Utilities.DataTypes.TreeNode{`0})">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the node</param>
      <param name="Parent">Parent node</param>
      <param name="Left">Left node</param>
      <param name="Right">Right node</param>
    </member>
    <member name="M:Utilities.DataTypes.TreeNode`1.ToString">
      <summary>
            Returns the node as a string
            </summary>
      <returns>String representation of the node</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Value">
      <summary>
            Value of the node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Parent">
      <summary>
            Parent node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Left">
      <summary>
            Left node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Right">
      <summary>
            Right node
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.IsRoot">
      <summary>
            Is this the root
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.IsLeaf">
      <summary>
            Is this a leaf
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.TreeNode`1.Visited">
      <summary>
            Visited?
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.PriorityQueue`1">
      <summary>
            Helper class that implements a priority queue
            </summary>
      <typeparam name="T">The type of the values placed in the queue</typeparam>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Peek">
      <summary>
            Peek at the next thing in the queue
            </summary>
      <returns>The next item in queue or default(T) if it is empty</returns>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Add(System.Int32,System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds an item to the queue
            </summary>
      <param name="Priority">Priority</param>
      <param name="Value">Items to add</param>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Add(System.Collections.Generic.KeyValuePair{System.Int32,System.Collections.Generic.ICollection{`0}})">
      <summary>
            Adds an item to the queue
            </summary>
      <param name="item">Item to add</param>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Add(System.Int32,`0)">
      <summary>
            Adds an item to the queue
            </summary>
      <param name="Priority">Priority</param>
      <param name="Value">Item to add</param>
    </member>
    <member name="M:Utilities.DataTypes.PriorityQueue`1.Pop">
      <summary>
            Removes an item from the queue and returns it
            </summary>
      <returns>The next item in the queue</returns>
    </member>
    <member name="P:Utilities.DataTypes.PriorityQueue`1.HighestKey">
      <summary>
            Highest value key
            </summary>
    </member>
    <member name="T:Utilities.Environment.ArgsParser">
      <summary>
            Parses the args variables of an application
            </summary>
    </member>
    <member name="M:Utilities.Environment.ArgsParser.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="OptionStarter">The text to determine where an option starts</param>
      <requires description="OptionStarter" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(OptionStarter)" vb="Not IsNullOrEmpty(OptionStarter)">!string.IsNullOrEmpty(OptionStarter)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(OptionStarter)</exception>
    </member>
    <member name="M:Utilities.Environment.ArgsParser.Parse(System.String[])">
      <summary>
            Parses the args into individual options
            </summary>
      <param name="Args">Args to parse</param>
      <returns>A list of options</returns>
    </member>
    <member name="P:Utilities.Environment.ArgsParser.OptionRegex">
      <summary>
            Option regex
            </summary>
    </member>
    <member name="P:Utilities.Environment.ArgsParser.OptionStarter">
      <summary>
            String that starts an option
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.Application">
      <summary>
            Represents an application
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Application.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Application.Name">
      <summary>
            Application Name
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.Applications">
      <summary>
            Application list
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Applications.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Computer Name</param>
      <param name="Password">Password</param>
      <param name="UserName">User Name</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Applications.LoadApplications(System.String,System.String,System.String)">
      <summary>
            Loads applications
            </summary>
      <param name="Name">Computer name</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Applications.GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Applications.System#Collections#Generic#IEnumerable{Utilities#Environment#DataTypes#Application}#GetEnumerator">
      <summary>
            Gets the enumerator
            </summary>
      <returns>The enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Applications.ApplicationList">
      <summary>
            Application list
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.BIOS">
      <summary>
            Represents BIOS information
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.BIOS.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Computer Name</param>
      <param name="Password">Password</param>
      <param name="UserName">User Name</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.BIOS.LoadBIOS(System.String,System.String,System.String)">
      <summary>
            Loads the BIOS info
            </summary>
      <param name="Name">Computer name</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="P:Utilities.Environment.DataTypes.BIOS.SerialNumber">
      <summary>
            Serial Number
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.Computer">
      <summary>
            Represents a computer
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Computer.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Computer Name</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.Name">
      <summary>
            Computer Name
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.UserName">
      <summary>
            User Name
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.Password">
      <summary>
            Password
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.BIOS">
      <summary>
            BIOS info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.BIOS_">
      <summary>
            BIOS info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.Applications">
      <summary>
            Application info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.Applications_">
      <summary>
            Applications
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.Network">
      <summary>
            Network info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.Network_">
      <summary>
            Network info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.OperatingSystem">
      <summary>
            Operating system info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.OperatingSystem_">
      <summary>
            Operating system info
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.LatestUsers">
      <summary>
            Holds a list of users that have logged into the machine recently
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Computer.User_">
      <summary>
            User info
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.Files">
      <summary>
            Helper class for searching for files (will be modified later)
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Files.GetFilesWithExtension(System.String,System.String,System.String,System.String)">
      <summary>
            Gets a list of files on the machine with a specific extension
            </summary>
      <param name="Computer">Computer to search</param>
      <param name="UserName">User name (if not local)</param>
      <param name="Password">Password (if not local)</param>
      <param name="Extension">File extension to look for</param>
      <returns>List of files that are found to have the specified extension</returns>
      <requires description="Computer" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Computer)" vb="Not IsNullOrEmpty(Computer)">!string.IsNullOrEmpty(Computer)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Computer)</exception>
      <requires description="Extension" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Extension)" vb="Not IsNullOrEmpty(Extension)">!string.IsNullOrEmpty(Extension)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Extension)</exception>
    </member>
    <member name="T:Utilities.Environment.DataTypes.Network">
      <summary>
            Represents network info
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Network.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Computer name</param>
      <param name="Password">Password</param>
      <param name="UserName">Username</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Network.GetNetworkInfo(System.String,System.String,System.String)">
      <summary>
            Gets the network info
            </summary>
      <param name="Name">Computer name</param>
      <param name="Password">Password</param>
      <param name="UserName">Username</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.Network.GetNetworkAdapterInfo(System.String,System.String,System.String)">
      <summary>
            Gets the network adapter info
            </summary>
      <param name="Name">Computer name</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Network.NetworkAddresses">
      <summary>
            Network addresses (IP Addresses, etc.)
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.Network.MACAddresses">
      <summary>
            MAC Address 
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.NetworkAdapter">
      <summary>
            Holds information for a network adapter
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.NetworkAdapter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.NetworkAdapter.Description">
      <summary>
            Description of the adapter
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.NetworkAdapter.MACAddress">
      <summary>
            MAC address
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.NetworkAddress">
      <summary>
            Holds an address's info
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.NetworkAddress.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.NetworkAddress.Type">
      <summary>
            Type of address
            </summary>
    </member>
    <member name="P:Utilities.Environment.DataTypes.NetworkAddress.Address">
      <summary>
            Actual address
            </summary>
    </member>
    <member name="T:Utilities.Environment.DataTypes.OperatingSystem">
      <summary>
            Holds operating system info
            </summary>
    </member>
    <member name="M:Utilities.Environment.DataTypes.OperatingSystem.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Computer name</param>
      <param name="Password">Password</param>
      <param name="UserName">Username</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Environment.DataTypes.OperatingSystem.GetOperatingSystemInfo(System.String,System.String,System.String)">
      <summary>
            Gets operating system info
            </summary>
      <param name="Name">Computer name</param>
      <param name="UserName">User name</param>
      <param name="Password">Password</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="P:Utilities.Environment.DataTypes.OperatingSystem.LastBootUpTime">
      <summary>
            Last bootup time
            </summary>
    </member>
    <member name="T:Utilities.Environment.Option">
      <summary>
            Contains an individual option
            </summary>
    </member>
    <member name="M:Utilities.Environment.Option.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Text">Option text</param>
      <param name="OptionStarter">Starter text for an option ("/", "-", etc.)</param>
      <requires description="Text" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Text)" vb="Not IsNullOrEmpty(Text)">!string.IsNullOrEmpty(Text)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Text)</exception>
      <requires description="OptionStarter" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(OptionStarter)" vb="Not IsNullOrEmpty(OptionStarter)">!string.IsNullOrEmpty(OptionStarter)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(OptionStarter)</exception>
    </member>
    <member name="M:Utilities.Environment.Option.ToString">
      <summary>
            Converts the options into a string
            </summary>
      <returns>The string representation of the option</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Environment.Option.Command">
      <summary>
            Command string
            </summary>
    </member>
    <member name="P:Utilities.Environment.Option.Parameters">
      <summary>
            List of parameters found
            </summary>
    </member>
    <member name="T:Utilities.Environment.WMI">
      <summary>
            WMI class helper
            </summary>
    </member>
    <member name="M:Utilities.Environment.WMI.GetComputerInfo(System.String,System.String,System.String)">
      <summary>
            Gets a computer's info using WMI
            </summary>
      <param name="ComputerName">Computer name</param>
      <param name="UserName">User name (optional)</param>
      <param name="Password">Password (optional)</param>
      <returns>The computer's information</returns>
      <requires description="ComputerName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(ComputerName)" vb="Not IsNullOrEmpty(ComputerName)">!string.IsNullOrEmpty(ComputerName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(ComputerName)</exception>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.BaseEventArgs">
      <summary>
            Base event args for the events used in the system
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.EventArgs.BaseEventArgs.Stop">
      <summary>
            Should the event be stopped?
            </summary>
    </member>
    <member name="P:Utilities.DataTypes.EventArgs.BaseEventArgs.Content">
      <summary>
            Content of the event
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.SavedEventArgs">
      <summary>
            Saved event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.SavingEventArgs">
      <summary>
            Saving event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.DeletedEventArgs">
      <summary>
            Deleted event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.DeletingEventArgs">
      <summary>
            Deleting event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.ChangedEventArgs">
      <summary>
            Changed event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.LoadedEventArgs">
      <summary>
            Loaded event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.LoadingEventArgs">
      <summary>
            Loading event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.OnStartEventArgs">
      <summary>
            On start event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.OnEndEventArgs">
      <summary>
            On end event args
            </summary>
    </member>
    <member name="T:Utilities.DataTypes.EventArgs.OnErrorEventArgs">
      <summary>
            On error event args
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Author">
      <summary>
            Individual author
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Author.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Author.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element containing the author info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Author.ToString">
      <summary>
            Converts the author to a string
            </summary>
      <returns>The author as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Author.ID">
      <summary>
            ID of the author
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Author.Email">
      <summary>
            Email address of the author
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Author.Title">
      <summary>
            The person's title (most likely their name)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Author.REF">
      <summary>
            Determines if this should be a reference to an author
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Author.DateCreated">
      <summary>
            Date created
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Author.DateModified">
      <summary>
            Date modified
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Authors">
      <summary>
            Authors list
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Authors.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Authors.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing the authors information</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Authors.ToString">
      <summary>
            Converts the authors to a string
            </summary>
      <returns>The authors as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Authors.AuthorList">
      <summary>
            List of authors
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Authors.Item(System.Int32)">
      <summary>
            Gets a specific author
            </summary>
      <param name="index">Index within the list</param>
      <returns>The author specified</returns>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Authors.Item(System.String)">
      <summary>
            Gets a specific author
            </summary>
      <param name="index">Author's ID that you want</param>
      <returns>The author specified</returns>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.BlogML">
      <summary>
            BlogML class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.BlogML.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.BlogML.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Location">Location of the XML file</param>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.BlogML.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.BlogML.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.Title">
      <summary>
            Title of the blog
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.SubTitle">
      <summary>
            Sub title of the blog
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.Authors">
      <summary>
            Authors of the blog
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.Categories">
      <summary>
            Categories of the blog (doesn't include tags)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.Posts">
      <summary>
            Posts of the blog
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.DateCreated">
      <summary>
            Date created
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.BlogML.RootURL">
      <summary>
            Root URL
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Categories">
      <summary>
            Categories
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Categories.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Categories.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Categories element</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Categories.ToString">
      <summary>
            Converts the categories to a formatted string
            </summary>
      <returns>The formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Categories.CategoryList">
      <summary>
            Categories list
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Categories.Item(System.String)">
      <summary>
            Gets a specified category
            </summary>
      <param name="index">The ID of the category</param>
      <returns>The category specified</returns>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Category">
      <summary>
            Category class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Category.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Category.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element with the category info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Category.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Category.ID">
      <summary>
            ID of the category
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Category.Title">
      <summary>
            Title of the cateogry (its name)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Category.REF">
      <summary>
            Determines if this is a reference to a category
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Category.ParentREF">
      <summary>
            Parent ref
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Category.DateCreated">
      <summary>
            Date createed
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Category.DateModified">
      <summary>
            Date modified
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Comment">
      <summary>
            Comment class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Comment.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Comment.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing the post info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Comment.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.Title">
      <summary>
            Title of the comment
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.Content">
      <summary>
            Actual content of the comment
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.DateCreated">
      <summary>
            Date created
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.Approved">
      <summary>
            Determines if the comment is approved
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.UserName">
      <summary>
            User name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.UserEmail">
      <summary>
            User email
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.UserIP">
      <summary>
            User IP
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.UserURL">
      <summary>
            User URL
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comment.ID">
      <summary>
            ID
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Comments">
      <summary>
            Comments class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Comments.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Comments.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing post info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Comments.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Comments.CommentList">
      <summary>
            List of comments
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Post">
      <summary>
            Post class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Post.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Post.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing the post info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Post.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.ID">
      <summary>
            ID of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.PostURL">
      <summary>
            URL of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Title">
      <summary>
            Title of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Content">
      <summary>
            Content of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Excerpt">
      <summary>
            Excerpt of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.PostName">
      <summary>
            Name of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.DateCreated">
      <summary>
            Date the post was created
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.DateModified">
      <summary>
            Date the post was modified
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Authors">
      <summary>
            Authors of the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Categories">
      <summary>
            Categories associated with the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Tags">
      <summary>
            Tags associated with the post
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Post.Comments">
      <summary>
            Comments associated with the post
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Posts">
      <summary>
            Posts class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Posts.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Posts.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing post info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Posts.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Posts.PostList">
      <summary>
            List of posts
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Tag">
      <summary>
            Tag class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Tag.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Tag.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing the tag info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Tag.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Tag.REF">
      <summary>
            Gets the REF info for the tag (usually just the tag's name)
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.BlogML.Tags">
      <summary>
            Tags information
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Tags.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Tags.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing tags info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.BlogML.Tags.ToString">
      <summary>
            Converts the object to a string
            </summary>
      <returns>The object as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Tags.TagList">
      <summary>
            Tags list
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.BlogML.Tags.Item(System.Int32)">
      <summary>
            gets a specific tag
            </summary>
      <param name="index">Index of the tag</param>
      <returns>A specific tag</returns>
    </member>
    <member name="T:Utilities.AI.NaiveBayes`1">
      <summary>
            Naive bayes classifier
            </summary>
      <typeparam name="T">The type of the individual tokens</typeparam>
    </member>
    <member name="M:Utilities.AI.NaiveBayes`1.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="ATokenWeight">Weight of each token in set A</param>
      <param name="BTokenWeight">Weight of each token in set B</param>
      <param name="MaxInterestingTokenCount">After sorting, this is the maximum number of tokens that are picked to figure out the final probability</param>
      <param name="MaxTokenProbability">Maximum token probability</param>
      <param name="MinTokenProbability">Minimum token probability</param>
      <param name="MinCountForInclusion">Minimum number of times a token needs to be present for it to be included</param>
    </member>
    <member name="M:Utilities.AI.NaiveBayes`1.LoadTokens(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Loads a set of tokens
            </summary>
      <param name="SetATokens">Set A</param>
      <param name="SetBTokens">Set B</param>
      <requires description="SetATokens" exception="T:System.ArgumentNullException" csharp="SetATokens != null" vb="SetATokens &lt;&gt; Nothing">SetATokens != null</requires>
      <exception cref="T:System.ArgumentNullException">SetATokens == null</exception>
      <requires description="SetBTokens" exception="T:System.ArgumentNullException" csharp="SetBTokens != null" vb="SetBTokens &lt;&gt; Nothing">SetBTokens != null</requires>
      <exception cref="T:System.ArgumentNullException">SetBTokens == null</exception>
    </member>
    <member name="M:Utilities.AI.NaiveBayes`1.CalculateProbabilityOfTokens(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Calculates the probability of the list of tokens being in set A
            </summary>
      <param name="Items">List of items</param>
      <returns>The probability that the tokens are from set A</returns>
      <requires description="Items" exception="T:System.ArgumentNullException" csharp="Items != null" vb="Items &lt;&gt; Nothing">Items != null</requires>
      <exception cref="T:System.ArgumentNullException">Items == null</exception>
      <requires description="Probabilities has not been initialized" exception="T:System.InvalidOperationException" csharp="this.Probabilities != null" vb="Me.Probabilities &lt;&gt; Nothing">this.Probabilities != null</requires>
      <exception cref="T:System.InvalidOperationException">this.Probabilities == null</exception>
    </member>
    <member name="M:Utilities.AI.NaiveBayes`1.CalculateProbabilityOfToken(`0)">
      <summary>
            Calculates a single items probability of being in set A
            </summary>
      <param name="Item">Item to calculate</param>
      <returns>The probability that the token is from set A</returns>
      <requires description="Probabilities have not been initialized" exception="T:System.ArgumentNullException" csharp="this.SetA != default(Utilities.DataTypes.Bag&lt;T&gt;) &amp;&amp; this.SetB != null" vb="Me.SetA &lt;&gt; Nothing AndAlso Me.SetB &lt;&gt; Nothing">this.SetA != default(Utilities.DataTypes.Bag&lt;T&gt;) &amp;&amp; this.SetB != null</requires>
      <exception cref="T:System.ArgumentNullException">this.SetA == default(Utilities.DataTypes.Bag&lt;T&gt;) ? !false : this.SetB == null</exception>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.SetA">
      <summary>
            Set A
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.SetB">
      <summary>
            Set B
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.Total">
      <summary>
            Total number of tokens
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.TotalA">
      <summary>
            Total number of tokens in set A
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.TotalB">
      <summary>
            Total number of tokens in set B
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.Probabilities">
      <summary>
            Dictionary containing probabilities
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.ATokenWeight">
      <summary>
            Weight to give to the probabilities in set A
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.BTokenWeight">
      <summary>
            Weight to give the probabilities in set B
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.MinCountForInclusion">
      <summary>
            Minimum count that an item needs to be found to be included in final probability
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.MinTokenProbability">
      <summary>
            Minimum token probability (if less than this amount, it becomes this amount)
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.MaxTokenProbability">
      <summary>
            Maximum token probability (if greater than this amount, it becomes this amount)
            </summary>
    </member>
    <member name="P:Utilities.AI.NaiveBayes`1.MaxInterestingTokenCount">
      <summary>
            After sorting, this is the maximum number of tokens that are picked to figure out the final probability
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Delimited.Cell">
      <summary>
            Cell within a delimited file
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Cell.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Cell.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Content">Value within the cell</param>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Cell.op_Implicit(Utilities.FileFormats.Delimited.Cell)~System.String">
      <summary>
            Converts the cell to a string
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The value as a string</returns>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Cell.op_Implicit(System.String)~Utilities.FileFormats.Delimited.Cell">
      <summary>
            Converts the string to a cell
            </summary>
      <param name="Value">Value to convert</param>
      <returns>The string as a cell</returns>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Cell.ToString">
      <summary>
            To string function
            </summary>
      <returns>The value of the cell</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Cell.Value">
      <summary>
            Value within the cell
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Delimited.Row">
      <summary>
            Individual row within a delimited file
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Delimiter">Delimiter to parse the individual cells</param>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Content">Content of the row</param>
      <param name="Delimiter">Delimiter to parse the individual cells</param>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.ToString">
      <summary>
            To string function
            </summary>
      <returns>The content of the row in string form</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the delimited file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.Add(Utilities.FileFormats.Delimited.Cell)">
      <summary>
            Adds a Cell to the file
            </summary>
      <param name="item">Cell to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.Clear">
      <summary>
            Clears the file
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.Contains(Utilities.FileFormats.Delimited.Cell)">
      <summary>
            Determines if the file contains a Cell
            </summary>
      <param name="item">Cell to check for</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.CopyTo(Utilities.FileFormats.Delimited.Cell[],System.Int32)">
      <summary>
            Copies the delimited file to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.Remove(Utilities.FileFormats.Delimited.Cell)">
      <summary>
            Removes a Cell from the file
            </summary>
      <param name="item">Cell to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.IndexOf(Utilities.FileFormats.Delimited.Cell)">
      <summary>
            Index of a specific Cell
            </summary>
      <param name="item">Cell to search for</param>
      <returns>The index of a specific Cell</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.Insert(System.Int32,Utilities.FileFormats.Delimited.Cell)">
      <summary>
            Inserts a Cell at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Cell to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.FileFormats.Delimited.Row.RemoveAt(System.Int32)">
      <summary>
            Removes a Cell at a specific index
            </summary>
      <param name="index">Index of the Cell to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Row.Cells">
      <summary>
            Cells within the row
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Row.Item(System.Int32)">
      <summary>
            Returns a cell within the row
            </summary>
      <param name="Position">The position of the cell</param>
      <returns>The specified cell</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Row.Delimiter">
      <summary>
            Delimiter used
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Row.Count">
      <summary>
            Number of Cells
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.FileFormats.Delimited.Row.IsReadOnly">
      <summary>
            Is the file read only
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.FixedLength.BaseClasses.FieldBase`1">
      <summary>
            Field base class
            </summary>
      <typeparam name="T">Field type</typeparam>
    </member>
    <member name="T:Utilities.FileFormats.FixedLength.Interfaces.IField`1">
      <summary>
            Field interface
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.Interfaces.IField`1.Parse(System.String,System.Int32,System.String)">
      <summary>
            Parses the string into fields
            </summary>
      <param name="Value">The string value</param>
      <param name="Length">Max length of the value</param>
      <param name="FillerCharacter">Filler character used to fill
            the rest of the field</param>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.Interfaces.IField`1.Length">
      <summary>
            Field length
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.Interfaces.IField`1.Value">
      <summary>
            Field value
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FieldBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FieldBase`1.Parse(System.String,System.Int32,System.String)">
      <summary>
            Parses the field
            </summary>
      <param name="Value">Value to place in the field</param>
      <param name="Length">Length of the field</param>
      <param name="FillerCharacter">Filler character to use</param>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FieldBase`1.ToString">
      <summary>
            Converts the field to a string
            </summary>
      <returns>The field as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.FieldBase`1.Length">
      <summary>
            Length of the field
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.FieldBase`1.Value">
      <summary>
            Value of the field
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2">
      <summary>
            Parses and creates a fixed length file
            </summary>
      <typeparam name="ObjectType">Object Type</typeparam>
      <typeparam name="FieldType">Field Type</typeparam>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.Parse(System.String,System.Int32)">
      <summary>
            Parses the string into fields
            </summary>
      <param name="Value">The string value</param>
      <param name="Length">Max length for the record</param>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.ToString">
      <summary>
            Converts the file to a string
            </summary>
      <returns>The file as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.FixedLengthBase`2.LoadFromData(System.String)">
      <summary>
            Loads the data into the object
            </summary>
      <param name="Data">The data to load</param>
    </member>
    <member name="T:Utilities.FileFormats.FixedLength.Interfaces.IRecord`1">
      <summary>
            Record interface
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.Interfaces.IRecord`1.Parse(System.String,System.Int32)">
      <summary>
            Parses the string into fields
            </summary>
      <param name="Value">The string value</param>
      <param name="Length">Max length of the value</param>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.Interfaces.IRecord`1.Length">
      <summary>
            Length of the record
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1">
      <summary>
            Record base class
            </summary>
      <typeparam name="T">Field type</typeparam>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Parse(System.String,System.Int32)">
      <summary>
            Parses the record
            </summary>
      <param name="Value">Value</param>
      <param name="Length">Length of the record</param>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.ToString">
      <summary>
            Converts the record to a string
            </summary>
      <returns>The record as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.GetEnumerator">
      <summary>
            Gets the enumerator for the file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Gets the enumerator for the file
            </summary>
      <returns>The enumerator for this file</returns>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Add(Utilities.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Adds a Field to the file
            </summary>
      <param name="item">Field to add</param>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Add(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &gt;= old(this.Count)" vb="Me.Count &gt;= old(Me.Count)">this.Count &gt;= old(this.Count)</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Clear">
      <summary>
            Clears the file
            </summary>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Clear" inheritedFromTypeName="ICollection" csharp="this.Count == 0" vb="Me.Count = 0">this.Count == 0</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Contains(Utilities.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Determines if the file contains a Field
            </summary>
      <param name="item">Field to check for</param>
      <returns>True if it does, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Contains(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt; 0" vb="result Implies Me.Count &gt; 0">!result || this.Count &gt; 0</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.CopyTo(Utilities.FileFormats.FixedLength.Interfaces.IField{`0}[],System.Int32)">
      <summary>
            Copies the delimited file to an array
            </summary>
      <param name="array">Array to copy to</param>
      <param name="arrayIndex">Index to start at</param>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="array != null" vb="array &lt;&gt; Nothing">array != null</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &gt;= 0" vb="arrayIndex &gt;= 0">arrayIndex &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" inheritedFromTypeName="ICollection" csharp="arrayIndex &lt;= array.Length - this.Count" vb="arrayIndex &lt;= array.Length - Me.Count">arrayIndex &lt;= array.Length - this.Count</requires>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Remove(Utilities.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Removes a Field from the file
            </summary>
      <param name="item">Field to remove</param>
      <returns>True if it is removed, false otherwise</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="this.Count &lt;= old(this.Count)" vb="Me.Count &lt;= old(Me.Count)">this.Count &lt;= old(this.Count)</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.Remove(`0)" inheritedFromTypeName="ICollection" csharp="result ⇒ this.Count &gt;= old(this.Count - 1)" vb="result Implies Me.Count &gt;= old(Me.Count - 1)">!result || this.Count &gt;= old(this.Count - 1)</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.IndexOf(Utilities.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Index of a specific Field
            </summary>
      <param name="item">Field to search for</param>
      <returns>The index of a specific Field</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &gt;= -1" vb="result &gt;= -1">result &gt;= -1</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.IndexOf(`0)" inheritedFromTypeName="IList" csharp="result &lt; this.Count" vb="result &lt; Me.Count">result &lt; this.Count</ensures>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Insert(System.Int32,Utilities.FileFormats.FixedLength.Interfaces.IField{`0})">
      <summary>
            Inserts a Field at a specific index
            </summary>
      <param name="index">Index to insert at</param>
      <param name="item">Field to insert</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt;= this.Count" vb="index &lt;= Me.Count">index &lt;= this.Count</requires>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.RemoveAt(System.Int32)">
      <summary>
            Removes a Field at a specific index
            </summary>
      <param name="index">Index of the Field to remove</param>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
      <requires inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      <ensures inheritedFrom="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)" inheritedFromTypeName="IList" csharp="this.Count == old(this.Count) - 1" vb="Me.Count = old(Me.Count) - 1">this.Count == old(this.Count) - 1</ensures>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Length">
      <summary>
            Length
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Fields">
      <summary>
            The list of fields
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Item(System.Int32)">
      <summary>
            Individual records
            </summary>
      <param name="Position">The record that you want to get</param>
      <returns>The record requested</returns>
      <getter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.get_Item(System.Int32)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &gt;= 0" vb="index &gt;= 0">index &gt;= 0</requires>
        <requires inheritedFrom="M:System.Collections.Generic.IList`1.set_Item(System.Int32,`0)" inheritedFromTypeName="IList" csharp="index &lt; this.Count" vb="index &lt; Me.Count">index &lt; this.Count</requires>
      </setter>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.Count">
      <summary>
            Number of Fields
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.Collections.Generic.ICollection`1.get_Count" inheritedFromTypeName="ICollection" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.FileFormats.FixedLength.BaseClasses.RecordBase`1.IsReadOnly">
      <summary>
            Is the file read only
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.FixedLength.StringField">
      <summary>
            Field containing string info (used in text based files)
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.StringField.#ctor(System.String,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to place in the field</param>
      <param name="Length">Max length of the value</param>
    </member>
    <member name="M:Utilities.FileFormats.FixedLength.StringField.Parse(System.String,System.Int32,System.String)">
      <summary>
            Parses the string field
            </summary>
      <param name="Value">Value</param>
      <param name="Length">Max length allowed</param>
      <param name="FillerCharacter">Filler character</param>
    </member>
    <member name="T:Utilities.FileFormats.PipeDelimited.PipeDelimited">
      <summary>
            Pipe delimited loader
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.PipeDelimited.PipeDelimited.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.PipeDelimited.PipeDelimited.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">File content</param>
    </member>
    <member name="P:Utilities.FileFormats.PipeDelimited.PipeDelimited.Delimiter">
      <summary>
            Delimiter used
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.GUID">
      <summary>
            GUID info holder
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.GUID.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.GUID.#ctor(System.Xml.XmlElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element holding info for the enclosure</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
      <requires description="Element is not a guid" exception="T:System.ArgumentException" csharp="Element.Name.Equals(&quot;guid&quot;, 1)" vb="Element.Name.Equals(&quot;guid&quot;, 1)">Element.Name.Equals("guid", 1)</requires>
      <exception cref="T:System.ArgumentException">!Element.Name.Equals("guid", 1)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.GUID.ToString">
      <summary>
            to string item. Used for outputting the item to RSS.
            </summary>
      <returns>A string formatted for RSS output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.GUID.PermaLink">
      <summary>
            Is this a perma link?
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.GUID.GUIDText">
      <summary>
            GUID Text
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.Thumbnail">
      <summary>
            Thumbnail info holder
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Thumbnail.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Thumbnail.#ctor(System.Xml.XmlElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element holding info for the enclosure</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
      <requires description="Element is not a thumbnail" exception="T:System.ArgumentException" csharp="Element.Name.Equals(&quot;media:thumbnail&quot;, 1)" vb="Element.Name.Equals(&quot;media:thumbnail&quot;, 1)">Element.Name.Equals("media:thumbnail", 1)</requires>
      <exception cref="T:System.ArgumentException">!Element.Name.Equals("media:thumbnail", 1)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Thumbnail.ToString">
      <summary>
            to string item. Used for outputting the item to RSS.
            </summary>
      <returns>A string formatted for RSS output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Thumbnail.Url">
      <summary>
            Location of the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Thumbnail.Width">
      <summary>
            Image width
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Thumbnail.Height">
      <summary>
            Image height
            </summary>
    </member>
    <member name="T:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions">
      <summary>
            Extension methods for <see cref="T:System.IO.DirectoryInfo" /></summary>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.CopyTo(System.IO.DirectoryInfo,System.String,System.Boolean,Utilities.IO.ExtensionMethods.Enums.CopyOptions)">
      <summary>
            Copies a directory to another location
            </summary>
      <param name="Source">Source directory</param>
      <param name="Destination">Destination directory</param>
      <param name="Recursive">Should the copy be recursive</param>
      <param name="Options">Options used in copying</param>
      <returns>The DirectoryInfo for the destination info</returns>
      <requires description="Source" exception="T:System.ArgumentNullException" csharp="Source != null" vb="Source &lt;&gt; Nothing">Source != null</requires>
      <exception cref="T:System.ArgumentNullException">Source == null</exception>
      <requires description="Source directory not found." exception="T:System.IO.DirectoryNotFoundException" csharp="Source.Exists" vb="Source.Exists">Source.Exists</requires>
      <exception cref="T:System.IO.DirectoryNotFoundException">!Source.Exists</exception>
      <requires description="Destination" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Destination)" vb="Not IsNullOrEmpty(Destination)">!string.IsNullOrEmpty(Destination)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Destination)</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DeleteAll(System.IO.DirectoryInfo)">
      <summary>
            Deletes directory and all content found within it
            </summary>
      <param name="Info">Directory info object</param>
      <requires description="Info" exception="T:System.ArgumentNullException" csharp="Info != null" vb="Info &lt;&gt; Nothing">Info != null</requires>
      <exception cref="T:System.ArgumentNullException">Info == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DeleteDirectoriesNewerThan(System.IO.DirectoryInfo,System.DateTime,System.Boolean)">
      <summary>
            Deletes directories newer than the specified date
            </summary>
      <param name="Directory">Directory to look within</param>
      <param name="CompareDate">The date to compare to</param>
      <param name="Recursive">Is this a recursive call</param>
      <returns>Returns the directory object</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass5().CompareDate = CompareDate;&#xD;&#xA;    }&#xD;&#xA;    return Directory != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass5().CompareDate = CompareDate&#xD;&#xA;    return Directory &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass5().CompareDate = CompareDate;
    }
    return Directory != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass5().CompareDate = CompareDate);
    }
    return (Directory != null); })()</exception>
      <requires description="Directory" exception="T:System.IO.DirectoryNotFoundException" csharp="Directory.Exists" vb="Directory.Exists">Directory.Exists</requires>
      <exception cref="T:System.IO.DirectoryNotFoundException">!Directory.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DeleteDirectoriesOlderThan(System.IO.DirectoryInfo,System.DateTime,System.Boolean)">
      <summary>
            Deletes directories newer than the specified date
            </summary>
      <param name="Directory">Directory to look within</param>
      <param name="CompareDate">The date to compare to</param>
      <param name="Recursive">Is this a recursive call</param>
      <returns>Returns the directory object</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClassa().CompareDate = CompareDate;&#xD;&#xA;    }&#xD;&#xA;    return Directory != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClassa().CompareDate = CompareDate&#xD;&#xA;    return Directory &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClassa().CompareDate = CompareDate;
    }
    return Directory != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClassa().CompareDate = CompareDate);
    }
    return (Directory != null); })()</exception>
      <requires description="Directory" exception="T:System.IO.DirectoryNotFoundException" csharp="Directory.Exists" vb="Directory.Exists">Directory.Exists</requires>
      <exception cref="T:System.IO.DirectoryNotFoundException">!Directory.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DeleteFiles(System.IO.DirectoryInfo,System.Boolean)">
      <summary>
            Deletes files from a directory
            </summary>
      <param name="Directory">Directory to delete the files from</param>
      <param name="Recursive">Should this be recursive?</param>
      <returns>The directory that is sent in</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="Directory != null" vb="Directory &lt;&gt; Nothing">Directory != null</requires>
      <exception cref="T:System.ArgumentNullException">Directory == null</exception>
      <requires description="Directory" exception="T:System.IO.DirectoryNotFoundException" csharp="Directory.Exists" vb="Directory.Exists">Directory.Exists</requires>
      <exception cref="T:System.IO.DirectoryNotFoundException">!Directory.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DeleteFilesNewerThan(System.IO.DirectoryInfo,System.DateTime,System.Boolean)">
      <summary>
            Deletes files newer than the specified date
            </summary>
      <param name="Directory">Directory to look within</param>
      <param name="CompareDate">The date to compare to</param>
      <param name="Recursive">Is this a recursive call</param>
      <returns>Returns the directory object</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass11().CompareDate = CompareDate;&#xD;&#xA;    }&#xD;&#xA;    return Directory != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass11().CompareDate = CompareDate&#xD;&#xA;    return Directory &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass11().CompareDate = CompareDate;
    }
    return Directory != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass11().CompareDate = CompareDate);
    }
    return (Directory != null); })()</exception>
      <requires description="Directory" exception="T:System.IO.DirectoryNotFoundException" csharp="Directory.Exists" vb="Directory.Exists">Directory.Exists</requires>
      <exception cref="T:System.IO.DirectoryNotFoundException">!Directory.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DeleteFilesOlderThan(System.IO.DirectoryInfo,System.DateTime,System.Boolean)">
      <summary>
            Deletes files older than the specified date
            </summary>
      <param name="Directory">Directory to look within</param>
      <param name="CompareDate">The date to compare to</param>
      <param name="Recursive">Is this a recursive call</param>
      <returns>Returns the directory object</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass16().CompareDate = CompareDate;&#xD;&#xA;    }&#xD;&#xA;    return Directory != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass16().CompareDate = CompareDate&#xD;&#xA;    return Directory &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass16().CompareDate = CompareDate;
    }
    return Directory != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass16().CompareDate = CompareDate);
    }
    return (Directory != null); })()</exception>
      <requires description="Directory" exception="T:System.IO.DirectoryNotFoundException" csharp="Directory.Exists" vb="Directory.Exists">Directory.Exists</requires>
      <exception cref="T:System.IO.DirectoryNotFoundException">!Directory.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.DriveInfo(System.IO.DirectoryInfo)">
      <summary>
            Gets the drive information for a directory
            </summary>
      <param name="Directory">The directory to get the drive info of</param>
      <returns>The drive info connected to the directory</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="Directory != null" vb="Directory &lt;&gt; Nothing">Directory != null</requires>
      <exception cref="T:System.ArgumentNullException">Directory == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.EnumerateFiles(System.IO.DirectoryInfo,System.Collections.Generic.IEnumerable{System.String},System.IO.SearchOption)">
      <summary>
            Enumerates the files within a directory
            </summary>
      <param name="Directory">Directory to search in</param>
      <param name="SearchPatterns">Patterns to search for</param>
      <param name="Options">Search options</param>
      <returns>The enumerated files from the directory</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.Size(System.IO.DirectoryInfo,System.String,System.Boolean)">
      <summary>
            Gets the size of all files within a directory
            </summary>
      <param name="Directory">Directory</param>
      <param name="SearchPattern">Search pattern used to tell what files to include (defaults to all)</param>
      <param name="Recursive">determines if this is a recursive call or not</param>
      <returns>The directory size</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="Directory != null" vb="Directory &lt;&gt; Nothing">Directory != null</requires>
      <exception cref="T:System.ArgumentNullException">Directory == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.SetAttributes(System.IO.DirectoryInfo,System.IO.FileAttributes,System.Boolean)">
      <summary>
            Sets a directory's attributes
            </summary>
      <param name="Directory">Directory</param>
      <param name="Attributes">Attributes to set</param>
      <param name="Recursive">Determines if this is a recursive call</param>
      <returns>The directory object</returns>
      <requires description="Directory" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass1c().Attributes = Attributes;&#xD;&#xA;    }&#xD;&#xA;    return Directory != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass1c().Attributes = Attributes&#xD;&#xA;    return Directory &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass1c().Attributes = Attributes;
    }
    return Directory != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.IO.ExtensionMethods.DirectoryInfoExtensions.&lt;&gt;c__DisplayClass1c().Attributes = Attributes);
    }
    return (Directory != null); })()</exception>
    </member>
    <member name="T:Utilities.IO.ExtensionMethods.Enums.CopyOptions">
      <summary>
            Options used in directory copying
            </summary>
    </member>
    <member name="F:Utilities.IO.ExtensionMethods.Enums.CopyOptions.CopyIfNewer">
      <summary>
            Copy if newer than the DateTime specified
            </summary>
    </member>
    <member name="F:Utilities.IO.ExtensionMethods.Enums.CopyOptions.CopyAlways">
      <summary>
            Copy always
            </summary>
    </member>
    <member name="F:Utilities.IO.ExtensionMethods.Enums.CopyOptions.DoNotOverwrite">
      <summary>
            Do not overwrite a file
            </summary>
    </member>
    <member name="T:Utilities.IO.ExtensionMethods.FileInfoExtensions">
      <summary>
            Extension methods for <see cref="T:System.IO.FileInfo" /></summary>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.CompareTo(System.IO.FileInfo,System.IO.FileInfo)">
      <summary>
            Compares two files against one another
            </summary>
      <param name="File1">First file</param>
      <param name="File2">Second file</param>
      <returns>True if the content is the same, false otherwise</returns>
      <requires description="File1" exception="T:System.ArgumentNullException" csharp="File1 != default(System.IO.FileInfo) &amp;&amp; File1.Exists" vb="File1 &lt;&gt; Nothing AndAlso File1.Exists">File1 != default(System.IO.FileInfo) &amp;&amp; File1.Exists</requires>
      <exception cref="T:System.ArgumentNullException">File1 == default(System.IO.FileInfo) ? !false : !File1.Exists</exception>
      <requires description="File2" exception="T:System.ArgumentNullException" csharp="File2 != default(System.IO.FileInfo) &amp;&amp; File2.Exists" vb="File2 &lt;&gt; Nothing AndAlso File2.Exists">File2 != default(System.IO.FileInfo) &amp;&amp; File2.Exists</requires>
      <exception cref="T:System.ArgumentNullException">File2 == default(System.IO.FileInfo) ? !false : !File2.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.DriveInfo(System.IO.FileInfo)">
      <summary>
            Gets the drive information for a file
            </summary>
      <param name="File">The file to get the drive info of</param>
      <returns>The drive info connected to the file</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Read(System.IO.FileInfo)">
      <summary>
            Reads a file to the end as a string
            </summary>
      <param name="File">File to read</param>
      <returns>A string containing the contents of the file</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Read(System.String)">
      <summary>
            Reads a file to the end as a string
            </summary>
      <param name="Location">File to read</param>
      <returns>A string containing the contents of the file</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.ReadBinary(System.IO.FileInfo)">
      <summary>
            Reads a file to the end and returns a binary array
            </summary>
      <param name="File">File to open</param>
      <returns>A binary array containing the contents of the file</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.ReadBinary(System.String)">
      <summary>
            Reads a file to the end and returns a binary array
            </summary>
      <param name="Location">File to open</param>
      <returns>A binary array containing the contents of the file</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Execute(System.IO.FileInfo,System.String,System.String,System.String,System.String,System.Diagnostics.ProcessWindowStyle,System.String)">
      <summary>
            Executes the file
            </summary>
      <param name="File">File to execute</param>
      <param name="Arguments">Arguments sent to the executable</param>
      <param name="Domain">Domain of the user</param>
      <param name="Password">Password of the user</param>
      <param name="User">User to run the file as</param>
      <param name="WindowStyle">Window style</param>
      <param name="WorkingDirectory">Working directory</param>
      <returns>The process object created when the executable is started</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
      <requires description="file does not exist" exception="T:System.IO.FileNotFoundException" csharp="File.Exists" vb="File.Exists">File.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!File.Exists</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Execute(System.String,System.String,System.String,System.String,System.String,System.Diagnostics.ProcessWindowStyle,System.String)">
      <summary>
            Executes the file
            </summary>
      <param name="File">File to execute</param>
      <param name="Arguments">Arguments sent to the executable</param>
      <param name="Domain">Domain of the user</param>
      <param name="Password">Password of the user</param>
      <param name="User">User to run the file as</param>
      <param name="WindowStyle">Window style</param>
      <param name="WorkingDirectory">Working directory</param>
      <returns>The process object created when the executable is started</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(File)" vb="Not IsNullOrEmpty(File)">!string.IsNullOrEmpty(File)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(File)</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Execute(System.IO.FileInfo,System.Diagnostics.ProcessStartInfo)">
      <summary>
            Executes the file
            </summary>
      <param name="File">File to execute</param>
      <param name="Info">Info used to execute the file</param>
      <returns>The process object created when the executable is started</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
      <requires description="File not found" exception="T:System.IO.FileNotFoundException" csharp="File.Exists" vb="File.Exists">File.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!File.Exists</exception>
      <requires description="Info" exception="T:System.ArgumentNullException" csharp="Info != null" vb="Info &lt;&gt; Nothing">Info != null</requires>
      <exception cref="T:System.ArgumentNullException">Info == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Execute(System.String,System.Diagnostics.ProcessStartInfo)">
      <summary>
            Executes the file
            </summary>
      <param name="File">File to execute</param>
      <param name="Info">Info used to execute the file</param>
      <returns>The process object created when the executable is started</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(File)" vb="Not IsNullOrEmpty(File)">!string.IsNullOrEmpty(File)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(File)</exception>
      <requires description="Info" exception="T:System.ArgumentNullException" csharp="Info != null" vb="Info &lt;&gt; Nothing">Info != null</requires>
      <exception cref="T:System.ArgumentNullException">Info == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Save(System.IO.FileInfo,System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Saves a string to a file
            </summary>
      <param name="File">File to save to</param>
      <param name="Content">Content to save to the file</param>
      <param name="EncodingUsing">Encoding that the content is using (defaults to ASCII)</param>
      <param name="Mode">Mode for saving the file (defaults to Create)</param>
      <returns>The FileInfo object</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Save(System.IO.FileInfo,System.Byte[],System.IO.FileMode)">
      <summary>
            Saves a byte array to a file
            </summary>
      <param name="File">File to save to</param>
      <param name="Content">Content to save to the file</param>
      <param name="Mode">Mode for saving the file (defaults to Create)</param>
      <returns>The FileInfo object</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Save(System.String,System.String,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Saves the string to the specified file
            </summary>
      <param name="Location">Location to save the content to</param>
      <param name="Content">Content to save the the file</param>
      <param name="EncodingUsing">Encoding that the content is using (defaults to ASCII)</param>
      <param name="Mode">Mode for saving the file (defaults to Create)</param>
      <returns>The FileInfo object associated with the location</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.Save(System.String,System.Byte[],System.IO.FileMode)">
      <summary>
            Saves a byte array to a file
            </summary>
      <param name="Location">File to save to</param>
      <param name="Content">Content to save to the file</param>
      <param name="Mode">Mode for saving the file (defaults to Create)</param>
      <returns>The FileInfo object associated with the location</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.SaveAsync(System.IO.FileInfo,System.String,System.AsyncCallback,System.Object,System.IO.FileMode,System.Text.Encoding)">
      <summary>
            Saves a string to a file (asynchronously)
            </summary>
      <param name="File">File to save to</param>
      <param name="Content">Content to save to the file</param>
      <param name="CallBack">Call back function</param>
      <param name="StateObject">State object</param>
      <param name="EncodingUsing">Encoding that the content is using (defaults to ASCII)</param>
      <param name="Mode">Mode for saving the file (defaults to Create)</param>
      <returns>The FileInfo object</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.SaveAsync(System.IO.FileInfo,System.Byte[],System.AsyncCallback,System.Object,System.IO.FileMode)">
      <summary>
            Saves a byte array to a file (asynchronously)
            </summary>
      <param name="File">File to save to</param>
      <param name="Content">Content to save to the file</param>
      <param name="CallBack">Call back function</param>
      <param name="StateObject">State object</param>
      <param name="Mode">Mode for saving the file (defaults to Create)</param>
      <returns>The FileInfo object</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.FileInfoExtensions.SetAttributes(System.IO.FileInfo,System.IO.FileAttributes)">
      <summary>
            Sets the attributes of a file
            </summary>
      <param name="File">File</param>
      <param name="Attributes">Attributes to set</param>
      <returns>The file info</returns>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
      <requires description="File" exception="T:System.IO.FileNotFoundException" csharp="File.Exists" vb="File.Exists">File.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!File.Exists</exception>
    </member>
    <member name="T:Utilities.IO.ExtensionMethods.SerializationExtensions">
      <summary>
            Serialization extensions
            </summary>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Serialize(System.Object,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding,System.String)">
      <summary>
            Serializes the object using the specified serializer
            </summary>
      <param name="Object">Object to serialize</param>
      <param name="Serializer">Serializer to use (defaults to JSONSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)</param>
      <param name="FileLocation">File location to save to</param>
      <returns>The serialized object</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.IO.ExtensionMethods.SerializationExtensions.&lt;&gt;c__DisplayClass1().EncodingUsing = EncodingUsing;&#xD;&#xA;    }&#xD;&#xA;    return Object != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.IO.ExtensionMethods.SerializationExtensions.&lt;&gt;c__DisplayClass1().EncodingUsing = EncodingUsing&#xD;&#xA;    return Object &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.IO.ExtensionMethods.SerializationExtensions.&lt;&gt;c__DisplayClass1().EncodingUsing = EncodingUsing;
    }
    return Object != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.IO.ExtensionMethods.SerializationExtensions.&lt;&gt;c__DisplayClass1().EncodingUsing = EncodingUsing);
    }
    return (Object != null); })()</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.SerializeBinary(System.Object,Utilities.IO.Serializers.Interfaces.ISerializer{System.Byte[]},System.String)">
      <summary>
            Serializes the object using the specified serializer
            </summary>
      <param name="Object">Object to serialize</param>
      <param name="Serializer">Serializer to use (defaults to BinarySerializer)</param>
      <param name="FileLocation">File location to save to</param>
      <returns>The serialized object</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="Object != null" vb="Object &lt;&gt; Nothing">Object != null</requires>
      <exception cref="T:System.ArgumentNullException">Object == null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize``1(System.String,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding)">
      <summary>
            Deserializes an object
            </summary>
      <typeparam name="R">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="Serializer">Serializer to use (defaults to JSONSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)&gt;</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize``1(System.Xml.XmlDocument,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding)">
      <summary>
            Deserializes an object
            </summary>
      <typeparam name="R">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="Serializer">Serializer to use (defaults to XMLSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)&gt;</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize``1(System.Byte[],Utilities.IO.Serializers.Interfaces.ISerializer{System.Byte[]})">
      <summary>
            Deserializes an object
            </summary>
      <typeparam name="R">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="Serializer">Serializer to use (defaults to BinarySerializer)</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize``1(System.IO.FileInfo,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding)">
      <summary>
            Deserializes an object
            </summary>
      <typeparam name="R">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="Serializer">Serializer to use (defaults to JSONSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)&gt;</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize(System.IO.FileInfo,System.Type,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding)">
      <summary>
            Deserializes an object
            </summary>
      <param name="Data">Data to deserialize</param>
      <param name="Serializer">Serializer to use (defaults to JSONSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)&gt;</param>
      <param name="ObjectType">Object type</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize(System.String,System.Type,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding)">
      <summary>
            Deserializes an object
            </summary>
      <param name="Data">Data to deserialize</param>
      <param name="ObjectType">Object type</param>
      <param name="Serializer">Serializer to use (defaults to JSONSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)&gt;</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize(System.Byte[],System.Type,Utilities.IO.Serializers.Interfaces.ISerializer{System.Byte[]})">
      <summary>
            Deserializes an object
            </summary>
      <param name="Data">Data to deserialize</param>
      <param name="ObjectType">Object type</param>
      <param name="Serializer">Serializer to use (defaults to BinarySerializer)</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.Deserialize(System.Xml.XmlDocument,System.Type,Utilities.IO.Serializers.Interfaces.ISerializer{System.String},System.Text.Encoding)">
      <summary>
            Deserializes an object
            </summary>
      <param name="Data">Data to deserialize</param>
      <param name="ObjectType">Object type</param>
      <param name="Serializer">Serializer to use (defaults to XMLSerializer)</param>
      <param name="EncodingUsing">Encoding to use (defaults to ASCII)&gt;</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.DeserializeBinary(System.IO.FileInfo,System.Type,Utilities.IO.Serializers.Interfaces.ISerializer{System.Byte[]})">
      <summary>
            Deserializes an object
            </summary>
      <param name="Data">Data to deserialize</param>
      <param name="ObjectType">Object type</param>
      <param name="Serializer">Serializer to use (defaults to BinarySerializer)</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.SerializationExtensions.DeserializeBinary``1(System.IO.FileInfo,Utilities.IO.Serializers.Interfaces.ISerializer{System.Byte[]})">
      <summary>
            Deserializes an object
            </summary>
      <typeparam name="R">Object type</typeparam>
      <param name="Data">Data to deserialize</param>
      <param name="Serializer">Serializer to use (defaults to BinarySerializer)</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="T:Utilities.IO.ExtensionMethods.UriExtensions">
      <summary>
            Uri Extension methods
            </summary>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.UriExtensions.Execute(System.Uri)">
      <summary>
            opens the URL in a browser
            </summary>
      <param name="URL">URL to execute</param>
      <returns>The process object created when opening the URL</returns>
      <requires description="URL" exception="T:System.ArgumentNullException" csharp="URL != (System.Uri)null" vb="URL &lt;&gt; ((System.Uri)Nothing) ">URL != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">!URL != (System.Uri)null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.UriExtensions.Read(System.Uri,System.String,System.String,System.String,System.String)">
      <summary>
            Reads the text content of a URL
            </summary>
      <param name="URL">Uri to read the content of</param>
      <param name="UserName">User name used in network credentials</param>
      <param name="Password">Password used in network credentials</param>
      <param name="Domain">Domain to use in network credentials</param>
      <param name="AuthenticationType">Authentication type to use in network credentials</param>
      <returns>String representation of the content of the URL</returns>
      <requires description="URL" exception="T:System.ArgumentNullException" csharp="URL != (System.Uri)null" vb="URL &lt;&gt; ((System.Uri)Nothing) ">URL != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">!URL != (System.Uri)null</exception>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.UriExtensions.Read(System.Uri,System.Net.WebClient,System.String,System.String,System.String,System.String)">
      <summary>
            Reads the text content of a URL
            </summary>
      <param name="URL">The Uri to read the content of</param>
      <param name="Client">WebClient used to load the data</param>
      <param name="UserName">User name used in network credentials</param>
      <param name="Password">Password used in network credentials</param>
      <param name="Domain">Domain to use in network credentials</param>
      <param name="AuthenticationType">Authentication type to use in network credentials</param>
      <returns>Stream containing the content of the URL</returns>
    </member>
    <member name="M:Utilities.IO.ExtensionMethods.UriExtensions.ReadBinary(System.Uri,System.String,System.String,System.String,System.String)">
      <summary>
            Reads the content of a URL
            </summary>
      <param name="URL">Uri to read the content of</param>
      <param name="UserName">User name used in network credentials</param>
      <param name="Password">Password used in network credentials</param>
      <param name="Domain">Domain to use in network credentials</param>
      <param name="AuthenticationType">Authentication type to use in network credentials</param>
      <returns>Byte array representation of the content of the URL</returns>
      <requires description="URL" exception="T:System.ArgumentNullException" csharp="URL != (System.Uri)null" vb="URL &lt;&gt; ((System.Uri)Nothing) ">URL != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">!URL != (System.Uri)null</exception>
    </member>
    <member name="T:Utilities.IO.Logging.BaseClasses.LogBase`1">
      <summary>
            Base class for logs
            </summary>
      <typeparam name="LogType">Log type</typeparam>
    </member>
    <member name="T:Utilities.IO.Logging.Interfaces.ILog">
      <summary>
            Log interface
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.Interfaces.ILog.LogMessage(System.String,Utilities.IO.Logging.Enums.MessageType,System.Object[])">
      <summary>
            Logs a message
            </summary>
      <param name="Message">Message text</param>
      <param name="Type">Message type</param>
      <param name="args">Any additional arguments that will be used in formatting the message</param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.#ctor(System.Action{`0})">
      <summary>
            Constructor
            </summary>
      <param name="Start">Action called when the log is created</param>
    </member>
    <member name="F:Utilities.IO.Logging.BaseClasses.LogBase`1.Log_">
      <summary>
            Called to log the current message
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.BaseClasses.LogBase`1.LogMessage(System.String,Utilities.IO.Logging.Enums.MessageType,System.Object[])">
      <summary>
            Logs a message
            </summary>
      <param name="Message">Message to log</param>
      <param name="Type">Type of message</param>
      <param name="args">args to format/insert into the message</param>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.Start">
      <summary>
            Called when the log is "opened"
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.End">
      <summary>
            Called when the log is "closed"
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.Log">
      <summary>
            Called to log the current message
            </summary>
    </member>
    <member name="P:Utilities.IO.Logging.BaseClasses.LogBase`1.FormatMessage">
      <summary>
            Format message function
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.BaseClasses.Format">
      <summary>
            Delegate used to format the message
            </summary>
      <param name="Message">Message to format</param>
      <param name="Type">Type of message</param>
      <param name="args">Args to insert into the message</param>
      <returns>The formatted message</returns>
    </member>
    <member name="T:Utilities.IO.Logging.ConsoleLog">
      <summary>
            Outputs messages to the console
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.ConsoleLog.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.Enums.MessageType">
      <summary>
            Message type
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.General">
      <summary>
            General message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Debug">
      <summary>
            Debug message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Trace">
      <summary>
            Trace message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Info">
      <summary>
            Info message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Warn">
      <summary>
            Warn message
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.Enums.MessageType.Error">
      <summary>
            Error message
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.FileLog">
      <summary>
            Outputs messages to a file
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.FileLog.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="T:Utilities.IO.Logging.LoggingManager">
      <summary>
            Logging manager
            </summary>
    </member>
    <member name="F:Utilities.IO.Logging.LoggingManager.Logs">
      <summary>
            Logs
            </summary>
    </member>
    <member name="M:Utilities.IO.Logging.LoggingManager.GetLog``1(System.String)">
      <summary>
            Gets a specified log
            </summary>
      <param name="Name">The name of the log file</param>
      <typeparam name="LogType">Log type that the log object should be</typeparam>
      <returns>The log file specified</returns>
      <requires description="Log was not found" exception="T:System.ArgumentException" csharp="Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)" vb="Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)">Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)</requires>
      <exception cref="T:System.ArgumentException">!Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)</exception>
      <requires description="Log is not the type specified" exception="T:System.ArgumentException" csharp="Utilities.IO.Logging.LoggingManager.Logs.Item[Name] is LogType" vb="Utilities.IO.Logging.LoggingManager.Logs.Item[Name] Is LogType">Utilities.IO.Logging.LoggingManager.Logs.Item[Name] is LogType</requires>
      <exception cref="T:System.ArgumentException">!(Utilities.IO.Logging.LoggingManager.Logs.Item[Name] is LogType)</exception>
    </member>
    <member name="M:Utilities.IO.Logging.LoggingManager.GetLog(System.String)">
      <summary>
            Gets a specified log
            </summary>
      <param name="Name">The name of the log file</param>
      <returns>The log file specified</returns>
      <requires description="Log was not found" exception="T:System.ArgumentException" csharp="Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)" vb="Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)">Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)</requires>
      <exception cref="T:System.ArgumentException">!Utilities.IO.Logging.LoggingManager.Logs.ContainsKey(Name)</exception>
    </member>
    <member name="M:Utilities.IO.Logging.LoggingManager.AddLog``1(System.String)">
      <summary>
            Adds a log object or replaces one already in use
            </summary>
      <param name="Name">The name of the log file</param>
      <typeparam name="LogType">Log type to add</typeparam>
    </member>
    <member name="M:Utilities.IO.Logging.LoggingManager.AddLog(Utilities.IO.Logging.Interfaces.ILog,System.String)">
      <summary>
            Adds a log object or replaces one already in use
            </summary>
      <param name="Log">The log object to add</param>
      <param name="Name">The name of the log file</param>
      <requires description="Log" exception="T:System.ArgumentNullException" csharp="Log != null" vb="Log &lt;&gt; Nothing">Log != null</requires>
      <exception cref="T:System.ArgumentNullException">Log == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.IO.Logging.LoggingManager.Destroy">
      <summary>
            Destroys the logging manager
            </summary>
    </member>
    <member name="T:Utilities.Math.Conversion">
      <summary>
            Conversion helper
            </summary>
    </member>
    <member name="M:Utilities.Math.Conversion.CelsiusToFahrenheit(System.Double)">
      <summary>
            Celsius to Fahrenheit
            </summary>
      <param name="Value">Celsius value</param>
      <returns>Equivalent Fahrenheit temp</returns>
    </member>
    <member name="M:Utilities.Math.Conversion.CelsiusToKelvin(System.Double)">
      <summary>
            Celsius to Kelvin
            </summary>
      <param name="Value">Celsius value</param>
      <returns>Equivalent Kelvin temp</returns>
    </member>
    <member name="M:Utilities.Math.Conversion.FahrenheitToCelsius(System.Double)">
      <summary>
            Fahrenheit to Celsius
            </summary>
      <param name="Value">Fahrenheit value</param>
      <returns>Equivalent Celsius value</returns>
    </member>
    <member name="M:Utilities.Math.Conversion.FahrenheitToKelvin(System.Double)">
      <summary>
            Fahrenheit to Kelvin
            </summary>
      <param name="Value">Fahrenheit value</param>
      <returns>Equivalent Kelvin value</returns>
    </member>
    <member name="M:Utilities.Math.Conversion.KelvinToCelsius(System.Double)">
      <summary>
            Kelvin to Celsius
            </summary>
      <param name="Value">Kelvin value</param>
      <returns>Equivalent Celsius value</returns>
    </member>
    <member name="M:Utilities.Math.Conversion.KelvinToFahrenheit(System.Double)">
      <summary>
            Kelvin to Fahrenheit
            </summary>
      <param name="Value">Kelvin value</param>
      <returns>Equivalent Fahrenheit value</returns>
    </member>
    <member name="T:Utilities.Math.Set`1">
      <summary>
            Class to be used for sets of data
            </summary>
      <typeparam name="T">Type that the set holds</typeparam>
    </member>
    <member name="M:Utilities.Math.Set`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Math.Set`1.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="InitialSize">Initial size</param>
    </member>
    <member name="M:Utilities.Math.Set`1.Contains(Utilities.Math.Set{`0})">
      <summary>
            Used to tell if this set contains the other
            </summary>
      <param name="Set">Set to check against</param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.IsSubset(Utilities.Math.Set{`0})">
      <summary>
            Used to tell if this is a subset of the other
            </summary>
      <param name="Set">Set to check against</param>
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.Intersect(Utilities.Math.Set{`0})">
      <summary>
            Determines if the sets intersect
            </summary>
      <param name="Set">Set to check against</param>
      <returns>True if they do, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.GetIntersection(Utilities.Math.Set{`0},Utilities.Math.Set{`0})">
      <summary>
            Gets the intersection of set 1 and set 2
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>The intersection of the two sets</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.op_Addition(Utilities.Math.Set{`0},Utilities.Math.Set{`0})">
      <summary>
            Adds two sets together
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>The joined sets</returns>
      <requires description="Set1" exception="T:System.ArgumentNullException" csharp="Set1 != (Utilities.Math.Set&lt;T&gt;)null" vb="Set1 &lt;&gt; ((Utilities.Math.Set(Of T))Nothing) ">Set1 != (Utilities.Math.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set1 != (Utilities.Math.Set&lt;T&gt;)null</exception>
      <requires description="Set2" exception="T:System.ArgumentNullException" csharp="Set2 != (Utilities.Math.Set&lt;T&gt;)null" vb="Set2 &lt;&gt; ((Utilities.Math.Set(Of T))Nothing) ">Set2 != (Utilities.Math.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set2 != (Utilities.Math.Set&lt;T&gt;)null</exception>
    </member>
    <member name="M:Utilities.Math.Set`1.op_Subtraction(Utilities.Math.Set{`0},Utilities.Math.Set{`0})">
      <summary>
            Removes items from set 2 from set 1
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>The resulting set</returns>
      <requires description="Set1" exception="T:System.ArgumentNullException" csharp="Set1 != (Utilities.Math.Set&lt;T&gt;)null" vb="Set1 &lt;&gt; ((Utilities.Math.Set(Of T))Nothing) ">Set1 != (Utilities.Math.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set1 != (Utilities.Math.Set&lt;T&gt;)null</exception>
      <requires description="Set2" exception="T:System.ArgumentNullException" csharp="Set2 != (Utilities.Math.Set&lt;T&gt;)null" vb="Set2 &lt;&gt; ((Utilities.Math.Set(Of T))Nothing) ">Set2 != (Utilities.Math.Set&lt;T&gt;)null</requires>
      <exception cref="T:System.ArgumentNullException">!Set2 != (Utilities.Math.Set&lt;T&gt;)null</exception>
    </member>
    <member name="M:Utilities.Math.Set`1.op_Equality(Utilities.Math.Set{`0},Utilities.Math.Set{`0})">
      <summary>
            Determines if the two sets are equivalent
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.op_Inequality(Utilities.Math.Set{`0},Utilities.Math.Set{`0})">
      <summary>
            Determines if the two sets are not equivalent
            </summary>
      <param name="Set1">Set 1</param>
      <param name="Set2">Set 2</param>
      <returns>False if they are, true otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.GetHashCode">
      <summary>
            Returns the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.Equals(System.Object)">
      <summary>
            Determines if the two sets are equivalent
            </summary>
      <param name="obj">The object to compare to</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Set`1.ToString">
      <summary>
            Returns the set as a string
            </summary>
      <returns>The set as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.Media.Image.Procedural.CellularTexture">
      <summary>
            Cellular texture helper
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.CellularTexture.Generate(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Generates a cellular texture image
            </summary>
      <param name="Width">Width</param>
      <param name="Height">Height</param>
      <param name="NumberOfPoints">Number of points</param>
      <param name="Seed">Random seed</param>
      <returns>Returns an image of a cellular texture</returns>
    </member>
    <member name="T:Utilities.Media.Image.ColorMatrix">
      <summary>
            Helper class for setting up and applying a color matrix
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.ColorMatrix.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.ColorMatrix.Apply(System.Drawing.Bitmap)">
      <summary>
            Applies the color matrix
            </summary>
      <param name="OriginalImage">Image sent in</param>
      <returns>An image with the color matrix applied</returns>
      <requires description="OriginalImage" exception="T:System.ArgumentNullException" csharp="OriginalImage != null" vb="OriginalImage &lt;&gt; Nothing">OriginalImage != null</requires>
      <exception cref="T:System.ArgumentNullException">OriginalImage == null</exception>
    </member>
    <member name="P:Utilities.Media.Image.ColorMatrix.Matrix">
      <summary>
            Matrix containing the values of the ColorMatrix
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.Procedural.FaultFormation">
      <summary>
            Helper class for doing fault formations
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.FaultFormation.Generate(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Generates a number of faults, returning an image
            </summary>
      <param name="Width">Width of the resulting image</param>
      <param name="Height">Height of the resulting image</param>
      <param name="NumberFaults">Number of faults</param>
      <param name="Seed">Random seed</param>
      <returns>An image from the resulting faults</returns>
    </member>
    <member name="T:Utilities.Media.Image.Procedural.MidpointDisplacement">
      <summary>
            Helper class for generating cracks by midpoint displacement
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.MidpointDisplacement.Generate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Generates an image that contains cracks
            </summary>
      <param name="Width">Image width</param>
      <param name="Height">Image height</param>
      <param name="NumberOfCracks">Number of cracks</param>
      <param name="Iterations">Iterations</param>
      <param name="MaxChange">Maximum height change of the cracks</param>
      <param name="MaxLength">Maximum length of the cracks</param>
      <param name="Seed">Random seed</param>
      <returns>An image containing "cracks"</returns>
    </member>
    <member name="T:Utilities.Media.Image.Procedural.PerlinNoise">
      <summary>
            Perlin noise helper class
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.PerlinNoise.Generate(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
      <summary>
            Generates perlin noise
            </summary>
      <param name="Width">Width of the resulting image</param>
      <param name="Height">Height of the resulting image</param>
      <param name="MaxRGBValue">MaxRGBValue</param>
      <param name="MinRGBValue">MinRGBValue</param>
      <param name="Frequency">Frequency</param>
      <param name="Amplitude">Amplitude</param>
      <param name="Persistance">Persistance</param>
      <param name="Octaves">Octaves</param>
      <param name="Seed">Random seed</param>
      <returns>An image containing perlin noise</returns>
    </member>
    <member name="T:Utilities.ORM.Aspect.Interfaces.IORMObject">
      <summary>
            ORM object interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.Interfaces.IORMObject.Session0">
      <summary>
            ORM session that this item came from (used for lazy loading)
            </summary>
    </member>
    <member name="T:Utilities.ORM.Aspect.ORMAspect">
      <summary>
            ORM Aspect (used internally)
            </summary>
    </member>
    <member name="T:Utilities.Reflection.AOP.Interfaces.IAspect">
      <summary>
            Aspect interface
            </summary>
    </member>
    <member name="M:Utilities.Reflection.AOP.Interfaces.IAspect.SetupStartMethod(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type)">
      <summary>
            Used to insert IL code at the beginning of the method
            </summary>
      <param name="Method">Overridding Method</param>
      <param name="BaseType">Base type</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.Interfaces.IAspect.SetupEndMethod(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Used to insert IL code at the end of the method
            </summary>
      <param name="Method">Overridding Method</param>
      <param name="BaseType">Base type</param>
      <param name="ReturnValue">Local holder for the value returned by the function</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.Interfaces.IAspect.SetupExceptionMethod(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type)">
      <summary>
            Used to insert IL code within the catch portion of the try/catch portion of the method
            </summary>
      <param name="Method">Overridding Method</param>
      <param name="BaseType">Base type</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.Interfaces.IAspect.Setup(System.Object)">
      <summary>
            Used to hook into the object once it has been created
            </summary>
      <param name="Object">Object created by the system</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.Interfaces.IAspect.SetupInterfaces(Utilities.Reflection.Emit.TypeBuilder)">
      <summary>
            Used to set up any interfaces, extra fields, methods, etc. prior to overridding any methods.
            </summary>
      <param name="TypeBuilder">Type builder object</param>
    </member>
    <member name="P:Utilities.Reflection.AOP.Interfaces.IAspect.InterfacesUsing">
      <summary>
            List of interfaces that need to be injected by this aspect
            </summary>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.#ctor(Utilities.DataTypes.ListMapping{System.Type,Utilities.ORM.Mapping.Interfaces.IMapping})">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.Setup(System.Object)">
      <summary>
            Sets up an object
            </summary>
      <param name="Object">Object to set up</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupEndMethod(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Sets up the code at the end of the method
            </summary>
      <param name="Method">Method builder to use</param>
      <param name="BaseType">Base type</param>
      <param name="ReturnValue">Return value (if there is one)</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupExceptionMethod(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type)">
      <summary>
            Sets up the exception method
            </summary>
      <param name="Method">Method builder</param>
      <param name="BaseType">Base type</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupInterfaces(Utilities.Reflection.Emit.TypeBuilder)">
      <summary>
            Set up interfaces
            </summary>
      <param name="TypeBuilder">Type builder to use</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupStartMethod(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type)">
      <summary>
            Sets up the start method
            </summary>
      <param name="Method">Method builder to use</param>
      <param name="BaseType">Base type</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.CreateConstructor(Utilities.Reflection.Emit.TypeBuilder)">
      <summary>
            Creates the default constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.CreateProperty(Utilities.Reflection.Emit.TypeBuilder,System.String,System.Type)">
      <summary>
            Creates a default property
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Name">Name of the property</param>
      <param name="PropertyType">Property type</param>
      <returns>The property builder</returns>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupFields(Utilities.Reflection.Emit.TypeBuilder)">
      <summary>
            Sets up the fields needed to store the data for lazy loading
            </summary>
      <param name="TypeBuilder" />
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupIEnumerableProperty(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type,Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.ORM.Mapping.Interfaces.IProperty,Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Sets up a property (IEnumerable)
            </summary>
      <param name="Method">Method builder</param>
      <param name="BaseType">Base type for the object</param>
      <param name="ReturnValue">Return value</param>
      <param name="Property">Property info</param>
      <param name="Mapping">Mapping info</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupListProperty(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type,Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.ORM.Mapping.Interfaces.IProperty,Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Sets up a property (List)
            </summary>
      <param name="Method">Method builder</param>
      <param name="BaseType">Base type for the object</param>
      <param name="ReturnValue">Return value</param>
      <param name="Property">Property info</param>
      <param name="Mapping">Mapping info</param>
    </member>
    <member name="M:Utilities.ORM.Aspect.ORMAspect.SetupSingleProperty(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Type,Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.ORM.Mapping.Interfaces.IProperty,Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Sets up a property (non IEnumerable)
            </summary>
      <param name="Method">Method builder</param>
      <param name="BaseType">Base type for the object</param>
      <param name="ReturnValue">Return value</param>
      <param name="Property">Property info</param>
      <param name="Mapping">Mapping info</param>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.InterfacesUsing">
      <summary>
            Interfaces this aspect is using
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.ClassMappings">
      <summary>
            Class mappings
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.Fields">
      <summary>
            Fields used for storing Map, ManyToOne, and ManyToMany properties
            </summary>
    </member>
    <member name="P:Utilities.ORM.Aspect.ORMAspect.SessionField">
      <summary>
            Field to store the session object
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IID`2">
      <summary>
            ID interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IIEnumerableManyToOne`2">
      <summary>
            Many to one interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Property data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IIEnumerableManyToOne">
      <summary>
            Many to one interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IManyToMany`2">
      <summary>
            Many to many interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Property data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IManyToMany">
      <summary>
            Many to many interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IManyToOne`2">
      <summary>
            Many to one interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Property data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IManyToOne">
      <summary>
            Many to one interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IMap`2">
      <summary>
            Map interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IMap">
      <summary>
            Map interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IMappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMappingManager.Mappings">
      <summary>
            Mappings
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IReference`2">
      <summary>
            Reference interface
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.Mapping`2">
      <summary>
            Class mapping
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DatabaseType">Database type</typeparam>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IMapping`1">
      <summary>
            Class mapping interface
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ID``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Declares a property as an ID
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the ID object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ID(System.Linq.Expressions.Expression{System.Func{`0,System.String}})">
      <summary>
            Declares a property as an ID
            </summary>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the ID object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.Reference``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Sets a property as a reference type
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the reference object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.Reference(System.Linq.Expressions.Expression{System.Func{`0,System.String}})">
      <summary>
            Sets a property as a reference type
            </summary>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the reference object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Sets a property as a map type
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>the map object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the property</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            IEnumerable many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointint to the property</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            IEnumerable many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointint to the property</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            Many to many mapping
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the many to many property</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            Many to many mapping
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression pointing to the many to many property</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.Any(System.String,System.Data.CommandType)">
      <summary>
            Sets the default command to call when Any is called (optional)
            </summary>
      <param name="Command">Command to call</param>
      <param name="CommandType">Command type</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping`1.All(System.String,System.Data.CommandType)">
      <summary>
            Sets the default command to call when All is called (optional)
            </summary>
      <param name="Command">Command to call</param>
      <param name="CommandType">Command type</param>
    </member>
    <member name="T:Utilities.ORM.Mapping.Interfaces.IMapping">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase)">
      <summary>
            Internal function used to add to
            the query provider
            </summary>
      <param name="Database">Database object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Interfaces.IMapping.Initialize">
      <summary>
            Should be overwritten to initialize values in the 
            database. This is run after the initial setup but prior to
            returning to the user.
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.Suffix">
      <summary>
            Suffix used for defining properties/table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.Prefix">
      <summary>
            Prefix used for defining properties/table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.DatabaseConfigType">
      <summary>
            Database config type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.Properties">
      <summary>
            Properties list
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.IDProperty">
      <summary>
            ID property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.Manager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.ObjectType">
      <summary>
            The object type associated with the mapping
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.AnyCommand">
      <summary>
            Any command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.AllCommand">
      <summary>
            All command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Interfaces.IMapping.Order">
      <summary>
            Order that the mappings are initialized
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.#ctor(System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="TableName">Table name</param>
      <param name="Suffix">Suffix used to define names of properties/table name</param>
      <param name="Prefix">Prefix used to define names of properties/table name</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase)">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.All(System.String,System.Data.CommandType)">
      <summary>
            Sets a command for default all function
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.Any(System.String,System.Data.CommandType)">
      <summary>
            Sets a command for default any function
            </summary>
      <param name="Command">Command</param>
      <param name="CommandType">Command type</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.Setup">
      <summary>
            Sets up the mapping
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ID``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates an ID object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>ID object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ID(System.Linq.Expressions.Expression{System.Func{`0,System.String}})">
      <summary>
            Creates an ID object
            </summary>
      <param name="Expression">Expression</param>
      <returns>ID object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.Initialize">
      <summary>
            Should be overwritten to initialize values in the 
            database. This is run after the initial setup but prior to
            returning to the user.
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.Reference``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates a reference object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>A reference object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.Reference(System.Linq.Expressions.Expression{System.Func{`0,System.String}})">
      <summary>
            Creates a reference object
            </summary>
      <param name="Expression">Expression</param>
      <returns>A reference object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates a map object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The map object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Creates a many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            Creates a many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ManyToOne``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            Creates a many to one
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to one object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            Creates a many to many object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to many object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.Mapping`2.ManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.List{``0}}})">
      <summary>
            Creates a many to many object
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Expression">Expression</param>
      <returns>The many to many object</returns>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.Suffix">
      <summary>
            Suffix used
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.Prefix">
      <summary>
            Prefix used
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.DatabaseConfigType">
      <summary>
            Database config type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.Properties">
      <summary>
            List of properties
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.IDProperty">
      <summary>
            ID property
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.Manager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.ObjectType">
      <summary>
            Object type
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.AnyCommand">
      <summary>
            Default any command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.AllCommand">
      <summary>
            Default all command
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.Mapping`2.Order">
      <summary>
            The order in which the mappings are initialized
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.MappingManager.#ctor(System.Reflection.Assembly)">
      <summary>
            Constructor
            </summary>
      <param name="AssemblyUsing">Assembly using</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.MappingManager.#ctor(System.Reflection.Assembly[])">
      <summary>
            Constructor
            </summary>
      <param name="AssembliesUsing">Assemblies using</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.MappingManager.Setup(System.Reflection.Assembly)">
      <summary>
            Sets up the mappings
            </summary>
      <param name="AssemblyUsing">Assembly using</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.MappingManager.Initialize">
      <summary>
            Initializes the mappings
            </summary>
    </member>
    <member name="P:Utilities.ORM.Mapping.MappingManager.Mappings">
      <summary>
            List of mappings
            </summary>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.ID`2">
      <summary>
            ID class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the ID</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.SetDefaultValue(System.Func{`1})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ID`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2">
      <summary>
            Many to one class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{`1}}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.SetupLoadCommands">
      <summary>
            Sets loading command
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.SetDefaultValue(System.Func{System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.IEnumerableManyToOne`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2">
      <summary>
            Many to many class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{`1}}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to many</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.SetDefaultValue(System.Func{System.Collections.Generic.IEnumerable{`1}})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToMany`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2">
      <summary>
            Many to one class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the many to one</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.SetDefaultValue(System.Func{`1})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.ManyToOne`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.Map`2">
      <summary>
            Map class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the Map</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.SetDefaultValue(System.Func{`1})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Map`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.Reference`2">
      <summary>
            Reference class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.#ctor(System.Linq.Expressions.Expression{System.Func{`0,`1}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the property</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.SetDefaultValue(System.Func{`1})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.Reference`2.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.StringID`1">
      <summary>
            ID class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.String}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the ID</param>
      <param name="Mapping">Mapping the StringID is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.SetDefaultValue(System.Func{System.String})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringID`1.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.Mapping.PropertyTypes.StringReference`1">
      <summary>
            Reference class
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0,System.String}},Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Constructor
            </summary>
      <param name="Expression">Expression pointing to the property</param>
      <param name="Mapping">Mapping that the reference is added to</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.SetupLoadCommands">
      <summary>
            Sets up the default load commands
            </summary>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.JoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object from join tables
            </summary>
      <param name="Object">Object to remove</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.JoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.CascadeJoinsDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object to from join tables on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.CascadeJoinsSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object to various join tables on cascade
            </summary>
      <param name="Object">Object to add</param>
      <param name="MicroORM">Micro ORM object</param>
      <returns>The list of commands needed to do this</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.CascadeDelete(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Deletes the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.CascadeSave(`0,Utilities.SQL.SQLHelper)">
      <summary>
            Saves the object on cascade
            </summary>
      <param name="Object">Object</param>
      <param name="MicroORM">Micro ORM object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.GetAsParameter(`0)">
      <summary>
            Gets it as a parameter
            </summary>
      <param name="Object">Object</param>
      <returns>The value as a parameter</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.GetAsObject(`0)">
      <summary>
            Gets it as an object
            </summary>
      <param name="Object">Object</param>
      <returns>The value as an object</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.LoadUsingCommand(System.String,System.Data.CommandType)">
      <summary>
            Sets the loading command used
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.AddToQueryProvider(Utilities.ORM.QueryProviders.Interfaces.IDatabase,Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Add to query provider
            </summary>
      <param name="Database">Database object</param>
      <param name="Mapping">Mapping object</param>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.SetDefaultValue(System.Func{System.String})">
      <summary>
            Set a default value
            </summary>
      <param name="DefaultValue">Default value</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.DoNotAllowNullValues">
      <summary>
            Does not allow null values
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.ThisShouldBeUnique">
      <summary>
            This should be unique
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.TurnOnIndexing">
      <summary>
            Turn on indexing
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.TurnOnAutoIncrement">
      <summary>
            Turn on auto increment
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.SetFieldName(System.String)">
      <summary>
            Set field name
            </summary>
      <param name="FieldName">Field name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.SetTableName(System.String)">
      <summary>
            Set the table name
            </summary>
      <param name="TableName">Table name</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.TurnOnCascade">
      <summary>
            Turn on cascade
            </summary>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.ORM.Mapping.PropertyTypes.StringReference`1.SetMaxLength(System.Int32)">
      <summary>
            Set max length
            </summary>
      <param name="MaxLength">Max length</param>
      <returns>This</returns>
    </member>
    <member name="T:Utilities.ORM.ORM">
      <summary>
            Main ORM class
            </summary>
    </member>
    <member name="M:Utilities.ORM.ORM.#ctor(System.Boolean,System.Reflection.Assembly[])">
      <summary>
            Constructor
            </summary>
      <param name="Profile">Should calls be profiled?</param>
      <param name="Assemblies">Assemblies containing business object mappings</param>
    </member>
    <member name="M:Utilities.ORM.ORM.Setup">
      <summary>
            Can be used to setup various bits of data that are normally created on the fly as the system is used.
            Also calls initialization code found in mappings.
            </summary>
    </member>
    <member name="M:Utilities.ORM.ORM.CreateSession">
      <summary>
            Creates a session to allow you to make queries to the system
            </summary>
      <returns>A session object</returns>
    </member>
    <member name="M:Utilities.ORM.ORM.Destroy">
      <summary>
            Deletes all mappings, etc. Basically clears out everything so you can recreate items (only really useful for testing)
            </summary>
    </member>
    <member name="P:Utilities.ORM.ORM.QueryProvider">
      <summary>
            Query provider
            </summary>
    </member>
    <member name="P:Utilities.ORM.ORM.MappingManager">
      <summary>
            Mapping manager
            </summary>
    </member>
    <member name="P:Utilities.ORM.ORM.DatabaseManager">
      <summary>
            Database manager
            </summary>
    </member>
    <member name="T:Utilities.ORM.QueryProviders.Interfaces.IDatabase">
      <summary>
            Database configuration interface
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.Name">
      <summary>
            Name associated with the database
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.ConnectionString">
      <summary>
            Connection string
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.ParameterStarter">
      <summary>
            String used to start parameter names
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.Audit">
      <summary>
            Determines if audit tables are generated
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.Update">
      <summary>
            Should the structure of the database be updated?
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.Writable">
      <summary>
            Should this database be used to write data?
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.Readable">
      <summary>
            Should this database be used to read data?
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Interfaces.IDatabase.Order">
      <summary>
            Order that this database should be in
            (if only one database is being used, it is ignored)
            </summary>
    </member>
    <member name="T:Utilities.ORM.QueryProviders.Default">
      <summary>
            Default query provider
            </summary>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.#ctor(System.Boolean,System.Reflection.Assembly[])">
      <summary>
            Constructor
            </summary>
      <param name="Profile">Should profiling be done</param>
      <param name="AssembliesUsing">Assemblies using</param>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Setup(System.Reflection.Assembly)">
      <summary>
            Sets up the system
            </summary>
      <param name="AssemblyUsing">Assembly to set up</param>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.AddMapping(Utilities.ORM.Mapping.Interfaces.IMapping)">
      <summary>
            Adds a mapping
            </summary>
      <param name="Mapping">Mapping to add</param>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Any``1(Utilities.ORM.Session,``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns any item that matches the criteria
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Parameters">Parameters used in the where clause</param>
      <param name="CurrentSession">Current session</param>
      <param name="ReturnValue">Return value</param>
      <returns>First item matching the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Any``1(Utilities.ORM.Session,System.String,``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns any item that matches the criteria
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Columns">Columns to load</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <param name="CurrentSession">Current session</param>
      <param name="ReturnValue">Return value</param>
      <returns>First item that matches the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Any``1(Utilities.ORM.Session,System.String,System.Data.CommandType,``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns any item that matches the criteria
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Command">Command to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <param name="CurrentSession">Current session</param>
      <param name="ReturnValue">Return value</param>
      <returns>First item that matches the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.All``1(Utilities.ORM.Session,System.String,System.Int32,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a list of objects that meet the criteria
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="CurrentSession">Current session</param>
      <param name="Columns">Columns to load</param>
      <param name="Limit">Limit on the number of items to return</param>
      <param name="OrderBy">Order by clause (minus the ORDER BY)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A list of objects that meet the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.All``1(Utilities.ORM.Session,System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a list of objects that meet the criteria
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="CurrentSession">Current session</param>
      <param name="Command">Command to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A list of objects that meet the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.All``1(Utilities.ORM.Session,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a list of objects that meet the criteria
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="CurrentSession">Current session</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A list of objects that meet the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Delete``1(``0)">
      <summary>
            Deletes the specified object from the database
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to delete</param>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.LoadProperties``2(Utilities.ORM.Session,``0,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads a property
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Property type</typeparam>
      <param name="CurrentSession">Current Session</param>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <param name="Parameters">Extra parameters</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.LoadListProperties``2(Utilities.ORM.Session,``0,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads a property
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Property type</typeparam>
      <param name="CurrentSession">Current Session</param>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <param name="Parameters">Extra parameters</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.LoadProperty``2(Utilities.ORM.Session,``0,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads a property
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Property type</typeparam>
      <param name="CurrentSession">Current session</param>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <param name="Parameters">Extra parameters</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Paged``1(Utilities.ORM.Session,System.String,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a paged list of items
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Columns">Columns to load</param>
      <param name="OrderBy">Order by clause (minus the ORDER BY part)</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (starting with 0)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <param name="CurrentSession">Current session to use in the query</param>
      <returns>A paged list of items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.PagedCommand``1(Utilities.ORM.Session,System.String,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a paged list of items
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Command">Command to use</param>
      <param name="OrderBy">Order by clause (minus the ORDER BY part)</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (starting with 0)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <param name="CurrentSession">Current session to use in the query</param>
      <returns>A paged list of items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.PageCount``1(Utilities.ORM.Session,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified info
            </summary>
      <param name="CurrentSession">Current session</param>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.PageCount``1(Utilities.ORM.Session,System.String,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified info
            </summary>
      <param name="CurrentSession">Current session</param>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Save``2(``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Saves an object to the database
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="PrimaryKeyType">Primary key type</typeparam>
      <param name="Object">Object to save</param>
      <param name="Parameters">Extra parameters used in saving the object</param>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Scalar``2(Utilities.ORM.Session,System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a supplied scalar function and returns the result
            </summary>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <param name="CurrentSession">Current session</param>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ObjectType">Object type</typeparam>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.ORM.QueryProviders.Default.Scalar``2(Utilities.ORM.Session,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a scalar command using the specified aggregate function
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="CurrentSession">Current session</param>
      <param name="AggregateFunction">Aggregate function</param>
      <param name="Parameters">Parameters</param>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Default.Databases">
      <summary>
            List of database configurations
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Default.Manager">
      <summary>
            AOP manager (used to create objects)
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Default.Mappings">
      <summary>
            Mappings associated to databases
            </summary>
    </member>
    <member name="P:Utilities.ORM.QueryProviders.Default.Profile">
      <summary>
            Should the queries be profiled?
            </summary>
    </member>
    <member name="T:Utilities.ORM.Session">
      <summary>
            Session class
            </summary>
    </member>
    <member name="M:Utilities.ORM.Session.#ctor(Utilities.ORM.QueryProviders.Default)">
      <summary>
            Constructor
            </summary>
      <param name="QueryProvider">Query provider</param>
    </member>
    <member name="M:Utilities.ORM.Session.Any``1(System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a single item matching the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Columns">Columns to load</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A single object matching the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.Any``1(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a single item matching the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A single object matching the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.Any``1(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a single item matching the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Command">SQL Command to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A single object matching the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.All``1(System.String,System.Int32,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns all items that match the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Columns">Columns to load</param>
      <param name="Limit">Limit of the number of items to load</param>
      <param name="OrderBy">Order by clause (minus the ORDER BY part)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>All items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.All``1(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns all items that match the criteria
            </summary>
      <typeparam name="ObjectType">Type of the object</typeparam>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>All items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.All``1(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            /// Returns all items that match the criteria
            </summary>
      <typeparam name="ObjectType" />
      <param name="Command">SQL Command to run</param>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>All items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.Delete``1(``0)">
      <summary>
            Deletes an object from the database
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Object">Object to delete</param>
    </member>
    <member name="M:Utilities.ORM.Session.LoadProperties``2(``0,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads a property (primarily used internally for lazy loading)
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <param name="Parameters">Extra parameters (generally will be the ID of the object)</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.Session.LoadListProperties``2(``0,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads a property (primarily used internally for lazy loading)
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <param name="Parameters">Extra parameters (generally will be the ID of the object)</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.Session.LoadProperty``2(``0,System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Loads a property (primarily used internally for lazy loading)
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="DataType">Data type</typeparam>
      <param name="Object">Object</param>
      <param name="PropertyName">Property name</param>
      <param name="Parameters">Extra parameters (generally will be the ID of the object)</param>
      <returns>The appropriate property value</returns>
    </member>
    <member name="M:Utilities.ORM.Session.Paged``1(System.String,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a paged list of items
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Columns">Columns to load</param>
      <param name="OrderBy">Order by clause (minus the ORDER BY part)</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (starting with 0)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A paged list of items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.PagedCommand``1(System.String,System.String,System.Int32,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Returns a paged list of items
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="Command">Command to call</param>
      <param name="OrderBy">Order by clause (minus the ORDER BY part)</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page (starting with 0)</param>
      <param name="Parameters">Parameters used in the where clause</param>
      <returns>A paged list of items that match the criteria</returns>
    </member>
    <member name="M:Utilities.ORM.Session.PageCount``1(System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified 
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <typeparam name="ObjectType">Object type to get the page count of</typeparam>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.ORM.Session.PageCount``1(System.String,System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified 
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <typeparam name="ObjectType">Object type to get the page count of</typeparam>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.ORM.Session.Save``2(``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Saves an object to the database
            </summary>
      <typeparam name="ObjectType">Object type</typeparam>
      <typeparam name="PrimaryKeyType">Primary key type</typeparam>
      <param name="Object">Object to save</param>
      <param name="Parameters">Extra parameters to save</param>
    </member>
    <member name="M:Utilities.ORM.Session.Scalar``2(System.String,System.Data.CommandType,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a supplied scalar function and returns the result
            </summary>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ObjectType">Object type</typeparam>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.ORM.Session.Scalar``2(System.String,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a scalar command using the specified aggregate function
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ObjectType">Object type</typeparam>
      <param name="AggregateFunction">Aggregate function</param>
      <param name="Parameters">Parameters</param>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="P:Utilities.ORM.Session.QueryProvider">
      <summary>
            Query provider
            </summary>
    </member>
    <member name="T:Utilities.Profiler.StopWatch">
      <summary>
            Acts as a stop watch (records start and stop times)
            </summary>
    </member>
    <member name="M:Utilities.Profiler.StopWatch.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Profiler.StopWatch.Start">
      <summary>
            Starts the stop watch
            </summary>
    </member>
    <member name="M:Utilities.Profiler.StopWatch.Reset">
      <summary>
            Resets the watch
            </summary>
    </member>
    <member name="M:Utilities.Profiler.StopWatch.Stop">
      <summary>
            Stops the stop watch
            </summary>
    </member>
    <member name="P:Utilities.Profiler.StopWatch.ElapsedTime">
      <summary>
            Returns the elapsed time
            </summary>
    </member>
    <member name="P:Utilities.Profiler.StopWatch.Watch">
      <summary>
            Internal stop watch
            </summary>
    </member>
    <member name="T:Utilities.Reflection.AOP.AOPManager">
      <summary>
            AOP interface manager
            </summary>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.#ctor(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="AspectLocation">Aspect DLL location (optional)</param>
      <param name="AssemblyDirectory">Directory to save the generated types (optional)</param>
      <param name="AssemblyName">Assembly name to save the generated types as (optional)</param>
      <param name="RegenerateAssembly">Should this assembly be regenerated if found? (optional)</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.Destroy">
      <summary>
            Clears out the AOP data (really only used in testing)
            </summary>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.AddAspect(Utilities.Reflection.AOP.Interfaces.IAspect)">
      <summary>
            Adds an aspect to the manager (only needed if loading aspects manually)
            </summary>
      <param name="Aspect">Aspect to load</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.Save">
      <summary>
            Saves the assembly to the directory
            </summary>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.Setup(System.Type)">
      <summary>
            Sets up a type so it can be used in the system later
            </summary>
      <param name="Type">Type to set up</param>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.Create``1">
      <summary>
            Creates an object of the specified base type, registering the type if necessary
            </summary>
      <typeparam name="T">The base type</typeparam>
      <returns>Returns an object of the specified base type</returns>
    </member>
    <member name="M:Utilities.Reflection.AOP.AOPManager.Create(System.Type)">
      <summary>
            Creates an object of the specified base type, registering the type if necessary
            </summary>
      <param name="BaseType">The base type</param>
      <returns>Returns an object of the specified base type</returns>
    </member>
    <member name="F:Utilities.Reflection.AOP.AOPManager.Classes">
      <summary>
            Dictionary containing generated types and associates it with original type
            </summary>
    </member>
    <member name="F:Utilities.Reflection.AOP.AOPManager.Aspects">
      <summary>
            The list of aspects that are being used
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.AOPManager.AssemblyBuilder">
      <summary>
            Assembly containing generated types
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.AOPManager.AssemblyDirectory">
      <summary>
            Assembly directory
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.AOPManager.AssemblyName">
      <summary>
            Assembly name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.AOPManager.RegenerateAssembly">
      <summary>
            Determines if the assembly needs to be regenerated
            </summary>
    </member>
    <member name="T:Utilities.Reflection.AOP.EventArgs.Ending">
      <summary>
            EventArgs used in ending event
            </summary>
    </member>
    <member name="M:Utilities.Reflection.AOP.EventArgs.Ending.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Ending.MethodName">
      <summary>
            Method name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Ending.Parameters">
      <summary>
            Parameters list
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Ending.ReturnValue">
      <summary>
            Return value
            </summary>
    </member>
    <member name="T:Utilities.Reflection.AOP.EventArgs.Exception">
      <summary>
            EventArgs used during the exception event
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Exception.InternalException">
      <summary>
            Exception that was thrown
            </summary>
    </member>
    <member name="T:Utilities.Reflection.AOP.EventArgs.Starting">
      <summary>
            EventArgs used during the start event
            </summary>
    </member>
    <member name="M:Utilities.Reflection.AOP.EventArgs.Starting.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Starting.MethodName">
      <summary>
            Method Name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Starting.Parameters">
      <summary>
            Parameter list
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.EventArgs.Starting.ReturnValue">
      <summary>
            Return value
            </summary>
    </member>
    <member name="T:Utilities.Reflection.AOP.Interfaces.IEvents">
      <summary>
            Events interface (injected into all objects)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.Interfaces.IEvents.Aspectus_Ending">
      <summary>
            Called when property/function is ending
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.Interfaces.IEvents.Aspectus_Starting">
      <summary>
            Called when property/function is starting
            </summary>
    </member>
    <member name="P:Utilities.Reflection.AOP.Interfaces.IEvents.Aspectus_Exception">
      <summary>
            Called when an error is caught
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Assembly">
      <summary>
            Assembly class
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Assembly.#ctor(System.String,System.String,Utilities.Reflection.Emit.Enums.AssemblyType)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Assembly name</param>
      <param name="Directory">Directory to save the assembly (if left blank, the assembly is run only and will not be saved)</param>
      <param name="Type">Assembly type (exe or dll)</param>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.Assembly.Setup(System.String,System.String,Utilities.Reflection.Emit.Enums.AssemblyType)">
      <summary>
            Sets up the assembly
            </summary>
      <param name="Name">Assembly name</param>
      <param name="Directory">Directory to save the assembly (if left blank, the assembly is run only and will not be saved)</param>
      <param name="Type">Assembly type (dll or exe)</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Assembly.CreateType(System.String,System.Reflection.TypeAttributes,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Creates a type builder
            </summary>
      <param name="Name">Name of the type</param>
      <param name="Attributes">Attributes associated with the type</param>
      <param name="BaseClass">Base class for this type</param>
      <param name="Interfaces">Interfaces used by this type</param>
      <returns>A TypeBuilder class</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Assembly.CreateEnum(System.String,System.Type,System.Reflection.TypeAttributes)">
      <summary>
            Creates an enum builder
            </summary>
      <param name="Name">Name of the enum</param>
      <param name="EnumBaseType">Base type of the enum (defaults to int)</param>
      <param name="Attributes">Attributes associated with the type</param>
      <returns>An EnumBuilder class</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Assembly.Create">
      <summary>
            Creates all types associated with the assembly and saves the assembly to disk
            if a directory is specified.
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Assembly.ToString">
      <summary>
            Converts the assembly to a string
            </summary>
      <returns>The string version of the assembly</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Module">
      <summary>
            ModuleBuilder object
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Name">
      <summary>
            Name of the assembly
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Directory">
      <summary>
            Directory of the assembly
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Classes">
      <summary>
            List of classes associated with this assembly
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Enums">
      <summary>
            List of enums associated with this assembly
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Type">
      <summary>
            Assembly type (exe or dll)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Assembly.Builder">
      <summary>
            Assembly builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.BaseClasses.CommandBase">
      <summary>
            Command base class
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Interfaces.ICommand">
      <summary>
            Interface for a command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.CommandBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.CommandBase.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.CommandBase.ConversionOpCodes">
      <summary>
            Used to store conversion opcodes
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.CommandBase.ComparisonOpCodes">
      <summary>
            Used to store comparison opcodes
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.CommandBase.ComparisonTextEquivalent">
      <summary>
            Used to store text equivalent of comparison types
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.CommandBase.Result">
      <summary>
            Return value (set to null if not used by the command)
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.BaseClasses.MethodBase">
      <summary>
            Method base class
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Interfaces.IMethodBuilder">
      <summary>
            Interface for methods
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.SetCurrentMethod">
      <summary>
            Sets the method as the current method
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.CreateLocal(System.String,System.Type)">
      <summary>
            Defines a local variable
            </summary>
      <param name="Name">Name of the local variable</param>
      <param name="LocalType">The Type of the local variable</param>
      <returns>The LocalBuilder associated with the variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.CreateConstant(System.Object)">
      <summary>
            Constant value
            </summary>
      <param name="Value">Value of the constant</param>
      <returns>The ConstantBuilder associated with the variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.NewObj(System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Creates new object
            </summary>
      <param name="Constructor">Constructor</param>
      <param name="Variables">Variables to send to the constructor</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.NewObj(System.Type,System.Object[])">
      <summary>
            Creates new object
            </summary>
      <param name="ObjectType">object type</param>
      <param name="Variables">Variables to send to the constructor</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Assign(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Assigns the value to the left hand side variable
            </summary>
      <param name="LeftHandSide">Left hand side variable</param>
      <param name="Value">Value to store (may be constant or VariableBase object)</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Return(System.Object)">
      <summary>
            Returns a specified value
            </summary>
      <param name="ReturnValue">Variable to return</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Return">
      <summary>
            Returns from the method (used if void is the return type)
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Call(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Calls a function on an object
            </summary>
      <param name="ObjectCallingOn">Object calling on</param>
      <param name="MethodCalling">Method calling</param>
      <param name="Parameters">Parameters sending</param>
      <returns>The return value</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Call(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Calls a function on an object
            </summary>
      <param name="ObjectCallingOn">Object calling on</param>
      <param name="MethodCalling">Method calling</param>
      <param name="Parameters">Parameters sending</param>
      <returns>The return value</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.If(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Defines an if statement
            </summary>
      <param name="ComparisonType">Comparison type</param>
      <param name="LeftHandSide">Left hand side of the if statement</param>
      <param name="RightHandSide">Right hand side of the if statement</param>
      <returns>The if command</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.EndIf(Utilities.Reflection.Emit.Commands.If)">
      <summary>
            Defines the end of an if statement
            </summary>
      <param name="IfCommand">If command</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.While(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Defines a while statement
            </summary>
      <param name="ComparisonType">Comparison type</param>
      <param name="LeftHandSide">Left hand side of the while statement</param>
      <param name="RightHandSide">Right hand side of the while statement</param>
      <returns>The while command</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.EndWhile(Utilities.Reflection.Emit.Commands.While)">
      <summary>
            Defines the end of a while statement
            </summary>
      <param name="WhileCommand">While command</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Add(System.Object,System.Object)">
      <summary>
            Adds two variables and returns the result
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Subtract(System.Object,System.Object)">
      <summary>
            Subtracts two variables and returns the result
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Multiply(System.Object,System.Object)">
      <summary>
            Multiplies two variables and returns the result
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Divide(System.Object,System.Object)">
      <summary>
            Divides two variables and returns the result
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Modulo(System.Object,System.Object)">
      <summary>
            Mods (%) two variables and returns the result
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The result</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Try">
      <summary>
            Starts a try block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Catch(System.Type)">
      <summary>
            Ends a try block and starts a catch block
            </summary>
      <param name="ExceptionType">Exception type</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.EndTry">
      <summary>
            Ends a try/catch block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Box(System.Object)">
      <summary>
            Boxes a value
            </summary>
      <param name="Value">Value to box</param>
      <returns>The resulting boxed variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.UnBox(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Type)">
      <summary>
            Unboxes a value
            </summary>
      <param name="Value">Value to unbox</param>
      <param name="ValueType">Type to unbox to</param>
      <returns>The resulting unboxed variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Cast(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Type)">
      <summary>
            Casts an object to another type
            </summary>
      <param name="Value">Value to cast</param>
      <param name="ValueType">Value type to cast to</param>
      <returns>The resulting casted value</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Throw(Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Throws an exception
            </summary>
      <param name="Exception">Exception to throw</param>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Name">
      <summary>
            Method name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.ReturnType">
      <summary>
            Return type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Parameters">
      <summary>
            Parameters
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Attributes">
      <summary>
            Attributes for the method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.Generator">
      <summary>
            IL generator for this method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IMethodBuilder.This">
      <summary>
            Returns the this object for this object
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.CreateLocal(System.String,System.Type)">
      <summary>
            Creates a local variable
            </summary>
      <param name="Name">Name of the local</param>
      <param name="LocalType">Object type</param>
      <returns>The variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.CreateConstant(System.Object)">
      <summary>
            Creates a constant
            </summary>
      <param name="Value">Constant value</param>
      <returns>The constant</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.NewObj(System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Creates a new object
            </summary>
      <param name="Constructor">Constructor to use</param>
      <param name="Variables">Variables to use</param>
      <returns>The new object</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.NewObj(System.Type,System.Object[])">
      <summary>
            Creates a new object
            </summary>
      <param name="ObjectType">Object type</param>
      <param name="Variables">Variables to use</param>
      <returns>The new object</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Call(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Calls a method
            </summary>
      <param name="ObjectCallingOn">Object to call the method on</param>
      <param name="MethodCalling">Method to call</param>
      <param name="Parameters">Parameters to use</param>
      <returns>The result of the method call</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Call(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Calls a constructor
            </summary>
      <param name="ObjectCallingOn">Object to call the constructor on</param>
      <param name="MethodCalling">Constructor to call</param>
      <param name="Parameters">Parameters to use</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Assign(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Assigns a value to a variable
            </summary>
      <param name="LeftHandSide">Variable to assign to</param>
      <param name="Value">Value to assign</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Return(System.Object)">
      <summary>
            Returns a value back from the method
            </summary>
      <param name="ReturnValue">Value to return</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Return">
      <summary>
            Returns from the method
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.If(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Creates an if statement
            </summary>
      <param name="LeftHandSide">Left hand side variable</param>
      <param name="ComparisonType">Comparison type</param>
      <param name="RightHandSide">Right hand side variable</param>
      <returns>The if object</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.EndIf(Utilities.Reflection.Emit.Commands.If)">
      <summary>
            Ends an if statement
            </summary>
      <param name="IfCommand">If command to end</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.While(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Creates a while statement
            </summary>
      <param name="LeftHandSide">Left hand side variable</param>
      <param name="ComparisonType">Comparison type</param>
      <param name="RightHandSide">Right hand side variable</param>
      <returns>The while object</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.EndWhile(Utilities.Reflection.Emit.Commands.While)">
      <summary>
            Ends a while statement
            </summary>
      <param name="WhileCommand">While statement to end</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Add(System.Object,System.Object)">
      <summary>
            Adds two objects
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Subtract(System.Object,System.Object)">
      <summary>
            Subtracts two objects
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Multiply(System.Object,System.Object)">
      <summary>
            Multiply two objects
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Divide(System.Object,System.Object)">
      <summary>
            Divides two objects
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Modulo(System.Object,System.Object)">
      <summary>
            Modulo operator
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Try">
      <summary>
            Starts a try block
            </summary>
      <returns>The resulting try block</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Catch(System.Type)">
      <summary>
            Starts a catch block
            </summary>
      <param name="ExceptionType">Exception type to catch</param>
      <returns>The resulting catch block</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.EndTry">
      <summary>
            Ends a try block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Box(System.Object)">
      <summary>
            Boxes an object
            </summary>
      <param name="Value">Variable to box</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.UnBox(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Type)">
      <summary>
            Unboxes an object
            </summary>
      <param name="Value">Value to unbox</param>
      <param name="ValueType">Type to unbox to</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Cast(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Type)">
      <summary>
            Casts an object as a specific type
            </summary>
      <param name="Value">Value to cast</param>
      <param name="ValueType">Type to cast to</param>
      <returns>The resulting variable</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.Throw(Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Throws an exception
            </summary>
      <param name="Exception">Exception to throw</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.MethodBase.SetCurrentMethod">
      <summary>
            Sets the current method to this
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.Name">
      <summary>
            Name of the method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.ReturnType">
      <summary>
            Return type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.Parameters">
      <summary>
            Parameters
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.Attributes">
      <summary>
            Attributes for the method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.Generator">
      <summary>
            IL Generator for the method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod">
      <summary>
            Current method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.Commands">
      <summary>
            Commands used in the method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.ObjectCounter">
      <summary>
            Object counter
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.MethodBase.This">
      <summary>
            The this object
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.BaseClasses.VariableBase">
      <summary>
            Variable base class
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Assign(System.Object)">
      <summary>
            Assigns the value to the variable
            </summary>
      <param name="Value">Value to assign</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads the variable onto the stack
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves the top item from the stack onto the variable
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.GetDefinition">
      <summary>
            Gets the definition of the variable
            </summary>
      <returns />
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Call(System.String,System.Object[])">
      <summary>
            Calls a method on this variable
            </summary>
      <param name="MethodName">Method name</param>
      <param name="Parameters">Parameters sent in</param>
      <returns>Variable returned by the function (if one exists, null otherwise)</returns>
      <requires description="MethodName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(MethodName)" vb="Not IsNullOrEmpty(MethodName)">!string.IsNullOrEmpty(MethodName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(MethodName)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Call(Utilities.Reflection.Emit.MethodBuilder,System.Object[])">
      <summary>
            Calls a method on this variable
            </summary>
      <param name="Method">Method</param>
      <param name="Parameters">Parameters sent in</param>
      <returns>Variable returned by the function (if one exists, null otherwise)</returns>
      <requires description="Method" exception="T:System.ArgumentNullException" csharp="Method != null" vb="Method &lt;&gt; Nothing">Method != null</requires>
      <exception cref="T:System.ArgumentNullException">Method == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Call(System.Reflection.Emit.MethodBuilder,System.Object[])">
      <summary>
            Calls a method on this variable
            </summary>
      <param name="Method">Method</param>
      <param name="Parameters">Parameters sent in</param>
      <returns>Variable returned by the function (if one exists, null otherwise)</returns>
      <requires description="Method" exception="T:System.ArgumentNullException" csharp="Method != (System.Reflection.MethodInfo)null" vb="Method &lt;&gt; ((System.Reflection.MethodInfo)Nothing) ">Method != (System.Reflection.MethodInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Method != (System.Reflection.MethodInfo)null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Call(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Calls a method on this variable
            </summary>
      <param name="Method">Method</param>
      <param name="Parameters">Parameters sent in</param>
      <returns>Variable returned by the function (if one exists, null otherwise)</returns>
      <requires description="Method" exception="T:System.ArgumentNullException" csharp="Method != (System.Reflection.MethodInfo)null" vb="Method &lt;&gt; ((System.Reflection.MethodInfo)Nothing) ">Method != (System.Reflection.MethodInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Method != (System.Reflection.MethodInfo)null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Call(System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Calls a method on this variable
            </summary>
      <param name="Method">Method</param>
      <param name="Parameters">Parameters sent in</param>
      <returns>Variable returned by the function (if one exists, null otherwise)</returns>
      <requires description="Method" exception="T:System.ArgumentNullException" csharp="Method != (System.Reflection.ConstructorInfo)null" vb="Method &lt;&gt; ((System.Reflection.ConstructorInfo)Nothing) ">Method != (System.Reflection.ConstructorInfo)null</requires>
      <exception cref="T:System.ArgumentNullException">!Method != (System.Reflection.ConstructorInfo)null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.Call(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.Object[])">
      <summary>
            Calls a method on this variable
            </summary>
      <param name="Method">Method</param>
      <param name="Parameters">Parameters sent in</param>
      <returns>Variable returned by the function (if one exists, null otherwise)</returns>
      <requires description="Method" exception="T:System.ArgumentNullException" csharp="Method != null" vb="Method &lt;&gt; Nothing">Method != null</requires>
      <exception cref="T:System.ArgumentNullException">Method == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Addition(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Addition operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Subtraction(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Subtraction operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Multiply(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Multiplication operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Division(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Division operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Modulus(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Modulo operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Addition(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Addition operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Subtraction(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Subtraction operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Multiply(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Multiplication operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Division(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Division operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Modulus(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Modulo operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Addition(System.Object,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Addition operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Subtraction(System.Object,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Subtraction operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Multiply(System.Object,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Multiplication operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Division(System.Object,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Division operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Modulus(System.Object,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Modulo operator
            </summary>
      <param name="Left">Left side</param>
      <param name="Right">Right side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Increment(Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Plus one operator
            </summary>
      <param name="Left">Left side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.BaseClasses.VariableBase.op_Decrement(Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Subtract one operator
            </summary>
      <param name="Left">Left side</param>
      <returns>The resulting object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.VariableBase.Name">
      <summary>
            Variable name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.BaseClasses.VariableBase.DataType">
      <summary>
            Variable data type
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Add">
      <summary>
            Adds two variables
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Add.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="LeftHandSide">Left variable</param>
      <param name="RightHandSide">Right variable</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Add.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Add.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Add.LeftHandSide">
      <summary>
            Left hand side of the addition
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Add.RightHandSide">
      <summary>
            Right hand side of the addition
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Assign">
      <summary>
            Assignment command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Assign.#ctor(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="LeftHandSide">Left hand side</param>
      <param name="Value">Value to store</param>
      <requires description="LeftHandSide" exception="T:System.ArgumentNullException" csharp="LeftHandSide != null" vb="LeftHandSide &lt;&gt; Nothing">LeftHandSide != null</requires>
      <exception cref="T:System.ArgumentNullException">LeftHandSide == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Assign.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Assign.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Assign.LeftHandSide">
      <summary>
            Left hand side of the assignment
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Assign.RightHandSide">
      <summary>
            Value to assign
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Box">
      <summary>
            Boxes an object
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Box.#ctor(System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to box</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Box.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Box.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Box.Value">
      <summary>
            Value to box
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Call">
      <summary>
            Call command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Call.#ctor(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="ObjectCallingOn">Object calling on</param>
      <param name="Method">Method builder</param>
      <param name="MethodCalling">Method calling on the object</param>
      <param name="Parameters">List of parameters to send in</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Call.#ctor(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="ObjectCallingOn">Object calling on</param>
      <param name="Method">Method builder</param>
      <param name="MethodCalling">Method calling on the object</param>
      <param name="Parameters">List of parameters to send in</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Call.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Call.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Call.ObjectCallingOn">
      <summary>
            Object calling on
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Call.MethodCalling">
      <summary>
            Method calling
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Call.ConstructorCalling">
      <summary>
            Method calling
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Call.Parameters">
      <summary>
            Parameters sent in
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Call.MethodCallingFrom">
      <summary>
            Method calling from
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Cast">
      <summary>
            Casts a class object to another class
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Cast.#ctor(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to cast</param>
      <param name="ValueType">Desired type to cast to</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Cast.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Cast.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Cast.Value">
      <summary>
            Value to cast
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Cast.ValueType">
      <summary>
            Desired type to cast to
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Catch">
      <summary>
            Catch block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Catch.#ctor(System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="ExceptionType">Exception type</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Catch.Rethrow">
      <summary>
            Rethrows the error
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Catch.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Catch.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Catch.Exception">
      <summary>
            Exception caught in exception block
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Catch.ExceptionType">
      <summary>
            Exception type
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.DefineLocal">
      <summary>
            Defines a local variable
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.DefineLocal.#ctor(System.String,System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Local object name</param>
      <param name="LocalType">Local type</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.DefineLocal.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.DefineLocal.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Divide">
      <summary>
            Divide two variables
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Divide.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="LeftHandSide">Left variable</param>
      <param name="RightHandSide">Right variable</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Divide.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Divide.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Divide.LeftHandSide">
      <summary>
            Left hand side of the division
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Divide.RightHandSide">
      <summary>
            Right hand side of the division
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Else">
      <summary>
            Else command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Else.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Else.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Else.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.ElseIf">
      <summary>
            Else if command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.ElseIf.#ctor(System.Reflection.Emit.Label,Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Constructor
            </summary>
      <param name="EndIfLabel">End if label (for this else if)</param>
      <param name="ComparisonType">Comparison type</param>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.ElseIf.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.ElseIf.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.ElseIf.EndIfLabel">
      <summary>
            End if label
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.ElseIf.LeftHandSide">
      <summary>
            Left hand side of the comparison
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.ElseIf.RightHandSide">
      <summary>
            Right hand side of the comparison
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.ElseIf.ComparisonType">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.EndIf">
      <summary>
            End If command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndIf.#ctor(Utilities.Reflection.Emit.Commands.If)">
      <summary>
            Constructor
            </summary>
      <param name="IfCommand">If command</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndIf.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndIf.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.EndIf.IfCommand">
      <summary>
            If command
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.EndTry">
      <summary>
            Ends a try/catch block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndTry.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndTry.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndTry.ToString">
      <summary>
            To string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.EndWhile">
      <summary>
            End While command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndWhile.#ctor(Utilities.Reflection.Emit.Commands.While)">
      <summary>
            Constructor
            </summary>
      <param name="WhileCommand">While command</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndWhile.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.EndWhile.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.EndWhile.WhileCommand">
      <summary>
            While command
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.If">
      <summary>
            If command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.If.#ctor(Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Constructor
            </summary>
      <param name="ComparisonType">Comparison type</param>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.If.EndIf">
      <summary>
            Ends the if statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.If.ElseIf(Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Defines an else if statement
            </summary>
      <param name="ComparisonType">Comparison type</param>
      <param name="LeftHandSide">left hand side value</param>
      <param name="RightHandSide">right hand side value</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.If.Else">
      <summary>
            Defines an else statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.If.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.If.ToString">
      <summary>
            Converts the command to the string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.If.EndIfLabel">
      <summary>
            End if label
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.If.EndIfFinalLabel">
      <summary>
            End if label
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.If.LeftHandSide">
      <summary>
            Left hand side of the comparison
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.If.RightHandSide">
      <summary>
            Right hand side of the comparison
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.If.ComparisonType">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Modulo">
      <summary>
            Mods two variables
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Modulo.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="LeftHandSide">Left variable</param>
      <param name="RightHandSide">Right variable</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Modulo.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Modulo.ToString">
      <summary>
            Converts the command to the string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Modulo.LeftHandSide">
      <summary>
            Left hand side of the modulo
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Modulo.RightHandSide">
      <summary>
            Right hand side of the modulo
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Multiply">
      <summary>
            Multiply two variables
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Multiply.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="LeftHandSide">Left variable</param>
      <param name="RightHandSide">Right variable</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Multiply.Setup">
      <summary>
            Set up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Multiply.ToString">
      <summary>
            Converts the command to the string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Multiply.LeftHandSide">
      <summary>
            Left hand side of the multiplication
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Multiply.RightHandSide">
      <summary>
            Right hand side of the multiplication
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.NewObj">
      <summary>
            Command for creating a new object
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.NewObj.#ctor(System.Reflection.ConstructorInfo,System.Object[])">
      <summary>
            Constructor
            </summary>
      <param name="Constructor">Constructor to use</param>
      <param name="Parameters">Variables sent to the constructor</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.NewObj.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.NewObj.ToString">
      <summary>
            Converts the command to the string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.NewObj.Constructor">
      <summary>
            Constructor used
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.NewObj.Parameters">
      <summary>
            Variables sent to the Constructor
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Return">
      <summary>
            Return command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Return.#ctor(System.Type,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="ReturnType">Return type</param>
      <param name="ReturnValue">Return value</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Return.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Return.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Return.ReturnType">
      <summary>
            Return type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Return.ReturnValue">
      <summary>
            Return value
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Subtract">
      <summary>
            Subtracts two variables
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Subtract.#ctor(System.Object,System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="LeftHandSide">Left variable</param>
      <param name="RightHandSide">Right variable</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Subtract.Setup">
      <summary>
            Sets up the command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Subtract.ToString">
      <summary>
            Converts the command to a string
            </summary>
      <returns>The string version of the command</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Subtract.LeftHandSide">
      <summary>
            Left hand side of the subtraction
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Subtract.RightHandSide">
      <summary>
            Right hand side of the subtraction
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Throw">
      <summary>
            Throws an exception
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Throw.#ctor(Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Constructor
            </summary>
      <param name="Exception">Exception to throw</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Throw.Setup">
      <summary>
            Sets up the throw statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Throw.ToString">
      <summary>
            The throw statement as a string
            </summary>
      <returns>The throw statement as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.Throw.Exception">
      <summary>
            Exception to throw
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.Try">
      <summary>
            Starts a try block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Try.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Try.StartCatchBlock(System.Type)">
      <summary>
            Ends the try and starts a catch block
            </summary>
      <param name="ExceptionType">Exception type</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Try.EndTryBlock">
      <summary>
            Ends the try/catch block
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Try.Setup">
      <summary>
            Sets up the try statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.Try.ToString">
      <summary>
            The try statement as a string
            </summary>
      <returns>The try statement as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.UnBox">
      <summary>
            Unboxes an object
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.UnBox.#ctor(Utilities.Reflection.Emit.BaseClasses.VariableBase,System.Type)">
      <summary>
            Unboxes a value to a specified type
            </summary>
      <param name="Value">Value to unbox</param>
      <param name="ValueType">Value type</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.UnBox.Setup">
      <summary>
            Sets up the unbox statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.UnBox.ToString">
      <summary>
            Unbox statement as a string
            </summary>
      <returns>The unbox statement as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.UnBox.Value">
      <summary>
            Value to unbox
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.UnBox.ValueType">
      <summary>
            Value type to unbox to
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Commands.While">
      <summary>
            While command
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.While.#ctor(Utilities.Reflection.Emit.Enums.Comparison,Utilities.Reflection.Emit.BaseClasses.VariableBase,Utilities.Reflection.Emit.BaseClasses.VariableBase)">
      <summary>
            Constructor
            </summary>
      <param name="ComparisonType">Comparison type</param>
      <param name="LeftHandSide">Left hand side</param>
      <param name="RightHandSide">Right hand side</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.While.EndWhile">
      <summary>
            Ends the while statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.While.Setup">
      <summary>
            Sets up the while statement
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Commands.While.ToString">
      <summary>
            The while statement as a string
            </summary>
      <returns>The string representation of the while statement</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.While.StartWhileLabel">
      <summary>
            Start while label
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.While.EndWhileLabel">
      <summary>
            End while label
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.While.LeftHandSide">
      <summary>
            Left hand side of the comparison
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.While.RightHandSide">
      <summary>
            Right hand side of the comparison
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Commands.While.ComparisonType">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.ConstantBuilder">
      <summary>
            Helper class for defining a constant value
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstantBuilder.#ctor(System.Object)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value of the constant</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstantBuilder.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves the constant
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstantBuilder.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads the constant
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstantBuilder.GetDefinition">
      <summary>
            Get the definition of the constant
            </summary>
      <returns>The definition of the constant</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstantBuilder.ToString">
      <summary>
            The definition of the constant as a string
            </summary>
      <returns>The constant as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.ConstantBuilder.Value">
      <summary>
            Value of the constant
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.ConstructorBuilder">
      <summary>
            Helper class for defining/creating constructors
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstructorBuilder.#ctor(Utilities.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes,System.Collections.Generic.IEnumerable{System.Type},System.Reflection.CallingConventions)">
      <summary>
            Constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Attributes">Attributes for the constructor (public, private, etc.)</param>
      <param name="Parameters">Parameter types for the constructor</param>
      <param name="CallingConventions">Calling convention for the constructor</param>
      <requires description="TypeBuilder" exception="T:System.ArgumentNullException" csharp="TypeBuilder != null" vb="TypeBuilder &lt;&gt; Nothing">TypeBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">TypeBuilder == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.ConstructorBuilder.ToString">
      <summary>
            The definition of the constructor as a string
            </summary>
      <returns>The constructor as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.ConstructorBuilder.CallingConventions">
      <summary>
            Calling conventions for the constructor
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.ConstructorBuilder.Builder">
      <summary>
            Constructor builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.ConstructorBuilder.Type">
      <summary>
            Type builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.DefaultConstructorBuilder">
      <summary>
            Helper class for defining/creating default constructors
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultConstructorBuilder.#ctor(Utilities.Reflection.Emit.TypeBuilder,System.Reflection.MethodAttributes)">
      <summary>
            Constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Attributes">Attributes for the constructor (public, private, etc.)</param>
      <requires description="TypeBuilder" exception="T:System.ArgumentNullException" csharp="TypeBuilder != null" vb="TypeBuilder &lt;&gt; Nothing">TypeBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">TypeBuilder == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultConstructorBuilder.ToString">
      <summary>
            The constructor definition as a string
            </summary>
      <returns>The constructor as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultConstructorBuilder.CallingConventions">
      <summary>
            Calling conventions for the constructor
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultConstructorBuilder.Builder">
      <summary>
            Constructor builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultConstructorBuilder.Type">
      <summary>
            Type builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.DefaultPropertyBuilder">
      <summary>
            Helper class for defining default properties
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder">
      <summary>
            Interface for properties
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.GetDefinition">
      <summary>
            Gets the definition of the variable
            </summary>
      <returns>string representation of the variable definition</returns>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.Name">
      <summary>
            Property name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.DataType">
      <summary>
            Data type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.Builder">
      <summary>
            Property builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.Attributes">
      <summary>
            Attributes for the property
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.GetMethodAttributes">
      <summary>
            Attributes for the get method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.SetMethodAttributes">
      <summary>
            Attributes for the set method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.GetMethod">
      <summary>
            Method builder for the get method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.Interfaces.IPropertyBuilder.SetMethod">
      <summary>
            Method builder for the set method
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.#ctor(Utilities.Reflection.Emit.TypeBuilder,System.String,System.Reflection.PropertyAttributes,System.Reflection.MethodAttributes,System.Reflection.MethodAttributes,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Name">Name of the property</param>
      <param name="Attributes">Attributes for the property (public, private, etc.)</param>
      <param name="GetMethodAttributes">Get method attributes</param>
      <param name="SetMethodAttributes">Set method attributes</param>
      <param name="PropertyType">Property type for the property</param>
      <param name="Parameters">Parameter types for the property</param>
      <requires description="TypeBuilder" exception="T:System.ArgumentNullException" csharp="TypeBuilder != null" vb="TypeBuilder &lt;&gt; Nothing">TypeBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">TypeBuilder == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads the property
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves the property
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.GetDefinition">
      <summary>
            Gets the definition of the property
            </summary>
      <returns>The definition of the property</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.ToString">
      <summary>
            property as a string
            </summary>
      <returns>Property as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.op_Increment(Utilities.Reflection.Emit.DefaultPropertyBuilder)">
      <summary>
            Increments the property by one
            </summary>
      <param name="Left">The property to increment</param>
      <returns>The property</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.DefaultPropertyBuilder.op_Decrement(Utilities.Reflection.Emit.DefaultPropertyBuilder)">
      <summary>
            Decrements the property by one
            </summary>
      <param name="Left">The property to decrement</param>
      <returns>The property</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.Parameters">
      <summary>
            Parameter types
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.Builder">
      <summary>
            Method builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.Attributes">
      <summary>
            Attributes for the property
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.GetMethodAttributes">
      <summary>
            Attributes for the get method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.SetMethodAttributes">
      <summary>
            Attributes for the set method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.GetMethod">
      <summary>
            Method builder for the get method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.SetMethod">
      <summary>
            Method builder for the set method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.Field">
      <summary>
            Field builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.DefaultPropertyBuilder.Type">
      <summary>
            Type builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.EnumBuilder">
      <summary>
            Helper class for defining enums
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Interfaces.IType">
      <summary>
            Type interface
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.Interfaces.IType.Create">
      <summary>
            Creates the type
            </summary>
      <returns>The generated type defined by the object</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.EnumBuilder.#ctor(Utilities.Reflection.Emit.Assembly,System.String,System.Type,System.Reflection.TypeAttributes)">
      <summary>
            Constructor
            </summary>
      <param name="Assembly">Assembly builder</param>
      <param name="Name">Name of the enum</param>
      <param name="Attributes">Attributes for the enum (public, private, etc.)</param>
      <param name="EnumType">Type for the enum</param>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != null" vb="Assembly &lt;&gt; Nothing">Assembly != null</requires>
      <exception cref="T:System.ArgumentNullException">Assembly == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.EnumBuilder.AddLiteral(System.String,System.Object)">
      <summary>
            Adds a literal to the enum (an entry)
            </summary>
      <param name="Name">Name of the entry</param>
      <param name="Value">Value associated with it</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.EnumBuilder.Create">
      <summary>
            Creates the enum
            </summary>
      <returns>The type defined by this EnumBuilder</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.EnumBuilder.ToString">
      <summary>
            Enum definition as a string
            </summary>
      <returns>The enum as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.Name">
      <summary>
            Field name
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.Literals">
      <summary>
            Literals defined within the enum
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.Builder">
      <summary>
            Field builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.EnumType">
      <summary>
            Base enum type (int32, etc.)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.DefinedType">
      <summary>
            Type defined by this enum
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.Attributes">
      <summary>
            Attributes for the enum (private, public, etc.)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.EnumBuilder.Assembly">
      <summary>
            Assembly builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Enums.AssemblyType">
      <summary>
            Assembly type
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.AssemblyType.DLL">
      <summary>
            DLL assembly
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.AssemblyType.EXE">
      <summary>
            EXE assembly
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.Enums.Comparison">
      <summary>
            Comparison type
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.Comparison.Equal">
      <summary>
            Equal
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.Comparison.NotEqual">
      <summary>
            Not equal
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.Comparison.LessThan">
      <summary>
            Less than
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.Comparison.GreaterThan">
      <summary>
            Greater than
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.Comparison.LessThanOrEqual">
      <summary>
            Less than or equal
            </summary>
    </member>
    <member name="F:Utilities.Reflection.Emit.Enums.Comparison.GreaterThenOrEqual">
      <summary>
            Greater than or equal
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.FieldBuilder">
      <summary>
            Helper class for defining a field within a type
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.#ctor(Utilities.Reflection.Emit.TypeBuilder,System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>
            Constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Name">Name of the method</param>
      <param name="Attributes">Attributes for the field (public, private, etc.)</param>
      <param name="FieldType">Type for the field</param>
      <requires description="TypeBuilder" exception="T:System.ArgumentNullException" csharp="TypeBuilder != null" vb="TypeBuilder &lt;&gt; Nothing">TypeBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">TypeBuilder == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads the field
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves the field
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.GetDefinition">
      <summary>
            Gets the definition of the field
            </summary>
      <returns>The field's definition</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.ToString">
      <summary>
            The field as a string
            </summary>
      <returns>The field as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.op_Increment(Utilities.Reflection.Emit.FieldBuilder)">
      <summary>
            Increments the field by one
            </summary>
      <param name="Left">Field to increment</param>
      <returns>The field</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.FieldBuilder.op_Decrement(Utilities.Reflection.Emit.FieldBuilder)">
      <summary>
            Decrements the field by one
            </summary>
      <param name="Left">Field to decrement</param>
      <returns>The field</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="P:Utilities.Reflection.Emit.FieldBuilder.Builder">
      <summary>
            Field builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.FieldBuilder.Attributes">
      <summary>
            Attributes for the field (private, public, etc.)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.FieldBuilder.Type">
      <summary>
            Type builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.LocalBuilder">
      <summary>
            Helper class for defining a local variable
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.LocalBuilder.#ctor(Utilities.Reflection.Emit.Interfaces.IMethodBuilder,System.String,System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="MethodBuilder">Method builder</param>
      <param name="Name">Name of the local</param>
      <param name="LocalType">Type of the local</param>
      <requires description="MethodBuilder" exception="T:System.ArgumentNullException" csharp="MethodBuilder != null" vb="MethodBuilder &lt;&gt; Nothing">MethodBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">MethodBuilder == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.LocalBuilder.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads the local object
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.LocalBuilder.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves the local object
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.LocalBuilder.ToString">
      <summary>
            The local item as a string
            </summary>
      <returns>The local item as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Reflection.Emit.LocalBuilder.op_Increment(Utilities.Reflection.Emit.LocalBuilder)">
      <summary>
            Increments the local object by one
            </summary>
      <param name="Left">Local object to increment</param>
      <returns>The local object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.LocalBuilder.op_Decrement(Utilities.Reflection.Emit.LocalBuilder)">
      <summary>
            Decrements the local object by one
            </summary>
      <param name="Left">Local object to decrement</param>
      <returns>The local object</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="P:Utilities.Reflection.Emit.LocalBuilder.Builder">
      <summary>
            Local builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.LocalBuilder.MethodBuilder">
      <summary>
            Method builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.MethodBuilder">
      <summary>
            Helper class for defining a method within a type
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.MethodBuilder.#ctor(Utilities.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes,System.Collections.Generic.IEnumerable{System.Type},System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Name">Name of the method</param>
      <param name="Attributes">Attributes for the method (public, private, etc.)</param>
      <param name="Parameters">Parameter types for the method</param>
      <param name="ReturnType">Return type for the method</param>
      <requires description="TypeBuilder" exception="T:System.ArgumentNullException" csharp="TypeBuilder != null" vb="TypeBuilder &lt;&gt; Nothing">TypeBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">TypeBuilder == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.MethodBuilder.ToString">
      <summary>
            Outputs the method to a string
            </summary>
      <returns>The string representation of the method</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.MethodBuilder.Builder">
      <summary>
            Method builder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.MethodBuilder.Type">
      <summary>
            Type builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.ParameterBuilder">
      <summary>
            Used to define a parameter
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.ParameterBuilder.#ctor(System.Type,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="ParameterType">Parameter type</param>
      <param name="Number">Position in parameter order</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.ParameterBuilder.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads from the parameter
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.ParameterBuilder.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves to the parameter
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.ParameterBuilder.ToString">
      <summary>
            Outputs the parameter as a string
            </summary>
      <returns>The parameter</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Reflection.Emit.ParameterBuilder.op_Increment(Utilities.Reflection.Emit.ParameterBuilder)">
      <summary>
            Increments by one
            </summary>
      <param name="Left">Parameter to increment</param>
      <returns>The parameter</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.ParameterBuilder.op_Decrement(Utilities.Reflection.Emit.ParameterBuilder)">
      <summary>
            Decrements by one
            </summary>
      <param name="Left">Parameter to decrement</param>
      <returns>The parameter</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="P:Utilities.Reflection.Emit.ParameterBuilder.Number">
      <summary>
            Order in the parameter list
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.PropertyBuilder">
      <summary>
            Helper class for defining a property
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.#ctor(Utilities.Reflection.Emit.TypeBuilder,System.String,System.Reflection.PropertyAttributes,System.Reflection.MethodAttributes,System.Reflection.MethodAttributes,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Constructor
            </summary>
      <param name="TypeBuilder">Type builder</param>
      <param name="Name">Name of the property</param>
      <param name="Attributes">Attributes for the property (public, private, etc.)</param>
      <param name="GetMethodAttributes">Get method attributes</param>
      <param name="SetMethodAttributes">Set method attributes</param>
      <param name="PropertyType">Property type for the property</param>
      <param name="Parameters">Parameter types for the property</param>
      <requires description="TypeBuilder" exception="T:System.ArgumentNullException" csharp="TypeBuilder != null" vb="TypeBuilder &lt;&gt; Nothing">TypeBuilder != null</requires>
      <exception cref="T:System.ArgumentNullException">TypeBuilder == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.Load(System.Reflection.Emit.ILGenerator)">
      <summary>
            Loads a property
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.Save(System.Reflection.Emit.ILGenerator)">
      <summary>
            Saves the property
            </summary>
      <param name="Generator">IL Generator</param>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.GetDefinition">
      <summary>
            Gets the definition
            </summary>
      <returns>String version of what this object generates</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.ToString">
      <summary>
            Returns the property name
            </summary>
      <returns>The property name</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.op_Increment(Utilities.Reflection.Emit.PropertyBuilder)">
      <summary>
            Adds one to the property
            </summary>
      <param name="Left">Property object</param>
      <returns>The property builder</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.PropertyBuilder.op_Decrement(Utilities.Reflection.Emit.PropertyBuilder)">
      <summary>
            Subtracts one from the property builder
            </summary>
      <param name="Left">Property builder</param>
      <returns>The property builder</returns>
      <requires description="Unsure which method is the current method" exception="T:System.InvalidOperationException" csharp="CurrentMethod != null" vb="CurrentMethod &lt;&gt; Nothing">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod != null</requires>
      <exception cref="T:System.InvalidOperationException">Utilities.Reflection.Emit.BaseClasses.MethodBase.CurrentMethod == null</exception>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.Parameters">
      <summary>
            Parameter list
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.Builder">
      <summary>
            Builder object
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.Attributes">
      <summary>
            Attribute object
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.GetMethodAttributes">
      <summary>
            Get method attributes
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.SetMethodAttributes">
      <summary>
            Set method attributes
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.GetMethod">
      <summary>
            Get method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.SetMethod">
      <summary>
            Set method
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.PropertyBuilder.Type">
      <summary>
            Type builder
            </summary>
    </member>
    <member name="T:Utilities.Reflection.Emit.TypeBuilder">
      <summary>
            Helper class for defining types
            </summary>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.#ctor(Utilities.Reflection.Emit.Assembly,System.String,System.Collections.Generic.IEnumerable{System.Type},System.Type,System.Reflection.TypeAttributes)">
      <summary>
            Constructor
            </summary>
      <param name="Assembly">Assembly to generate the type within</param>
      <param name="Name">Name of the type</param>
      <param name="Interfaces">Interfaces that the type implements</param>
      <param name="Attributes">Attributes for the type (public, private, etc.)</param>
      <param name="BaseClass">Base class for the type</param>
      <requires description="Assembly" exception="T:System.ArgumentNullException" csharp="Assembly != null" vb="Assembly &lt;&gt; Nothing">Assembly != null</requires>
      <exception cref="T:System.ArgumentNullException">Assembly == null</exception>
      <requires description="Name" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Name)" vb="Not IsNullOrEmpty(Name)">!string.IsNullOrEmpty(Name)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Name)</exception>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.Create">
      <summary>
            Creates the type
            </summary>
      <returns>The type defined by this TypeBuilder</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.CreateMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Creates a method
            </summary>
      <param name="Name">Method name</param>
      <param name="Attributes">Attributes for the method (public, virtual, etc.)</param>
      <param name="ReturnType">Return type</param>
      <param name="ParameterTypes">Parameter types</param>
      <returns>Method builder for the method</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.CreateField(System.String,System.Type,System.Reflection.FieldAttributes)">
      <summary>
            Creates a field
            </summary>
      <param name="Name">Name of the field</param>
      <param name="FieldType">Type of the field</param>
      <param name="Attributes">Attributes for the field (public, private, etc.)</param>
      <returns>Field builder for the field</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.CreateProperty(System.String,System.Type,System.Reflection.PropertyAttributes,System.Reflection.MethodAttributes,System.Reflection.MethodAttributes,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Creates a property
            </summary>
      <param name="Name">Name of the property</param>
      <param name="PropertyType">Type of the property</param>
      <param name="Attributes">Attributes for the property (special name, etc.)</param>
      <param name="GetMethodAttributes">Get method's attributes (public, private, etc.)</param>
      <param name="SetMethodAttributes">Set method's attributes (public, private, etc.)</param>
      <param name="Parameters">Parameter types</param>
      <returns>Property builder for the property</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.CreateDefaultProperty(System.String,System.Type,System.Reflection.PropertyAttributes,System.Reflection.MethodAttributes,System.Reflection.MethodAttributes,System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Creates a default property (ex int Property{get;set;}
            </summary>
      <param name="Name">Name of the property</param>
      <param name="PropertyType">Type of the property</param>
      <param name="Attributes">Attributes for the property (special name, etc.)</param>
      <param name="GetMethodAttributes">Get method's attributes (public, private, etc.)</param>
      <param name="SetMethodAttributes">Set method's attributes (public, private, etc.)</param>
      <param name="Parameters">Parameter types</param>
      <returns>Property builder for the property</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.CreateConstructor(System.Reflection.MethodAttributes,System.Collections.Generic.IEnumerable{System.Type},System.Reflection.CallingConventions)">
      <summary>
            Creates a constructor
            </summary>
      <param name="Attributes">Attributes for the constructor (public, private, etc.)</param>
      <param name="ParameterTypes">The types for the parameters</param>
      <param name="CallingConventions">The calling convention used</param>
      <returns>Constructor builder for the constructor</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.CreateDefaultConstructor(System.Reflection.MethodAttributes)">
      <summary>
            Creates a default constructor
            </summary>
      <param name="Attributes">Attributes for the constructor (public, private, etc.)</param>
      <returns>Constructor builder for the constructor</returns>
    </member>
    <member name="M:Utilities.Reflection.Emit.TypeBuilder.ToString">
      <summary>
            Writes out the type builder to a readable string
            </summary>
      <returns>Code version of the type builder</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.DefinedType">
      <summary>
            The type defined by this TypeBuilder (filled once Create is called)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Methods">
      <summary>
            List of methods defined by this TypeBuilder 
            (does not include methods defined in base classes unless overridden)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Fields">
      <summary>
            List of fields defined by the TypeBuilder
            (does not include fields defined in base classes)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Properties">
      <summary>
            List of properties defined by the TypeBuilder
            (does not include properties defined in base classes)
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Constructors">
      <summary>
            Constructors defined by the TypeBuilder
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Interfaces">
      <summary>
            List of interfaces used by this type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.BaseClass">
      <summary>
            Base class used by this type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Builder">
      <summary>
            Builder used by this type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Attributes">
      <summary>
            TypeAttributes for this type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Name">
      <summary>
            Name of this type
            </summary>
    </member>
    <member name="P:Utilities.Reflection.Emit.TypeBuilder.Assembly">
      <summary>
            Assembly builder
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Column`1">
      <summary>
            Column class
            </summary>
      <typeparam name="T">Data type of the column</typeparam>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Column`1.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Column`1.#ctor(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,`0,System.Boolean,System.Boolean,System.Boolean,Utilities.SQL.DataClasses.Interfaces.ITable)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the column</param>
      <param name="ColumnType">The data type</param>
      <param name="Length">The data length</param>
      <param name="Nullable">Is it nullable?</param>
      <param name="Identity">Is it an identity?</param>
      <param name="Index">Is it the index?</param>
      <param name="PrimaryKey">Is it the primary key?</param>
      <param name="Unique">Is it unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="ParentTable">Parent table</param>
      <param name="OnDeleteCascade">Cascade on delete</param>
      <param name="OnDeleteSetNull">Set null on delete</param>
      <param name="OnUpdateCascade">Cascade on update</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Column`1.AddForeignKey(System.String,System.String)">
      <summary>
            Add foreign key
            </summary>
      <param name="ForeignKeyTable">Table of the foreign key</param>
      <param name="ForeignKeyColumn">Column of the foreign key</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Column`1.SetupForeignKeys">
      <summary>
            Sets up the foreign key list
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.OnDeleteCascade">
      <summary>
            On Delete Cascade
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.OnUpdateCascade">
      <summary>
            On Update Cascade
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.OnDeleteSetNull">
      <summary>
            On Delete Set Null
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.DataType">
      <summary>
            Data type
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.Length">
      <summary>
            Data length
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.ForeignKey">
      <summary>
            Foreign keys
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.PrimaryKey">
      <summary>
            Primary key?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.Nullable">
      <summary>
            Nullable?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.Unique">
      <summary>
            Unique?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.Index">
      <summary>
            Index?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.AutoIncrement">
      <summary>
            Auto increment?
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.Default">
      <summary>
            Default value
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Column`1.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Database">
      <summary>
            Database class
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Database.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the database</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Database.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Database.AddTable(System.String)">
      <summary>
            Adds a table to the database
            </summary>
      <param name="TableName">Table name</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Database.AddView(System.String)">
      <summary>
            Adds a view to the database
            </summary>
      <param name="ViewName">View name</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Database.AddStoredProcedure(System.String,System.String)">
      <summary>
            Adds a stored procedure to the database
            </summary>
      <param name="ProcedureName">Procedure name</param>
      <param name="Definition">Definition</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Database.AddFunction(System.String,System.String)">
      <summary>
            Adds a function to the database
            </summary>
      <param name="Name">Function name</param>
      <param name="Definition">Function definition</param>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Database.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Database.Tables">
      <summary>
            List of tables
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Database.StoredProcedures">
      <summary>
            List of stored procedures
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Database.Views">
      <summary>
            List of views
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Database.Functions">
      <summary>
            List of functions
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Database.Item(System.String)">
      <summary>
            Returns a table with the given name
            </summary>
      <param name="Name">Table name</param>
      <returns>The table specified</returns>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Enums.TriggerType">
      <summary>
            The type of trigger
            </summary>
    </member>
    <member name="F:Utilities.SQL.DataClasses.Enums.TriggerType.INSERT">
      <summary>
            Insert
            </summary>
    </member>
    <member name="F:Utilities.SQL.DataClasses.Enums.TriggerType.UPDATE">
      <summary>
            Update
            </summary>
    </member>
    <member name="F:Utilities.SQL.DataClasses.Enums.TriggerType.DELETE">
      <summary>
            Delete
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Function">
      <summary>
            Function class
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Function.#ctor(System.String,System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name of the function</param>
      <param name="Definition">Definition of the function</param>
      <param name="ParentDatabase">Parent database</param>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Function.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Function.Definition">
      <summary>
            Definition
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Function.ParentDatabase">
      <summary>
            Parent database
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Interfaces.ITable">
      <summary>
            Interface for table like structures
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.ITable.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.ITable.Columns">
      <summary>
            Columns
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Interfaces.ITable.ParentDatabase">
      <summary>
            Parent of the table structure
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.StoredProcedure">
      <summary>
            Stored Procedure
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.StoredProcedure.#ctor(System.String,System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Definition">Definition</param>
      <param name="ParentDatabase">Parent database</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.StoredProcedure.AddColumn``1(System.String,System.Data.DbType,System.Int32,``0)">
      <summary>
            Adds a column to the stored procedure (input and output properties accepted)
            </summary>
      <param name="Name">Name of the column</param>
      <param name="Type">Data type</param>
      <param name="Length">Max data length</param>
      <param name="Default">Default value</param>
    </member>
    <member name="P:Utilities.SQL.DataClasses.StoredProcedure.Name">
      <summary>
            Name of the stored procedure
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.StoredProcedure.ParentDatabase">
      <summary>
            Parent database
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.StoredProcedure.Columns">
      <summary>
            Columns in the stored procedure
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.StoredProcedure.Definition">
      <summary>
            Definition
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Table">
      <summary>
            Table class
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.#ctor(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="ParentDatabase">Parent database</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,``0,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a column
            </summary>
      <param name="ColumnName">Column Name</param>
      <param name="ColumnType">Data type</param>
      <param name="Length">Data length</param>
      <param name="Nullable">Nullable?</param>
      <param name="Identity">Identity?</param>
      <param name="Index">Index?</param>
      <param name="PrimaryKey">Primary key?</param>
      <param name="Unique">Unique?</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
      <param name="DefaultValue">Default value</param>
      <param name="OnDeleteCascade">On Delete Cascade</param>
      <param name="OnUpdateCascade">On Update Cascade</param>
      <param name="OnDeleteSetNull">On Delete Set Null</param>
      <typeparam name="T">Column type</typeparam>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.ContainsColumn(System.String)">
      <summary>
            Determines if a column exists in the table
            </summary>
      <param name="ColumnName">Column name</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.AddForeignKey(System.String,System.String,System.String)">
      <summary>
            Adds a foreign key
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ForeignKeyTable">Foreign key table</param>
      <param name="ForeignKeyColumn">Foreign key column</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.SetupForeignKeys">
      <summary>
            Sets up foreign keys
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Table.AddTrigger(System.String,System.String,Utilities.SQL.DataClasses.Enums.TriggerType)">
      <summary>
            Adds a trigger
            </summary>
      <param name="Name">Trigger name</param>
      <param name="Definition">Trigger definition</param>
      <param name="Type">The trigger type</param>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Table.Name">
      <summary>
            Name of the table
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Table.Columns">
      <summary>
            Columns in the table
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Table.ParentDatabase">
      <summary>
            Parent database
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Table.Triggers">
      <summary>
            List of triggers associated with the table
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Table.Item(System.String)">
      <summary>
            Gets the column specified
            </summary>
      <param name="Name">Column name</param>
      <returns>The specified column</returns>
    </member>
    <member name="T:Utilities.SQL.DataClasses.Trigger">
      <summary>
            Trigger class
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.Trigger.#ctor(System.String,System.String,Utilities.SQL.DataClasses.Enums.TriggerType,Utilities.SQL.DataClasses.Table)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="Definition">Definition</param>
      <param name="Type">Type</param>
      <param name="ParentTable">Parent table</param>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Trigger.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Trigger.Definition">
      <summary>
            Definition
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Trigger.Type">
      <summary>
            Trigger type
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.Trigger.ParentTable">
      <summary>
            Parent table
            </summary>
    </member>
    <member name="T:Utilities.SQL.DataClasses.View">
      <summary>
            View class
            </summary>
    </member>
    <member name="M:Utilities.SQL.DataClasses.View.#ctor(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Constructor
            </summary>
      <param name="Name">Name</param>
      <param name="ParentDatabase">Parent dataabse</param>
    </member>
    <member name="M:Utilities.SQL.DataClasses.View.AddColumn``1(System.String,System.Data.DbType,System.Int32,System.Boolean)">
      <summary>
            Adds a column to the view
            </summary>
      <param name="ColumnName">Column name</param>
      <param name="ColumnType">Data type</param>
      <param name="MaxLength">max length</param>
      <param name="Nullable">Nullable?</param>
    </member>
    <member name="P:Utilities.SQL.DataClasses.View.Name">
      <summary>
            Name of the view
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.View.ParentDatabase">
      <summary>
            Parent database
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.View.Columns">
      <summary>
            Columns in the view
            </summary>
    </member>
    <member name="P:Utilities.SQL.DataClasses.View.Definition">
      <summary>
            Definition of the view
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Database">
      <summary>
            Holds database information
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Database.#ctor(System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <param name="Connection">Connection string (if not specified, uses Name to get the connection string from the configuration manager)</param>
      <param name="Name">Database name (if not specified, it uses the first connection string it finds in the configuration manager)</param>
      <param name="DbType">Database type, based on ADO.Net provider name (will override if it pulls info from the configuration manager)</param>
      <param name="ParameterPrefix">Parameter prefix to use (if empty, it will override with its best guess based on database type)</param>
      <param name="Profile">Determines if the calls should be profiled</param>
      <param name="Readable">Should this database be used to read data?</param>
      <param name="Writable">Should this database be used to write data?</param>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.Connection">
      <summary>
            Connection string
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.Name">
      <summary>
            Name of the database
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.DbType">
      <summary>
            Database type, based on ADO.Net provider name
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.ParameterPrefix">
      <summary>
            Parameter prefix that the database uses
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.Profile">
      <summary>
            Should calls to this database be profiled?
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.Mappings">
      <summary>
            Contains the mappings associated with this database
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.Writable">
      <summary>
            Should this database be used to write data?
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Database.Readable">
      <summary>
            Should this database be used to read data?
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Enums.Mode">
      <summary>
            Determines the mode that the database is in
            </summary>
    </member>
    <member name="F:Utilities.SQL.MicroORM.Enums.Mode.Neither">
      <summary>
            Neither readable or writable
            </summary>
    </member>
    <member name="F:Utilities.SQL.MicroORM.Enums.Mode.Read">
      <summary>
            Readable
            </summary>
    </member>
    <member name="F:Utilities.SQL.MicroORM.Enums.Mode.Write">
      <summary>
            Writable
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Interfaces.IMapping">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Interfaces.IMapping`1">
      <summary>
            Mapping interface
            </summary>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.IMapping`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,``0,Utilities.SQL.MicroORM.Enums.Mode)">
      <summary>
            Maps a property to a database property name (required to actually get data from the database)
            </summary>
      <typeparam name="DataType">Data type of the property</typeparam>
      <param name="Property">Property to add a mapping for</param>
      <param name="DatabasePropertyName">Property name</param>
      <param name="Mode">This determines if the mapping should have read or write access</param>
      <param name="DefaultValue">Default value</param>
      <returns>This mapping</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Interfaces.IMapping`1.Map(System.Linq.Expressions.Expression{System.Func{`0,System.String}},System.String,System.String,Utilities.SQL.MicroORM.Enums.Mode)">
      <summary>
            Maps a property to a database property name (required to actually get data from the database)
            </summary>
      <param name="Property">Property to add a mapping for</param>
      <param name="DatabasePropertyName">Property name</param>
      <param name="Mode">This determines if the mapping should have read or write access</param>
      <param name="DefaultValue">Default value</param>
      <returns>This mapping</returns>
    </member>
    <member name="T:Utilities.SQL.MicroORM.Mapping`1">
      <summary>
            Class that acts as a mapping within the micro ORM
            </summary>
      <typeparam name="ClassType">Class type that this will accept</typeparam>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Mapping`1.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Constructor (can be used if supplying own SQLHelper)
            </summary>
      <param name="TableName">Table name</param>
      <param name="PrimaryKey">Primary key</param>
      <param name="AutoIncrement">Is the primary key set to auto increment?</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Mapping`1.#ctor(Utilities.SQL.MicroORM.Mapping{`0})">
      <summary>
            Constructor (used internally to create instance versions of static mappings
            </summary>
      <param name="MappingToCopyFrom">Mapping to copy from</param>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Mapping`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,``0,Utilities.SQL.MicroORM.Enums.Mode)">
      <summary>
            Maps a property to a database property name (required to actually get data from the database)
            </summary>
      <typeparam name="DataType">Data type of the property</typeparam>
      <param name="Property">Property to add a mapping for</param>
      <param name="DatabasePropertyName">Property name</param>
      <param name="Mode">This determines if the mapping should have read or write access</param>
      <param name="DefaultValue">Default value</param>
      <returns>This mapping</returns>
    </member>
    <member name="M:Utilities.SQL.MicroORM.Mapping`1.Map(System.Linq.Expressions.Expression{System.Func{`0,System.String}},System.String,System.String,Utilities.SQL.MicroORM.Enums.Mode)">
      <summary>
            Maps a property to a database property name (required to actually get data from the database)
            </summary>
      <param name="Property">Property to add a mapping for</param>
      <param name="DatabasePropertyName">Property name</param>
      <param name="Mode">This determines if the mapping should have read or write access</param>
      <param name="DefaultValue">Default value</param>
      <returns>This mapping</returns>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.Mappings">
      <summary>
            Mapper used to map properties to SQLHelper
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.TableName">
      <summary>
            Table name
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.PrimaryKey">
      <summary>
            Primary key
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.PrimaryKeyMapping">
      <summary>
            Used to get/set primary key from an object
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.GetPrimaryKey">
      <summary>
            Gets the primary key from an object
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.AutoIncrement">
      <summary>
            Auto increment?
            </summary>
    </member>
    <member name="P:Utilities.SQL.MicroORM.Mapping`1.ParameterNames">
      <summary>
            Parameter listing
            </summary>
    </member>
    <member name="T:Utilities.SQL.SQLHelper">
      <summary>
            SQL Helper class
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Database">Database name (can be used later to pull connection information)</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.#ctor(Utilities.SQL.MicroORM.Interfaces.ICommand,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Command">Command to use</param>
      <param name="Database">Database name (can be used later to pull connection information)</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.#ctor(System.String,System.Data.CommandType,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Command">Stored procedure/SQL Text to use</param>
      <param name="CommandType">The command type of the command sent in</param>
      <param name="Database">Database to use</param>
    </member>
    <member name="F:Utilities.SQL.SQLHelper.Databases">
      <summary>
            List of database connections
            </summary>
    </member>
    <member name="F:Utilities.SQL.SQLHelper.Cache">
      <summary>
            Cache that is used internally
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.BeginTransaction">
      <summary>
            Begins a transaction
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Close">
      <summary>
            Closes the connection
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Commit">
      <summary>
            Commits a transaction
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.GetDatabase(System.String)">
      <summary>
            Adds a database's info
            </summary>
      <param name="Name">Name to associate with the database (if not specified, it uses the first connection string it finds in the configuration manager)</param>
      <returns>The database object specified</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Open">
      <summary>
            Opens the connection
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Rollback">
      <summary>
            Rolls back a transaction
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupScalarCommand``1(System.String,Utilities.SQL.MicroORM.Mapping{``0},Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets up the scalar command
            </summary>
      <param name="Command">Command to create with</param>
      <param name="Parameters">Parameter list</param>
      <param name="Mapping">Mapping information</param>
      <returns>The string command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupDeleteCommand``1(Utilities.SQL.MicroORM.Mapping{``0})">
      <summary>
            Sets up the delete command
            </summary>
      <param name="Mapping">Mapping information</param>
      <returns>The command string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupInsertCommand``1(Utilities.SQL.MicroORM.Mapping{``0},Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets up the insert command
            </summary>
      <param name="Parameters">Parameters</param>
      <param name="Mapping">Mapping information</param>
      <returns>The command string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupPageCountCommand``1(Utilities.SQL.MicroORM.Mapping{``0},System.Int32,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets up the page count command
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameter list</param>
      <param name="Mapping">Mapping information</param>
      <returns>The string command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupPageCountCommand(System.String)">
      <summary>
            Sets up the page count command
            </summary>
      <param name="Command">Command</param>
      <returns>The string command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupPagedCommand``1(System.String,System.String,System.Int32,System.Int32,Utilities.SQL.MicroORM.Mapping{``0},Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets up the paged select command
            </summary>
      <param name="Columns">Columns to return</param>
      <param name="OrderBy">Order by clause</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page</param>
      <param name="Parameters">Parameter list</param>
      <param name="Mapping">Mapping information</param>
      <returns>The command string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupPagedCommand``1(System.String,System.String,System.Int32,System.Int32,Utilities.SQL.MicroORM.Mapping{``0})">
      <summary>
            Sets up the paged select command
            </summary>
      <param name="Query">Query used in getting the paged data</param>
      <param name="OrderBy">Order by clause</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">Current page</param>
      <param name="Mapping">Mapping information</param>
      <returns>The command string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupSelectCommand``1(System.String,System.Int32,System.String,Utilities.SQL.MicroORM.Mapping{``0},Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets up the select command
            </summary>
      <param name="Columns">Columns to return</param>
      <param name="Limit">limit on the number of items to return</param>
      <param name="OrderBy">Order by clause</param>
      <param name="Parameters">Parameter list</param>
      <param name="Mapping">Mapping information</param>
      <returns>The string command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.SetupUpdateCommand``1(Utilities.SQL.MicroORM.Mapping{``0},Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Sets up the update command
            </summary>
      <param name="Mapping">Mapping information</param>
      <param name="Parameters">Parameters</param>
      <returns>The command string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.AddParameter(System.String,System.String,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for strings only)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.AddParameter(System.String,System.Data.SqlDbType,System.Object,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.AddParameter``1(System.String,``0,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <typeparam name="DataType">Data type of the parameter</typeparam>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.AddParameter(System.String,System.Data.DbType,System.Object,System.Data.ParameterDirection)">
      <summary>
            Adds a parameter to the call (for all types other than strings)
            </summary>
      <param name="ID">Name of the parameter</param>
      <param name="Value">Value to add</param>
      <param name="Type">SQL type of the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.AddParameter(Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Adds parameters to the call
            </summary>
      <param name="Parameters">Parameters to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.AddParameter(System.Object[])">
      <summary>
            Adds parameters to the call
            </summary>
      <param name="Parameters">Parameters to add</param>
      <returns>This</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.All``1(System.String,System.Data.CommandType,System.Collections.Generic.IEnumerable{``0},System.Func{``0},System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets a list of all objects that meet the specified criteria
            </summary>
      <param name="Command">Command to use (can be an SQL string or stored procedure)</param>
      <param name="CommandType">Command type</param>
      <param name="Objects">Objects to modify/addon to (uses primary key to determine)</param>
      <param name="ObjectCreator">Function used to create the indvidual objects</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Cache">Should the item be cached</param>
      <returns>A list of all objects that meet the specified criteria</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt; local_2 = new Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;();&#xD;&#xA;    }&#xD;&#xA;    return !IsNullOrEmpty(Command); })()" vb="(() =&gt; {&#xD;&#xA;    Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt; local_2 = New Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2(Of ClassType)();&#xD;&#xA;    return Not IsNullOrEmpty(Command); })()">(() =&gt; {
    {
        Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt; local_2 = new Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;();
    }
    return !string.IsNullOrEmpty(Command); })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt; local_2 = new Utilities.SQL.SQLHelper.&lt;&gt;c__DisplayClass2&lt;ClassType&gt;();
    }
    return !string.IsNullOrEmpty(Command); })()</exception>
      <requires description="Mappings" exception="T:System.ArgumentNullException" csharp="this.DatabaseUsing.Mappings != null" vb="Me.DatabaseUsing.Mappings &lt;&gt; Nothing">this.DatabaseUsing.Mappings != null</requires>
      <exception cref="T:System.ArgumentNullException">this.DatabaseUsing.Mappings == null</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.All``1(System.String,System.Int32,System.String,System.Collections.Generic.IEnumerable{``0},System.Func{``0},System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets a list of all objects that meet the specified criteria
            </summary>
      <param name="Columns">Columns to return</param>
      <param name="Limit">Limit on the number of items to return</param>
      <param name="OrderBy">Order by clause</param>
      <param name="Objects">Objects to modify/addon to (uses primary key to determine)</param>
      <param name="ObjectCreator">Function used to create the individual objects</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Cache">Should the item be cached</param>
      <returns>A list of all objects that meet the specified criteria</returns>
      <requires description="Columns" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Columns)" vb="Not IsNullOrEmpty(Columns)">!string.IsNullOrEmpty(Columns)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Columns)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Any``1(System.String,``0,System.Func{``0},System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets a single object that fits the criteria
            </summary>
      <param name="Columns">Columns to select</param>
      <param name="ObjectToReturn">Object to return (in case the object needs to be created outside this,
            or default value is desired in case of nothing found)</param>
      <param name="ObjectCreator">Function used to create the object if the ObjectToReturn is set to null
            (if set to null, it just creates a new object using the default constructor)</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Cache">Should the item be cached</param>
      <returns>An object fitting the criteria specified or null if none are found</returns>
      <requires description="Columns" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Columns)" vb="Not IsNullOrEmpty(Columns)">!string.IsNullOrEmpty(Columns)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Columns)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Any``1(System.String,System.Data.CommandType,``0,System.Func{``0},System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets a single object that fits the criteria
            </summary>
      <param name="Command">Command to use (can be an SQL string or stored procedure name)</param>
      <param name="CommandType">Command type</param>
      <param name="ObjectToReturn">Object to return (in case the object needs to be created outside this,
            or default value is desired in case of nothing found)</param>
      <param name="ObjectCreator">Function used to create the object if the ObjectToReturn is set to null
            (if set to null, it just creates a new object using the default constructor)</param>
      <param name="Parameters">Parameters used to search by</param>
      <param name="Cache">Should the item be cached</param>
      <returns>An object fitting the criteria specified or null if none are found</returns>
      <requires description="Mappings" exception="T:System.ArgumentNullException" csharp="this.DatabaseUsing.Mappings != null" vb="Me.DatabaseUsing.Mappings &lt;&gt; Nothing">this.DatabaseUsing.Mappings != null</requires>
      <exception cref="T:System.ArgumentNullException">this.DatabaseUsing.Mappings == null</exception>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Command)" vb="Not IsNullOrEmpty(Command)">!string.IsNullOrEmpty(Command)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Command)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Delete``1(System.String,System.Data.CommandType,``0)">
      <summary>
            Deletes an object from the database
            </summary>
      <param name="Command">Command to use</param>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="CommandType">Command type</param>
      <param name="Object">Object to delete</param>
      <returns>The number of rows deleted</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="(object)Object != null" vb="((Object)Object) &lt;&gt; Nothing">(object)Object != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)Object == null</exception>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Command)" vb="Not IsNullOrEmpty(Command)">!string.IsNullOrEmpty(Command)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Command)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Delete``1(``0)">
      <summary>
            Deletes an object from the database
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Object">Object to delete</param>
      <returns>The number of rows deleted</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Delete``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Deletes a list of objects from the database
            </summary>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Objects">Objects to delete</param>
      <returns>The number of rows deleted</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Insert``2(System.String,System.Data.CommandType,``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Inserts an object based on the command specified
            </summary>
      <typeparam name="DataType">Data type expected to be returned from the query (to get the ID, etc.)</typeparam>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Command">Command to run</param>
      <param name="CommandType">Command type</param>
      <param name="Object">Object to insert</param>
      <param name="Parameters">Parameters sent into the function</param>
      <returns>The returned object from the query (usually the newly created row's ID)</returns>
      <requires description="Object" exception="T:System.ArgumentNullException" csharp="(object)Object != null" vb="((Object)Object) &lt;&gt; Nothing">(object)Object != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)Object == null</exception>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Command)" vb="Not IsNullOrEmpty(Command)">!string.IsNullOrEmpty(Command)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Command)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Insert``2(``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Inserts an object into the database
            </summary>
      <typeparam name="DataType">Data type expected (should be the same type as the primary key)</typeparam>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="Object">Object to insert</param>
      <param name="Parameters">Parameters sent into the function</param>
      <returns>The returned object from the query (the newly created row's ID)</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.PageCount``1(System.Int32,System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified 
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Cache">Should the item be cached</param>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.PageCount``1(System.String,System.Int32,System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets the number of pages based on the specified 
            </summary>
      <param name="PageSize">Page size</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <param name="Cache">Should the item be cached</param>
      <returns>The number of pages that the table contains for the specified page size</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Paged``1(System.String,System.String,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0},System.Func{``0},System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets a paged list of objects fitting the specified criteria
            </summary>
      <param name="Columns">Columns to return</param>
      <param name="OrderBy">Order by clause</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">The current page (starting at 0)</param>
      <param name="Objects">Objects to modify/addon to (uses primary key to determine)</param>
      <param name="ObjectCreator">Function used to create the individual objects (if set to null, it uses the default constructor)</param>
      <param name="Cache">Should the item be cached</param>
      <param name="Parameters">Parameters to search by</param>
      <returns>A list of objects that fit the specified criteria</returns>
      <requires description="Columns" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Columns)" vb="Not IsNullOrEmpty(Columns)">!string.IsNullOrEmpty(Columns)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Columns)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.PagedCommand``1(System.String,System.String,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0},System.Func{``0},System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Gets a paged list of objects fitting the specified criteria
            </summary>
      <param name="Command">Command to return data from</param>
      <param name="OrderBy">Order by clause</param>
      <param name="PageSize">Page size</param>
      <param name="CurrentPage">The current page (starting at 0)</param>
      <param name="Objects">Objects to modify/addon to (uses primary key to determine)</param>
      <param name="Cache">Should the item be cached</param>
      <param name="ObjectCreator">Function used to create the individual objects (if set to null, it uses the default constructor)</param>
      <param name="Parameters">Parameters to search by</param>
      <returns>A list of objects that fit the specified criteria</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Command)" vb="Not IsNullOrEmpty(Command)">!string.IsNullOrEmpty(Command)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Command)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Save``2(``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Saves (inserts/updates) an object based on the following criteria:
            1) If autoincrement is set to true and the primary key is the default value, it inserts
            2) If autoincrement is set to true and the primary key is not the default value, it updates
            3) If autoincrement is set to false and the primary key is the default value, it inserts
            4) If autoincrement is set to false and the primary key is not the default value,
            it does an Any call to see if the item is already in the database. If it is, it does an
            update. Otherwise it does an insert.
            On an insert, the primary key property is updated with the resulting value of the insert.
            </summary>
      <param name="Object">Object to save</param>
      <param name="Parameters">Extra parameters to be added to the insert/update function</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Save``2(System.Collections.Generic.IEnumerable{``0},Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Saves (inserts/updates) a list of objects based on the following criteria:
            1) If autoincrement is set to true and the primary key is the default value, it inserts
            2) If autoincrement is set to true and the primary key is not the default value, it updates
            3) If autoincrement is set to false and the primary key is the default value, it inserts
            4) If autoincrement is set to false and the primary key is not the default value,
            it does an Any call to see if the item is already in the database. If it is, it does an
            update. Otherwise it does an insert.
            On an insert, the primary key property is updated with the resulting value of the insert.
            </summary>
      <param name="Objects">Objects to save</param>
      <param name="Parameters">Extra parameters to be added to the insert/update function</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Scalar``2(System.String,System.Data.CommandType,System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a supplied scalar function and returns the result
            </summary>
      <param name="CommandType">Command type</param>
      <param name="Parameters">Parameters to search by</param>
      <param name="Command">Command to get the page count of</param>
      <param name="Cache">Should the item be cached</param>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ClassType">Class type</typeparam>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Scalar``2(System.String,System.Boolean,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Runs a scalar command using the specified aggregate function
            </summary>
      <typeparam name="DataType">Data type</typeparam>
      <typeparam name="ClassType">Class type</typeparam>
      <param name="AggregateFunction">Aggregate function</param>
      <param name="Parameters">Parameters</param>
      <param name="Cache">Should the item be cached</param>
      <returns>The scalar value returned by the command</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Update``1(System.String,System.Data.CommandType,``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Updates an object in the database
            </summary>
      <param name="Command">Command to use</param>
      <param name="CommandType">Command type</param>
      <param name="Object">Object to update</param>
      <param name="Parameters">Parameters sent into the function</param>
      <returns>The number of rows updated</returns>
      <requires description="Command" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Command)" vb="Not IsNullOrEmpty(Command)">!string.IsNullOrEmpty(Command)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Command)</exception>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Update``1(``0,Utilities.SQL.Interfaces.IParameter[])">
      <summary>
            Updates an object in the database
            </summary>
      <param name="Object">Object to update</param>
      <param name="Parameters">Parameters sent into the function</param>
      <returns>The number of rows updated</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Batch">
      <summary>
            Used to help batch various commands together
            </summary>
      <returns>The batch object</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ClearParameters">
      <summary>
            Clears the parameters
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteBulkCopy``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Data.SqlClient.SqlBulkCopyOptions,System.Boolean)">
      <summary>
            Does a bulk copy of the data (only usable on SQL Server)
            </summary>
      <param name="Data">Data to copy over</param>
      <param name="DestinationTable">Table to copy the data to</param>
      <param name="Options">Options used during the copy</param>
      <param name="CreateTransaction">Create transaction</param>
      <returns>Returns this SQLHelper object</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteBulkCopy(System.Data.DataTable,System.String,System.Data.SqlClient.SqlBulkCopyOptions,System.Boolean)">
      <summary>
            Does a bulk copy of the data (only usable on SQL Server)
            </summary>
      <param name="Data">Data to copy over</param>
      <param name="DestinationTable">Table to copy the data to</param>
      <param name="Options">Options used during the copy</param>
      <param name="CreateTransaction">Create transaction</param>
      <returns>Returns this SQLHelper object</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.BulkCopy(System.Data.DataTable,System.String,System.Data.SqlClient.SqlBulkCopyOptions,System.Boolean)">
      <summary>
            Does the actual bulk copy
            </summary>
      <param name="Data">Data to copy over</param>
      <param name="DestinationTable">Table to copy the data to</param>
      <param name="Options">Options used during the copy</param>
      <param name="CreateTransaction">Create transaction</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteDataSet(System.Boolean,System.Boolean)">
      <summary>
            Executes the query and returns a data set
            </summary>
      <param name="CreateTransaction">Create transaction</param>
      <param name="Cache">Determines if the query should be cached for future queries</param>
      <returns>A dataset filled with the results of the query</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteDataSet(System.Boolean,System.Boolean,System.Data.DataSet)">
      <summary>
            Executes the query and returns a data set
            </summary>
      <param name="CreateTransaction">Create transaction</param>
      <param name="Cache">Determines if the query should be cached for future queries</param>
      <param name="ReturnValue">DataSet</param>
      <returns>A dataset filled with the results of the query</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteNonQuery(System.Boolean)">
      <summary>
            Executes the stored procedure as a non query
            </summary>
      <param name="CreateTransaction">Creates a transaction for this command</param>
      <returns>Number of rows effected</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteNonQuery(System.Boolean,System.Int32)">
      <summary>
            Executes the stored procedure as a non query
            </summary>
      <param name="CreateTransaction">Creates a transaction for this command</param>
      <param name="ReturnValue">Not used</param>
      <returns>Number of rows effected</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteReader(System.Boolean,System.Boolean)">
      <summary>
            Executes the stored procedure and returns a reader object
            </summary>
      <param name="CreateTransaction">Create transaction</param>
      <param name="Cache">Determines if the query should be cached for future queries</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteReader(System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Executes the stored procedure/sql command and returns a reader object
            </summary>
      <param name="CreateTransaction">Create transaction</param>
      <param name="Cache">Determines if the query should be cached for future queries</param>
      <param name="NotUsed">Not used</param>
      <returns>this</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteScalar``1(System.Boolean,System.Boolean)">
      <summary>
            Executes the stored procedure as a scalar query
            </summary>
      <typeparam name="DataType">Data type to return</typeparam>
      <param name="CreateTransaction">Create transaction</param>
      <param name="Cache">Determines if the query should be cached for future queries</param>
      <returns>The object of the first row and first column</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteScalar``1(System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Executes the stored procedure as a scalar query
            </summary>
      <typeparam name="DataType">Data type to return</typeparam>
      <param name="CreateTransaction">Create transaction</param>
      <param name="Cache">Determines if the query should be cached for future queries</param>
      <param name="NotUsed">Not used</param>
      <returns>The object of the first row and first column</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteXmlReader(System.Boolean)">
      <summary>
            Executes the query and returns an XmlReader
            </summary>
      <param name="CreateTransaction">Create transaction</param>
      <returns>The XmlReader filled with the data from the query</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ExecuteXmlReader(System.Boolean,System.Boolean)">
      <summary>
            Executes the query and returns an XmlReader
            </summary>
      <param name="CreateTransaction">Create transaction</param>
      <param name="NotUsed">Not used</param>
      <returns>The XmlReader filled with the data from the query</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.GetParameter``1(System.String,``0,System.Data.ParameterDirection)">
      <summary>
            Returns a parameter's value
            </summary>
      <typeparam name="DataType">Data type of the object</typeparam>
      <param name="ID">Parameter name</param>
      <param name="Default">Default value for the parameter</param>
      <param name="Direction">Parameter direction (defaults to input)</param>
      <returns>if the parameter exists (and isn't null or empty), it returns the parameter's value. Otherwise the default value is returned.</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.GetParameter``1(System.Int32,``0)">
      <summary>
            Returns a parameter's value
            </summary>
      <typeparam name="DataType">Data type of the object</typeparam>
      <param name="Position">Position in the row</param>
      <param name="Default">Default value for the parameter</param>
      <returns>if the parameter exists (and isn't null or empty), it returns the parameter's value. Otherwise the default value is returned.</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.NextResult">
      <summary>
            Goes to the next result set (used if multiple queries are sent in)
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Read">
      <summary>
            Is there more information?
            </summary>
      <returns>True if there is more rows, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Setup(System.Boolean)">
      <summary>
            Sets up the info for 
            </summary>
      <param name="Transaction">Should a transaction be set up for this call?</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ClearAllMappings">
      <summary>
            Clears all database objects of all mappings
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ClearCache">
      <summary>
            Clears the cache
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.ClearMappings(System.String)">
      <summary>
            Clears a database object of all mappings
            </summary>
      <param name="Database">Database object to clear</param>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Database(System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Adds a database's info
            </summary>
      <param name="ConnectionString">Connection string to use for this database (if not specified, uses Name to get the connection string from the configuration manager)</param>
      <param name="Name">Name to associate with the database (if not specified, it uses the first connection string it finds in the configuration manager)</param>
      <param name="DbType">Database type, based on ADO.Net provider name (will override if it pulls info from the configuration manager)</param>
      <param name="Profile">Determines if the commands should be profiled (if empty, it will override with its best guess based on database type)</param>
      <param name="ParameterPrefix">Parameter prefix</param>
      <param name="Readable">Should this database be used to read data?</param>
      <param name="Writable">Should this database be used to write data?</param>
      <returns>The database object specified</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Map``1(System.String,System.String,System.Boolean,System.String)">
      <summary>
            Creates a mapping (or returns an already created one if it exists)
            </summary>
      <typeparam name="ClassType">Class type to map</typeparam>
      <param name="TableName">Table name</param>
      <param name="PrimaryKey">Primary key</param>
      <param name="AutoIncrement">Auto incrementing primar key</param>
      <param name="Database">Database to use</param>
      <returns>The created mapping (or an already created one if it exists)</returns>
    </member>
    <member name="M:Utilities.SQL.SQLHelper.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="P:Utilities.SQL.SQLHelper.Factory">
      <summary>
            Db provider factory (creates connections, etc.)
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLHelper.Connection">
      <summary>
            Connection to the database
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLHelper.ExecutableCommand">
      <summary>
            The executable command
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLHelper.Reader">
      <summary>
            The data reader for the query
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLHelper.DatabaseUsing">
      <summary>
            Database using
            </summary>
    </member>
    <member name="P:Utilities.SQL.SQLHelper.Command">
      <summary>
            Command using
            </summary>
    </member>
    <member name="T:Utilities.SQL.SQLServer.SQLServer">
      <summary>
            Functions helpful for SQL Server
            </summary>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.CreateDatabase(Utilities.SQL.DataClasses.Database,System.String)">
      <summary>
            Creates a database out of the structure it is given
            </summary>
      <param name="Database">Database structure</param>
      <param name="ConnectionString">The connection string to the database's location</param>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.DoesDatabaseExist(System.String,System.String)">
      <summary>
            Checks if a database exists
            </summary>
      <param name="Database">Name of the database</param>
      <param name="ConnectionString">Connection string</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.DoesStoredProcedureExist(System.String,System.String)">
      <summary>
            Checks if stored procedure exists
            </summary>
      <param name="StoredProcedure">Stored procedure's name</param>
      <param name="ConnectionString">Connection string</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.DoesTableExist(System.String,System.String)">
      <summary>
            Checks if a table exists
            </summary>
      <param name="Table">Table name</param>
      <param name="ConnectionString">Connection string</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.DoesTriggerExist(System.String,System.String)">
      <summary>
            Checks if trigger exists
            </summary>
      <param name="Trigger">Trigger's name</param>
      <param name="ConnectionString">Connection string</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.DoesViewExist(System.String,System.String)">
      <summary>
            Checks if a view exists
            </summary>
      <param name="View">View name</param>
      <param name="ConnectionString">Connection string</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetDatabaseStructure(System.String)">
      <summary>
            Gets the structure of a database
            </summary>
      <param name="ConnectionString">Connection string</param>
      <returns>The database structure</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.UpdateDatabase(Utilities.SQL.DataClasses.Database,Utilities.SQL.DataClasses.Database,System.String)">
      <summary>
            Updates a database (only adds new fields, tables, etc. does not delete old fields)
            </summary>
      <param name="DesiredDatabase">The desired structure of the database</param>
      <param name="CurrentDatabase">The current database structure</param>
      <param name="ConnectionString">Connection string to the database</param>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.BuildCommands(Utilities.SQL.DataClasses.Database,Utilities.SQL.DataClasses.Database)">
      <summary>
            Builds a list of commands for a datatbase
            </summary>
      <param name="DesiredDatabase">Desired database structure</param>
      <param name="CurrentDatabase">Current database structure</param>
      <returns>A list of commands</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.BuildCommands(Utilities.SQL.DataClasses.Database)">
      <summary>
            Builds the list of commands to build the database
            </summary>
      <param name="Database">Database object</param>
      <returns>The commands needed to build the database</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.CheckExists(System.String,System.String,System.String)">
      <summary>
            Checks if something exists
            </summary>
      <param name="Command">Command to run</param>
      <param name="Name">Name of the item</param>
      <param name="ConnectionString">Connection string</param>
      <returns>True if it exists, false otherwise</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetAlterFunctionCommand(Utilities.SQL.DataClasses.Function,Utilities.SQL.DataClasses.Function)">
      <summary>
            Gets a list of alter commands for a function
            </summary>
      <param name="Function">Desired function structure</param>
      <param name="CurrentFunction">Current function structure</param>
      <returns>A list of commands in a string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetAlterStoredProcedure(Utilities.SQL.DataClasses.StoredProcedure,Utilities.SQL.DataClasses.StoredProcedure)">
      <summary>
            Gets a list of alter commands for a stored procedure
            </summary>
      <param name="StoredProcedure">Desired stored procedure</param>
      <param name="CurrentStoredProcedure">Current stored procedure</param>
      <returns>A list of commands in a string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetAlterTableCommand(Utilities.SQL.DataClasses.Table,Utilities.SQL.DataClasses.Table)">
      <summary>
            Gets alter commands for a table
            </summary>
      <param name="DesiredTable">Desired table structure</param>
      <param name="CurrentTable">Current table structure</param>
      <returns>A string containing a list of commands</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetAlterTriggerCommand(Utilities.SQL.DataClasses.Table,Utilities.SQL.DataClasses.Table)">
      <summary>
            Gets a list of commands altering triggers
            </summary>
      <param name="Table">Desired table containing the triggers</param>
      <param name="CurrentTable">Current table containing the current triggers</param>
      <returns>A string containing a list of commands</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetAlterViewCommand(Utilities.SQL.DataClasses.View,Utilities.SQL.DataClasses.View)">
      <summary>
            Gets a list of alter commands for a view
            </summary>
      <param name="View">Desired view structure</param>
      <param name="CurrentView">Current view structure</param>
      <returns>A list of commands in a string</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetForeignKeyCommand(Utilities.SQL.DataClasses.Table)">
      <summary>
            Gets the foreign keys creation command
            </summary>
      <param name="Table">Table object</param>
      <returns>The string creating the foreign keys</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetFunctionCommand(Utilities.SQL.DataClasses.Function)">
      <summary>
            Gets the function command
            </summary>
      <param name="Function">The function object</param>
      <returns>The string creating the function</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetStoredProcedure(Utilities.SQL.DataClasses.StoredProcedure)">
      <summary>
            Gets the stored procedure creation command
            </summary>
      <param name="StoredProcedure">The stored procedure object</param>
      <returns>The string creating the stored procedure</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetTableCommand(Utilities.SQL.DataClasses.Table)">
      <summary>
            Gets the table creation commands
            </summary>
      <param name="Table">Table object</param>
      <returns>The string containing the creation commands</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetTables(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Gets the tables for a database
            </summary>
      <param name="ConnectionString">Connection string</param>
      <param name="Temp">The database object</param>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetTriggerCommand(Utilities.SQL.DataClasses.Table)">
      <summary>
            Gets the list of triggers associated with the table
            </summary>
      <param name="Table">Table object</param>
      <returns>The string containing the various creation commands</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.GetViewCommand(Utilities.SQL.DataClasses.View)">
      <summary>
            Gets the view creation command
            </summary>
      <param name="View">The view object</param>
      <returns>The string creating the view</returns>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.SetupFunctions(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Sets up the functions
            </summary>
      <param name="ConnectionString">Connection string</param>
      <param name="Temp">Database object</param>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.SetupStoredProcedures(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Sets up stored procedures
            </summary>
      <param name="ConnectionString">Connection string</param>
      <param name="Temp">Database object</param>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.SetupTables(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Sets up the tables (pulls columns, etc.)
            </summary>
      <param name="ConnectionString">Connection string</param>
      <param name="Temp">Database object</param>
    </member>
    <member name="M:Utilities.SQL.SQLServer.SQLServer.SetupViews(System.String,Utilities.SQL.DataClasses.Database)">
      <summary>
            Sets up the views
            </summary>
      <param name="ConnectionString">Connection string</param>
      <param name="Temp">Database object</param>
    </member>
    <member name="T:Utilities.Validation.Rules.CascadeAttribute">
      <summary>
            Cascade attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.CascadeAttribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.CascadeAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="T:Utilities.Validation.Rules.MaxLengthAttribute">
      <summary>
            Max length attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.MaxLengthAttribute.#ctor(System.Int64,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.MaxLengthAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.MaxLengthAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.MaxLengthAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.MinLengthAttribute">
      <summary>
            Min length attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.MinLengthAttribute.#ctor(System.Int64,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Value">Value to check</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.MinLengthAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.MinLengthAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.MinLengthAttribute.Value">
      <summary>
            Value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.NotInRangeAttribute">
      <summary>
            Not in range attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.NotInRangeAttribute.#ctor(System.Object,System.Object,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Max">Max value</param>
      <param name="Min">Min value</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.NotInRangeAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.NotInRangeAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="P:Utilities.Validation.Rules.NotInRangeAttribute.Min">
      <summary>
            Min value to compare to
            </summary>
    </member>
    <member name="P:Utilities.Validation.Rules.NotInRangeAttribute.Max">
      <summary>
            Max value to compare to
            </summary>
    </member>
    <member name="T:Utilities.Validation.Rules.NotEmptyAttribute">
      <summary>
            Not empty attribute
            </summary>
    </member>
    <member name="M:Utilities.Validation.Rules.NotEmptyAttribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="M:Utilities.Validation.Rules.NotEmptyAttribute.FormatErrorMessage(System.String)">
      <summary>
            Formats the error message
            </summary>
      <param name="name">Property name</param>
      <returns>The formatted string</returns>
    </member>
    <member name="M:Utilities.Validation.Rules.NotEmptyAttribute.IsValid(System.Object,System.ComponentModel.DataAnnotations.ValidationContext)">
      <summary>
            Determines if the property is valid
            </summary>
      <param name="value">Value to check</param>
      <param name="validationContext">Validation context</param>
      <returns>The validation result</returns>
    </member>
    <member name="T:Utilities.Web.Akismet.Akismet">
      <summary>
            Akismet helper class
            </summary>
    </member>
    <member name="T:Utilities.Web.REST.REST">
      <summary>
            Class designed to help with calling REST based applications
            </summary>
    </member>
    <member name="M:Utilities.Web.REST.REST.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.REST.REST.GET">
      <summary>
            Does a GET to the REST service
            </summary>
      <returns>a string containing the data returned by the service</returns>
    </member>
    <member name="M:Utilities.Web.REST.REST.POST">
      <summary>
            Does a POST to the REST service
            </summary>
      <returns>a string containing the data returned by the service</returns>
    </member>
    <member name="M:Utilities.Web.REST.REST.DELETE">
      <summary>
            Does a DELETE on the REST service
            </summary>
      <returns>a string containing the data returned by the service</returns>
    </member>
    <member name="M:Utilities.Web.REST.REST.PUT">
      <summary>
            Does a PUT on the REST service
            </summary>
      <returns>a string containing the data returned by the service</returns>
    </member>
    <member name="M:Utilities.Web.REST.REST.SetupData(System.Net.HttpWebRequest)">
      <summary>
            Sets up any data that needs to be sent
            </summary>
      <param name="Request">The web request object</param>
    </member>
    <member name="M:Utilities.Web.REST.REST.SetupCredentials(System.Net.HttpWebRequest)">
      <summary>
            Sets up any credentials (basic authentication,
            for OAuth, please use the OAuth class to create the
            URL)
            </summary>
      <param name="Request">The web request object</param>
    </member>
    <member name="M:Utilities.Web.REST.REST.SendRequest(System.Net.HttpWebRequest)">
      <summary>
            Sends the request to the URL specified
            </summary>
      <param name="Request">The web request object</param>
      <returns>The string returned by the service</returns>
    </member>
    <member name="P:Utilities.Web.REST.REST.Url">
      <summary>
            URL to send the request to
            </summary>
    </member>
    <member name="P:Utilities.Web.REST.REST.Data">
      <summary>
            Any data that needs to be appended to the request
            </summary>
    </member>
    <member name="P:Utilities.Web.REST.REST.UserName">
      <summary>
            User name (basic authentication)
            </summary>
    </member>
    <member name="P:Utilities.Web.REST.REST.Password">
      <summary>
            Password (basic authentication
            </summary>
    </member>
    <member name="M:Utilities.Web.Akismet.Akismet.#ctor(System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Key">API Key</param>
      <param name="Site">Site using Akismet</param>
    </member>
    <member name="M:Utilities.Web.Akismet.Akismet.VerifyKey">
      <summary>
            Verifies the Key
            </summary>
      <returns>True if the key is valid, false otherwise</returns>
    </member>
    <member name="M:Utilities.Web.Akismet.Akismet.IsSpam(Utilities.Web.Akismet.Comment)">
      <summary>
            Checks if a comment is spam or ham
            </summary>
      <param name="Comment">Comment to check</param>
      <returns>True if it is spam, false otherwise</returns>
    </member>
    <member name="M:Utilities.Web.Akismet.Akismet.SubmitSpam(Utilities.Web.Akismet.Comment)">
      <summary>
            Submits a spam message
            </summary>
      <param name="Comment">Comment to submit</param>
    </member>
    <member name="M:Utilities.Web.Akismet.Akismet.SubmitHam(Utilities.Web.Akismet.Comment)">
      <summary>
            Submits a ham message
            </summary>
      <param name="Comment">Comment to submit</param>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.Key">
      <summary>
            API Key
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.Website">
      <summary>
            Website
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.VerifyKeyData">
      <summary>
            Data sent to verify the API key
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.CommentCheckUrl">
      <summary>
            Comment check url
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.SubmitSpamUrl">
      <summary>
            Submit spam url
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.SubmitHamUrl">
      <summary>
            Submit ham url
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Akismet.CommentCheckData">
      <summary>
            Comment check data string
            </summary>
    </member>
    <member name="T:Utilities.Web.Akismet.Comment">
      <summary>
            Holds comment data
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.UserIP">
      <summary>
            User IP
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.UserAgent">
      <summary>
            User Agent
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.Referrer">
      <summary>
            Referrer
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.Permalink">
      <summary>
            Permalink
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.CommentType">
      <summary>
            Comment type
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.UserName">
      <summary>
            User name
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.UserEmail">
      <summary>
            User email
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.UserUrl">
      <summary>
            User URL
            </summary>
    </member>
    <member name="P:Utilities.Web.Akismet.Comment.Content">
      <summary>
            Content
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.SMTP.AppointmentSender">
      <summary>
            Sends appointments through SMTP
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.SMTP.EmailSender">
      <summary>
            Utility for sending an email
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.Message">
      <summary>
            Base message class used for emails
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Message.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Message.To">
      <summary>
            Whom the message is to
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Message.Subject">
      <summary>
            The subject of the email
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Message.From">
      <summary>
            Whom the message is from
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Message.Body">
      <summary>
            Body of the text
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.SMTP.EmailSender.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.SMTP.EmailSender.SendMail(System.String)">
      <summary>
            Sends an email
            </summary>
      <param name="MessageBody">The body of the message</param>
    </member>
    <member name="M:Utilities.Web.Email.SMTP.EmailSender.SendMailAsync(System.String)">
      <summary>
            Sends a piece of mail asynchronous
            </summary>
      <param name="MessageBody">The body of the message</param>
    </member>
    <member name="M:Utilities.Web.Email.SMTP.EmailSender.Dispose(System.Boolean)">
      <summary>
            Disposes of the object
            </summary>
      <param name="Managed">Ignored in this object</param>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.Attachments">
      <summary>
            Any attachments that are included with this
            message.
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.EmbeddedResources">
      <summary>
            Any attachment (usually images) that need to be embedded in the message
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.Priority">
      <summary>
            The priority of this message
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.Server">
      <summary>
            Server Location
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.UserName">
      <summary>
            User Name for the server
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.Password">
      <summary>
            Password for the server
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.Port">
      <summary>
            Port to send the information on
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.UseSSL">
      <summary>
            Decides whether we are using STARTTLS (SSL) or not
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.CC">
      <summary>
            Carbon copy send (seperate email addresses with a comma)
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.EmailSender.Bcc">
      <summary>
            Blind carbon copy send (seperate email addresses with a comma)
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.SMTP.AppointmentSender.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.SMTP.AppointmentSender.SendMail(System.String)">
      <summary>
            Sends an email
            </summary>
      <param name="MessageBody">The body of the message</param>
    </member>
    <member name="P:Utilities.Web.Email.SMTP.AppointmentSender.AppointmentInfo">
      <summary>
            Contains all of the appointment info
            </summary>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.DictionaryExtensions">
      <summary>
            Extensions for Dictionary classes
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.DictionaryExtensions.ToQueryString(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Converts the IDictionary to a query string
            </summary>
      <param name="Input">Input</param>
      <returns>The IDictionary expressed as a string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.HTTPRequestExtensions">
      <summary>
            Extensions for HttpRequest classes
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPRequestExtensions.UserIPAddress(System.Web.HttpRequestBase)">
      <summary>
            Gets the user's IP address if it exists, null is returned otherwise
            </summary>
      <param name="Request">Request</param>
      <returns>The IPAddress object if it exists, null otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPRequestExtensions.UserIPAddress(System.Web.HttpRequest)">
      <summary>
            Gets the user's IP address if it exists, null is returned otherwise
            </summary>
      <param name="Request">Request</param>
      <returns>The IPAddress object if it exists, null otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPRequestExtensions.IfModifiedSince(System.Web.HttpRequestBase)">
      <summary>
            Converts the If-Modified-Since header value to a DateTime object
            </summary>
      <param name="Request">Request</param>
      <returns>The If-Modified-Since header value expressed as a DateTime object</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPRequestExtensions.IfModifiedSince(System.Web.HttpRequest)">
      <summary>
            Converts the If-Modified-Since header value to a DateTime object
            </summary>
      <param name="Request">Request</param>
      <returns>The If-Modified-Since header value expressed as a DateTime object</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPRequestExtensions.IsMobile(System.Web.HttpRequestBase)">
      <summary>
            Detects if a browser is on a mobile device or not (does a more thorough job than simply Request.Browser.IsMobileDevice)
            </summary>
      <param name="Request">Request object</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
      <requires description="Browser" exception="T:System.ArgumentNullException" csharp="Request.Browser != null" vb="Request.Browser &lt;&gt; Nothing">Request.Browser != null</requires>
      <exception cref="T:System.ArgumentNullException">Request.Browser == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPRequestExtensions.IsMobile(System.Web.HttpRequest)">
      <summary>
            Detects if a browser is on a mobile device or not (does a more thorough job than simply Request.Browser.IsMobileDevice)
            </summary>
      <param name="Request">Request object</param>
      <returns>True if it is, false otherwise</returns>
      <requires description="Request" exception="T:System.ArgumentNullException" csharp="Request != null" vb="Request &lt;&gt; Nothing">Request != null</requires>
      <exception cref="T:System.ArgumentNullException">Request == null</exception>
      <requires description="Browser" exception="T:System.ArgumentNullException" csharp="Request.Browser != null" vb="Request.Browser &lt;&gt; Nothing">Request.Browser != null</requires>
      <exception cref="T:System.ArgumentNullException">Request.Browser == null</exception>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.NameValueCollectionExtensions">
      <summary>
            Extensions for NameValueCollection
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.NameValueCollectionExtensions.ToQueryString(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Converts the NameValueCollection to a query string
            </summary>
      <param name="Input">Input</param>
      <returns>The NameValueCollection expressed as a string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.HTTPContextExtensions">
      <summary>
            HttpContext extensions
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpAllInformation(System.Web.HttpContext,System.Boolean)">
      <summary>
            Dumps a lot of information about the request to a string (Request, Response, Session, Cookies, Cache, and Application state)
            </summary>
      <param name="Context">HttpContext</param>
      <param name="HTMLOutput">Determines if this should be HTML output or not</param>
      <returns>The exported data</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpApplicationState(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the Application State
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should html output be used?</param>
      <returns>A string containing the application state information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpApplicationState(System.Web.HttpApplicationState,System.Boolean)">
      <summary>
            Dumps the values found in the application state
            </summary>
      <param name="Input">Application state variable</param>
      <param name="HTMLOutput">Should html output be used?</param>
      <returns>A string containing the application state information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpCache(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the cache
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the cache information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpCache(System.Web.Caching.Cache,System.Boolean)">
      <summary>
            Dumps the values found in the cache
            </summary>
      <param name="Input">Cache variable</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the cache information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpCookies(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the cookies sent by the user
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should html output be used</param>
      <returns>A string containing the cookie information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpCookies(System.Web.HttpCookieCollection,System.Boolean)">
      <summary>
            Dumps the values found in the cookies sent by the user
            </summary>
      <param name="Input">Cookies</param>
      <param name="HTMLOutput">Should html output be used</param>
      <returns>A string containing the cookie information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpRequestVariable(System.Web.HttpRequest,System.Boolean)">
      <summary>
            Dumps information about the request variable
            </summary>
      <param name="Request">Request to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpRequestVariable(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps information about the request variable
            </summary>
      <param name="Page">Page to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpResponseVariable(System.Web.HttpResponse,System.Boolean)">
      <summary>
            Dumps information about the response variable
            </summary>
      <param name="Response">Response to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpResponseVariable(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps information about the response variable
            </summary>
      <param name="Page">Page to dump the information about</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing the information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpServerVars(System.Web.HttpRequest,System.Boolean)">
      <summary>
            Gets the server variables and dumps them out
            </summary>
      <param name="Request">request to get server variables from</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>a string containing an HTML formatted list of the server variables</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpServerVars(System.Web.UI.Page,System.Boolean)">
      <summary>
            Gets the server variables and dumps them out
            </summary>
      <param name="Page">page to get server variables from</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing an HTML formatted list of the server variables</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpSession(System.Web.UI.Page,System.Boolean)">
      <summary>
            Dumps the values found in the session
            </summary>
      <param name="Page">Page in which to dump</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the session information</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTTPContextExtensions.DumpSession(System.Web.SessionState.HttpSessionState,System.Boolean)">
      <summary>
            Dumps the values found in the session
            </summary>
      <param name="Input">Session variable</param>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>A string containing the session information</returns>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.HTMLExtensions">
      <summary>
            Set of HTML related extensions (and HTTP related)
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.AbsoluteRoot(System.Web.HttpContextBase)">
      <summary>
            Returns the absolute root
            </summary>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.AbsoluteRoot(System.Web.HttpContext)">
      <summary>
            Returns the absolute root
            </summary>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.AddScriptFile(System.Web.UI.Page,System.IO.FileInfo)">
      <summary>
            Adds a script file to the header of the current page
            </summary>
      <param name="File">Script file</param>
      <param name="Page">Page to add it to</param>
      <requires description="File" exception="T:System.ArgumentNullException" csharp="File != null" vb="File &lt;&gt; Nothing">File != null</requires>
      <exception cref="T:System.ArgumentNullException">File == null</exception>
      <requires description="File does not exist" exception="T:System.IO.FileNotFoundException" csharp="File.Exists" vb="File.Exists">File.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!File.Exists</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.ContainsHTML(System.String)">
      <summary>
            Decides if the string contains HTML
            </summary>
      <param name="Input">Input string to check</param>
      <returns>false if it does not contain HTML, true otherwise</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.ContainsHTML(System.IO.FileInfo)">
      <summary>
            Decides if the file contains HTML
            </summary>
      <param name="Input">Input file to check</param>
      <returns>false if it does not contain HTML, true otherwise</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.HTTPCompress(System.Web.HttpContextBase,System.Boolean,Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Adds HTTP compression to the current context
            </summary>
      <param name="Context">Current context</param>
      <param name="RemovePrettyPrinting">Sets the response filter to a special stream that
            removes pretty printing from content</param>
      <param name="Type">The minification type to use (defaults to HTML if RemovePrettyPrinting 
            is set to true, but can also deal with CSS and Javascript)</param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.HTTPCompress(System.Web.HttpContext,System.Boolean,Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Adds HTTP compression to the current context
            </summary>
      <param name="Context">Current context</param>
      <param name="RemovePrettyPrinting">Sets the response filter to a special stream that
            removes pretty printing from content</param>
      <param name="Type">The minification type to use (defaults to HTML if RemovePrettyPrinting 
            is set to true, but can also deal with CSS and Javascript)</param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.IsEncodingAccepted(System.Web.HttpContextBase,System.String)">
      <summary>
            Checks the request headers to see if the specified
            encoding is accepted by the client.
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.IsEncodingAccepted(System.Web.HttpContext,System.String)">
      <summary>
            Checks the request headers to see if the specified
            encoding is accepted by the client.
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.RelativeRoot(System.Web.HttpContextBase)">
      <summary>
            Gets the relative root of the web site
            </summary>
      <param name="Context">Current context</param>
      <returns>The relative root of the web site</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.RelativeRoot(System.Web.HttpContext)">
      <summary>
            Gets the relative root of the web site
            </summary>
      <param name="Context">Current context</param>
      <returns>The relative root of the web site</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.RemoveURLIllegalCharacters(System.String)">
      <summary>
            Removes illegal characters (used in uri's, etc.)
            </summary>
      <param name="Input">string to be converted</param>
      <returns>A stripped string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.SetEncoding(System.Web.HttpContextBase,System.String)">
      <summary>
            Adds the specified encoding to the response headers.
            </summary>
      <param name="Encoding">Encoding to set</param>
      <param name="Context">Context to set the encoding on</param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.SetEncoding(System.Web.HttpContext,System.String)">
      <summary>
            Adds the specified encoding to the response headers.
            </summary>
      <param name="Encoding">Encoding to set</param>
      <param name="Context">Context to set the encoding on</param>
      <requires description="Context" exception="T:System.ArgumentNullException" csharp="Context != null" vb="Context &lt;&gt; Nothing">Context != null</requires>
      <exception cref="T:System.ArgumentNullException">Context == null</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.StripHTML(System.String)">
      <summary>
            Removes HTML elements from a string
            </summary>
      <param name="HTML">HTML laiden string</param>
      <returns>HTML-less string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.StripHTML(System.IO.FileInfo)">
      <summary>
            Removes HTML elements from a string
            </summary>
      <param name="HTML">HTML laiden file</param>
      <returns>HTML-less string</returns>
      <requires description="HTML" exception="T:System.ArgumentNullException" csharp="HTML != null" vb="HTML &lt;&gt; Nothing">HTML != null</requires>
      <exception cref="T:System.ArgumentNullException">HTML == null</exception>
      <requires description="File does not exist" exception="T:System.IO.FileNotFoundException" csharp="HTML.Exists" vb="HTML.Exists">HTML.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!HTML.Exists</exception>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.URLDecode(System.String)">
      <summary>
            URL decodes a string
            </summary>
      <param name="Input">Input to decode</param>
      <returns>A decoded string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.URLEncode(System.String)">
      <summary>
            URL encodes a string
            </summary>
      <param name="Input">Input to encode</param>
      <returns>An encoded string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.RemoveExtraHyphen(System.String)">
      <summary>
            Removes extra hyphens from a string
            </summary>
      <param name="Input">string to be stripped</param>
      <returns>Stripped string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.HTMLExtensions.RemoveDiacritics(System.String)">
      <summary>
            Removes special characters (Diacritics) from the string
            </summary>
      <param name="Input">String to strip</param>
      <returns>Stripped string</returns>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.IPAddressExtensions">
      <summary>
            Extensions related to IP addresses
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.IPAddressExtensions.GetHostName(System.Net.IPAddress)">
      <summary>
            Gets the host name based off of an IP address
            </summary>
      <param name="IP">IP address</param>
      <returns>the host name associated with the IP</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.IPAddressExtensions.GetHostName(System.String)">
      <summary>
            Gets the host name based off of an IP address
            </summary>
      <param name="IP">IP address</param>
      <returns>the host name associated with the IP</returns>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.Minification">
      <summary>
            Extensions dealing with minification of data
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Minification.Combine(System.Collections.Generic.IEnumerable{System.String},Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Combines and minifies various files
            </summary>
      <param name="Input">input strings (file contents)</param>
      <param name="Type">Type of minification</param>
      <returns>A minified/packed string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Minification.Combine(System.Collections.Generic.IEnumerable{System.IO.FileInfo},Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Combines and minifies various files
            </summary>
      <param name="Input">input strings (file contents)</param>
      <param name="Type">Type of minification</param>
      <returns>A minified/packed string</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Minification.Minify(System.String,Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Minifies the file based on the data type specified
            </summary>
      <param name="Input">Input text</param>
      <param name="Type">Type of minification to run</param>
      <returns>A stripped file</returns>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Minification.Minify(System.IO.FileInfo,Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Minifies the file based on the data type specified
            </summary>
      <param name="Input">Input file</param>
      <param name="Type">Type of minification to run</param>
      <returns>A stripped file</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
      <requires description="Input file does not exist" exception="T:System.IO.FileNotFoundException" csharp="Input.Exists" vb="Input.Exists">Input.Exists</requires>
      <exception cref="T:System.IO.FileNotFoundException">!Input.Exists</exception>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.MinificationType">
      <summary>
            Defines the type of data that is being minified
            </summary>
    </member>
    <member name="F:Utilities.Web.ExtensionMethods.MinificationType.CSS">
      <summary>
            CSS
            </summary>
    </member>
    <member name="F:Utilities.Web.ExtensionMethods.MinificationType.JavaScript">
      <summary>
            Javascript
            </summary>
    </member>
    <member name="F:Utilities.Web.ExtensionMethods.MinificationType.HTML">
      <summary>
            HTML
            </summary>
    </member>
    <member name="T:Utilities.Web.ExtensionMethods.Streams.UglyStream">
      <summary>
            Removes "pretty printing" from HTML
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.#ctor(System.IO.Stream,Utilities.Compression.ExtensionMethods.Enums.CompressionType,Utilities.Web.ExtensionMethods.MinificationType)">
      <summary>
            Constructor
            </summary>
      <param name="StreamUsing">The stream for the page</param>
      <param name="Compression">The compression we're using (gzip or deflate)</param>
      <param name="Type">Minification type to use (defaults to HTML)</param>
    </member>
    <member name="F:Utilities.Web.ExtensionMethods.Streams.UglyStream.Compression">
      <summary>
            Compression using
            </summary>
    </member>
    <member name="F:Utilities.Web.ExtensionMethods.Streams.UglyStream.StreamUsing">
      <summary>
            Stream using
            </summary>
    </member>
    <member name="F:Utilities.Web.ExtensionMethods.Streams.UglyStream.FinalString">
      <summary>
            Final output string
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.Flush">
      <summary>
            Nothing to flush
            </summary>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Don't worry about
            </summary>
      <param name="buffer" />
      <param name="offset" />
      <param name="count" />
      <returns />
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="result &gt;= 0" vb="result &gt;= 0">result &gt;= 0</ensures>
      <ensures inheritedFrom="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="result &lt;= count" vb="result &lt;= count">result &lt;= count</ensures>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Once again not implemented
            </summary>
      <param name="offset" />
      <param name="origin" />
      <returns />
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.SetLength(System.Int64)">
      <summary>
            Don't worry about
            </summary>
      <param name="value" />
      <requires inheritedFrom="M:System.IO.Stream.SetLength(System.Int64)" inheritedFromTypeName="Stream" csharp="value &gt;= (long)0" vb="value &gt;= ((Long )0)">value &gt;= (long)0</requires>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Actually writes out the data
            </summary>
      <param name="buffer">the page's data in byte form</param>
      <param name="offset">offset of the data</param>
      <param name="count">the amount of data</param>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
      <requires inheritedFrom="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="Stream" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
    </member>
    <member name="M:Utilities.Web.ExtensionMethods.Streams.UglyStream.Evaluate(System.Text.RegularExpressions.Match)">
      <summary>
            Evaluates whether the text has spaces, page breaks, etc. and removes them.
            </summary>
      <param name="Matcher">Match found</param>
      <returns>The string minus any extra white space</returns>
    </member>
    <member name="P:Utilities.Web.ExtensionMethods.Streams.UglyStream.CanRead">
      <summary>
            Doesn't deal with reading
            </summary>
    </member>
    <member name="P:Utilities.Web.ExtensionMethods.Streams.UglyStream.CanSeek">
      <summary>
            No seeking
            </summary>
    </member>
    <member name="P:Utilities.Web.ExtensionMethods.Streams.UglyStream.CanWrite">
      <summary>
            Can write out though
            </summary>
    </member>
    <member name="P:Utilities.Web.ExtensionMethods.Streams.UglyStream.Length">
      <summary>
            Don't worry about
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Length" inheritedFromTypeName="Stream" csharp="result &gt;= (long)0" vb="result &gt;= ((Long )0)">result &gt;= (long)0</ensures>
      </getter>
    </member>
    <member name="P:Utilities.Web.ExtensionMethods.Streams.UglyStream.Position">
      <summary>
            No position to take care of
            </summary>
      <getter>
        <ensures inheritedFrom="M:System.IO.Stream.get_Position" inheritedFromTypeName="Stream" csharp="result &gt;= (long)0" vb="result &gt;= ((Long )0)">result &gt;= (long)0</ensures>
      </getter>
      <setter>
        <requires inheritedFrom="M:System.IO.Stream.set_Position(System.Int64)" inheritedFromTypeName="Stream" csharp="value &gt;= (long)0" vb="value &gt;= ((Long )0)">value &gt;= (long)0</requires>
      </setter>
    </member>
    <member name="T:Utilities.Web.Google.BaseClasses.APIBase">
      <summary>
            Google API base class
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.BaseClasses.APIBase.ToString">
      <summary>
            Converts the API base class to a string
            </summary>
      <returns>The API base class as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.Google.BaseClasses.APIBase.Key">
      <summary>
            API Key
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.BaseClasses.APIBase.APILocation">
      <summary>
            API Location
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.BaseClasses.APIBase.UseHTTPS">
      <summary>
            Should this use https?
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.Enums.ImageFormat">
      <summary>
            Image formats supported
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.ImageFormat.PNG8">
      <summary>
            8 bit PNG
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.ImageFormat.PNG">
      <summary>
            8 bit PNG
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.ImageFormat.PNG32">
      <summary>
            32 bit PNG
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.ImageFormat.GIF">
      <summary>
            GIF
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.ImageFormat.JPG">
      <summary>
            JPEG
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.ImageFormat.JPGBaseline">
      <summary>
            non-progressive JPEG
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.Enums.MapType">
      <summary>
            Map types supported
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MapType.RoadMap">
      <summary>
            Road map
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MapType.Satellite">
      <summary>
            Satellite map
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MapType.Terrain">
      <summary>
            Terrain map
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MapType.Hybrid">
      <summary>
            Hybrid map
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.Enums.MarkerSize">
      <summary>
            Marker sizes
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MarkerSize.Tiny">
      <summary>
            Tiny
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MarkerSize.Mid">
      <summary>
            Medium
            </summary>
    </member>
    <member name="F:Utilities.Web.Google.Enums.MarkerSize.Small">
      <summary>
            Small
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.HelperClasses.Address">
      <summary>
            Designates an address
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.Interfaces.ILocation">
      <summary>
            Location interface
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.HelperClasses.Address.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.HelperClasses.Address.ToString">
      <summary>
            Converts the location to a string
            </summary>
      <returns>The address as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Address.PhysicalAddress">
      <summary>
            Physical address
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.HelperClasses.LongLat">
      <summary>
            Location based on longitude and latitude
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.HelperClasses.LongLat.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.HelperClasses.LongLat.ToString">
      <summary>
            Exports the location as a string
            </summary>
      <returns>String of the location</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.LongLat.Longitude">
      <summary>
            Longitude
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.LongLat.Latitude">
      <summary>
            Latitude
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.HelperClasses.Markers">
      <summary>
            Holds data for displaying a set of markers on a map
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.HelperClasses.Markers.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.HelperClasses.Markers.ToString">
      <summary>
            Exports the location as an url encoded string
            </summary>
      <returns>Url encoded string of the location</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Markers.MarkerList">
      <summary>
            Marker list
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Markers.Size">
      <summary>
            Marker size
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Markers.Color">
      <summary>
            Marker color (24 bit hex color values)
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Markers.Label">
      <summary>
            Single uppercase alphanumeric character
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Markers.CustomIcon">
      <summary>
            Custom icon (may be PNG, JPEG, or GIF but PNG is recommended)
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.HelperClasses.Markers.CustomIconShadow">
      <summary>
            Should a shadow be generated from the custom icon?
            </summary>
    </member>
    <member name="T:Utilities.Web.Google.StaticMaps.Map">
      <summary>
            Static Maps API helper
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.StaticMaps.Map.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Google.StaticMaps.Map.ToString">
      <summary>
            Converts the map data to a URL
            </summary>
      <returns>The map as a URL</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.APILocation">
      <summary>
            API location
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Center">
      <summary>
            Center of the map
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Zoom">
      <summary>
            Zoom level (should be between 0 and 21
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Width">
      <summary>
            Width of the map
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Height">
      <summary>
            Height of the map
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Scale">
      <summary>
            Scale of the map (values are 1, 2, and 4 for business customers)
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Format">
      <summary>
            Image format
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.MapType">
      <summary>
            Map type
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Language">
      <summary>
            Language for the map to use
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Region">
      <summary>
            Displays appropriate borders based on geo-political sensitivities (uses two-character ccTLD values)
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Markers">
      <summary>
            A list of markers
            </summary>
    </member>
    <member name="P:Utilities.Web.Google.StaticMaps.Map.Sensor">
      <summary>
            Determines if a sensor is used to determine the user's location
            </summary>
    </member>
    <member name="T:Utilities.Web.Gravatar.Gravatar">
      <summary>
            Helper for getting Gravatar images
            </summary>
    </member>
    <member name="M:Utilities.Web.Gravatar.Gravatar.GetImageLink(System.String,System.Boolean)">
      <summary>
            Gets a Gravatar image link
            </summary>
      <param name="Email">Email identifier</param>
      <param name="AppendJPG">Should jpg be appended to the link?</param>
      <returns>The full path to the Gravatar image link</returns>
    </member>
    <member name="T:Utilities.FileFormats.CSV.CSV">
      <summary>
            CSV loader
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.CSV.CSV.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.CSV.CSV.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">File content</param>
    </member>
    <member name="P:Utilities.FileFormats.CSV.CSV.Delimiter">
      <summary>
            Delimiter used in the CSV
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.Attribute">
      <summary>
            Attributes associated with fields
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Attribute.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Attribute.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="AttributeText">Text of the attribute</param>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Attribute.Name">
      <summary>
            Name of the attribute
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Attribute.Value">
      <summary>
            Value of the attribtue
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.Code">
      <summary>
            Base coder class
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Code.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Code.Decode(System.String,System.Byte[]@)">
      <summary>
            Decodes a string to bytes
            </summary>
      <param name="Input">Input string</param>
      <param name="Output">Bytes once decoded</param>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Code.Decode(System.String,System.String@)">
      <summary>
            Decodes a string to another string
            </summary>
      <param name="Input">Input string</param>
      <param name="Output">Output string</param>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Code.Encode(System.Byte[])">
      <summary>
            Encodes a byte array
            </summary>
      <param name="Input">Input array</param>
      <returns>A string of the bytes encoded</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Code.Encode(System.String)">
      <summary>
            Encodes a string into a string
            </summary>
      <param name="Input">Input string</param>
      <returns>An encoded string</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Code.CharacterSet">
      <summary>
            Character set this coder is using
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.CodeManager">
      <summary>
            Manager in charge of the various decode/encode classes.
            Is a singleton.
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeManager.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeManager.Load">
      <summary>
            Loads the basic information for the class
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeManager.Instance">
      <summary>
            Instance of the class
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeManager.Item(System.String)">
      <summary>
            Gets the coder assocaited with the type specified
            </summary>
      <param name="Key">Content type</param>
      <returns>The coder associated with the type</returns>
    </member>
    <member name="T:Utilities.Web.Email.MIME.CodeTypes.CodeAddress">
      <summary>
            Address coder
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.CodeTypes.CodeBase">
      <summary>
            Default base coder
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.Decode(System.String,System.String@)">
      <summary>
            Decodes a string
            </summary>
      <param name="Input">Input string</param>
      <param name="Output">Output string</param>
      <requires description="Input" inheritedFrom="M:Utilities.Web.Email.MIME.Code.Decode(System.String,System.String@)" inheritedFromTypeName="Code" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.Encode(System.String)">
      <summary>
            Encodes a string
            </summary>
      <param name="Input">Input string</param>
      <returns>encoded string</returns>
      <requires description="Input" inheritedFrom="M:Utilities.Web.Email.MIME.Code.Encode(System.String)" inheritedFromTypeName="Code" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.EncodeDelimeter(System.String)">
      <summary>
            Encodes a string based on delimeters specified
            </summary>
      <param name="Input">Input string</param>
      <returns>A string encoded based off of delimeters</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.EncodeNoDelimeter(System.String)">
      <summary>
            Encodes a string without the use of delimeters
            </summary>
      <param name="Input">Input string</param>
      <returns>An encoded string</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.SelectEncoding(System.String)">
      <summary>
            Selects an encoding type
            </summary>
      <param name="Input">Input string</param>
      <returns>A string containing the encoding type that should be used</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase.IsNonASCIICharacter(System.Char)">
      <summary>
            Determines if this is a non ASCII character (greater than 255)
            </summary>
      <param name="Input" />
      <returns>True if it is, false otherwise</returns>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeBase.FoldCharacters">
      <summary>
            Fold characters
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeBase.IsAutoFold">
      <summary>
            Is folding used
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeBase.DelimeterNeeded">
      <summary>
            Are delimeter's needed
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeBase.DelimeterCharacters">
      <summary>
            Delimeter characters
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeAddress.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeAddress.FoldCharacters">
      <summary>
            Fold characters
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeAddress.IsAutoFold">
      <summary>
            Should this auto fold
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeAddress.DelimeterNeeded">
      <summary>
            Is a delimiter needed
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeAddress.DelimeterCharacters">
      <summary>
            Delimeter characters
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.CodeTypes.CodeBase64">
      <summary>
            Base 64 coder
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase64.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase64.Decode(System.String,System.Byte[]@)">
      <summary>
            Decodes from base64
            </summary>
      <param name="Input">Input string</param>
      <param name="Output">output array</param>
      <requires description="Input" inheritedFrom="M:Utilities.Web.Email.MIME.Code.Decode(System.String,System.Byte[]@)" inheritedFromTypeName="Code" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeBase64.Encode(System.Byte[])">
      <summary>
            Encodes to Base64
            </summary>
      <param name="Input">Input</param>
      <returns>byte array as base64</returns>
      <requires description="Input" inheritedFrom="M:Utilities.Web.Email.MIME.Code.Encode(System.Byte[])" inheritedFromTypeName="Code" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="T:Utilities.Web.Email.MIME.CodeTypes.CodeParameter">
      <summary>
            Coder for parameters
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeParameter.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeParameter.FoldCharacters">
      <summary>
            Fold character
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeParameter.IsAutoFold">
      <summary>
            Is auto folded
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeParameter.DelimeterNeeded">
      <summary>
            Delimiter needed
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.CodeTypes.CodeParameter.DelimeterCharacters">
      <summary>
            Delimiter characters
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.CodeTypes.CodeQP">
      <summary>
            Quoted-printable coder
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.CodeTypes.CodeQP.MAX_CHAR_LEN">
      <summary>
            Max char length
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeQP.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeQP.Decode(System.String,System.Byte[]@)">
      <summary>
            Decodes the string
            </summary>
      <param name="Input">String to decode</param>
      <param name="Output">Output in bytes</param>
      <requires description="Input" inheritedFrom="M:Utilities.Web.Email.MIME.Code.Decode(System.String,System.Byte[]@)" inheritedFromTypeName="Code" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeQP.Encode(System.Byte[])">
      <summary>
            Encodes the data
            </summary>
      <param name="Input">Input data</param>
      <returns>The encoded string</returns>
      <requires description="Input" inheritedFrom="M:Utilities.Web.Email.MIME.Code.Encode(System.Byte[])" inheritedFromTypeName="Code" exception="T:System.ArgumentNullException" csharp="Input != null" vb="Input &lt;&gt; Nothing">Input != null</requires>
      <exception cref="T:System.ArgumentNullException">Input == null</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeQP.DecodeOneLine(System.IO.Stream,System.String)">
      <summary>
            Decodes a single line
            </summary>
      <param name="Stream">Input stream</param>
      <param name="CurrentLine">The current line</param>
      <requires description="Stream" exception="T:System.ArgumentNullException" csharp="Stream != null" vb="Stream &lt;&gt; Nothing">Stream != null</requires>
      <exception cref="T:System.ArgumentNullException">Stream == null</exception>
      <requires description="CurrentLine" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(CurrentLine)" vb="Not IsNullOrEmpty(CurrentLine)">!string.IsNullOrEmpty(CurrentLine)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(CurrentLine)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeQP.IsHex(System.Char)">
      <summary>
            Determines if a character is possibly hexidecimal
            </summary>
      <param name="Input">Input character</param>
      <returns>true if it is, false otherwise</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.CodeTypes.CodeQP.FormatEncodedString(System.String)">
      <summary>
            Formats the encoded string
            </summary>
      <param name="Input">Input string</param>
      <returns>An encoded string</returns>
    </member>
    <member name="T:Utilities.Web.Email.MIME.Constants">
      <summary>
            Class containing constant used by the MIME parser
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MimeVersion">
      <summary>
            MIME version
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.ContentType">
      <summary>
            Content type
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.TransferEncoding">
      <summary>
            Transfer encoding
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.ContentID">
      <summary>
            Content ID
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.ContentDescription">
      <summary>
            Content Description
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.ContentDisposition">
      <summary>
            Content disposition
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Charset">
      <summary>
            Charset
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Subject">
      <summary>
            Subject
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.To">
      <summary>
            To
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.From">
      <summary>
            From
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Filename">
      <summary>
            Filename
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Boundary">
      <summary>
            Boundary
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Encoding7Bit">
      <summary>
            Encoding 7bit
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.Encoding8Bit">
      <summary>
            Encoding 8bit
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.EncodingBinary">
      <summary>
            Encoding binary
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.EncodingQP">
      <summary>
            Encoding QP
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.EncodingBase64">
      <summary>
            Encoding base64
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaText">
      <summary>
            Media text
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaImage">
      <summary>
            Media image
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaAudio">
      <summary>
            Media audio
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaVideo">
      <summary>
            Media video
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaApplication">
      <summary>
            Media application
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaMultiPart">
      <summary>
            Media multi part
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Constants.MediaMessage">
      <summary>
            Media message
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.Field">
      <summary>
            Fields within the header
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Field.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.Field.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FieldText">Field text</param>
      <requires description="FieldText" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(FieldText)" vb="Not IsNullOrEmpty(FieldText)">!string.IsNullOrEmpty(FieldText)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(FieldText)</exception>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Field.Name">
      <summary>
            Name of the field
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Field.Attributes">
      <summary>
            Attributes associated with the field
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Field.CharacterSet">
      <summary>
            Character set used by the field
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.Field.Item(System.String)">
      <summary>
            Can be used to get specific attributes' values
            </summary>
      <param name="Key">Name of the attribute</param>
      <returns>A string containing the value of the attribute</returns>
    </member>
    <member name="T:Utilities.Web.Email.MIME.MediaEnum">
      <summary>
            Enum defining media types
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_TEXT">
      <summary>
            Media text
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_IMAGE">
      <summary>
            Media image
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_AUDIO">
      <summary>
            Media audio
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_VIDEO">
      <summary>
            Media Video
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_APPLICATION">
      <summary>
            Media application
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_MULTIPART">
      <summary>
            Media multipart
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_MESSAGE">
      <summary>
            Media message
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaEnum.MEDIA_UNKNOWN">
      <summary>
            Media unknown
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.MediaType">
      <summary>
            Media type struct
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaType.MediaEnum">
      <summary>
            Enum associated with the sub type and file extension
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaType.SubType">
      <summary>
            Sub type
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MediaType.FileExtension">
      <summary>
            File extension
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MediaType.#ctor(Utilities.Web.Email.MIME.MediaEnum,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="MediaEnum">The media type</param>
      <param name="SubType">The sub type</param>
      <param name="FileExtension">File extension associated with the media type and sub type</param>
    </member>
    <member name="T:Utilities.Web.Email.MIME.MIMEBody">
      <summary>
            Body of the MIME message
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEBody.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEBody.#ctor(System.String,Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Constructor
            </summary>
      <param name="Input">Body text</param>
      <param name="Header">Header of the message</param>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEBody.GetMediaType(Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Gets the media type of the message
            </summary>
      <param name="Header">Header of the message</param>
      <returns>The media type</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEBody.GetContentType(Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Gets the content type
            </summary>
      <param name="Header">Header of the message</param>
      <returns>A string containing the content type</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEBody.GetBoundryMarker(Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Gets the boundary marker
            </summary>
      <param name="Header">Header of the message</param>
      <returns>A string containing the boundary marker</returns>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEBody.Boundries">
      <summary>
            Boundaries found within this item (files/messages)
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEBody.Content">
      <summary>
            Content of this boundary/message
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.MIMEHeader">
      <summary>
            Header of the MIME message
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEHeader.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEHeader.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="HeaderText">Text for the header</param>
      <requires description="HeaderText" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(HeaderText)" vb="Not IsNullOrEmpty(HeaderText)">!string.IsNullOrEmpty(HeaderText)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(HeaderText)</exception>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEHeader.Fields">
      <summary>
            The individual fields for the header
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEHeader.Item(System.String)">
      <summary>
            Can be used to get a specific field based on its name
            </summary>
      <param name="Key">Name of the field</param>
      <returns>Field specified</returns>
    </member>
    <member name="T:Utilities.Web.Email.MIME.MIMEMessage">
      <summary>
            Base message class for MIME messages
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Input">string containing the MIME message</param>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.LoadMessage(System.String)">
      <summary>
            Loads the message
            </summary>
      <param name="Input">string containing the message</param>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.GetContentType(Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Gets the content type
            </summary>
      <param name="Header">Header of the message</param>
      <returns>A string stating the content type</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.GetMediaType(Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Gets the media type for the body
            </summary>
      <param name="Header">The header of the message</param>
      <returns>An enum value indicating the media type of the boundary</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.GetContentSubType(Utilities.Web.Email.MIME.MIMEHeader)">
      <summary>
            Gets the sub type (used to determine if the item is HTML or plain text)
            </summary>
      <param name="Header">Header for this boundary/message</param>
      <returns>a string indicating the sub type of the boundary/message</returns>
    </member>
    <member name="M:Utilities.Web.Email.MIME.MIMEMessage.ToString">
      <summary>
            To string function returns the content of the message (including header)
            </summary>
      <returns>A string containing the initial message</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.Header">
      <summary>
            Header of the message
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.Body">
      <summary>
            Body of the message (may contain sub messages/boundries)
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.Subject">
      <summary>
            Subject of the message
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.To">
      <summary>
            Whom the message is to
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.From">
      <summary>
            Whom the message is from
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.BodyText">
      <summary>
            The text of the message
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.HTMLBodyText">
      <summary>
            Gets the HTML version of the text
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.MIME.MIMEMessage.PlainBodyText">
      <summary>
            Gets the plain version of the text
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.MIME.MIMEType">
      <summary>
            Defines basic MIME Types
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MIMEType.TypeTable">
      <summary>
            Defines the types in string form
            </summary>
    </member>
    <member name="F:Utilities.Web.Email.MIME.MIMEType.TypeCvtTable">
      <summary>
            Defines the sub types, file extensions, and media types
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.Pop3.Message">
      <summary>
            Class for containing the messages
            returned by the Pop3Client class.
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Message.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Message.Dispose(System.Boolean)">
      <summary>
            Does nothing in this instance
            </summary>
      <param name="Managed" />
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.MessageNumber">
      <summary>
            The number associated with the message
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.MessageSize">
      <summary>
            Size of the message in bytes
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.Retrieved">
      <summary>
            If true, we've retrieved this message from the server
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.MessageBody">
      <summary>
            MIME version of the email
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.Body">
      <summary>
            Body of the text
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.From">
      <summary>
            Whom the message is from
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.To">
      <summary>
            Whom the message is to
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Message.Subject">
      <summary>
            The subject of the email
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.Pop3.Pop3Client">
      <summary>
            Class for implemented basic Pop3 client
            functionality.
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.Connect(System.String,System.String,System.String,System.Int32)">
      <summary>
            Connects to a server
            </summary>
      <param name="UserName">Username used to log into the server</param>
      <param name="Password">Password used to log into the server</param>
      <param name="Server">Server location</param>
      <param name="Port">Port on the server to use</param>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.Disconnect">
      <summary>
            Disconnects from the server
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.GetMessageList">
      <summary>
            Gets a list of messages from the server
            </summary>
      <returns>A list of messages (only contains message number and size)</returns>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.GetMessage(Utilities.Web.Email.Pop3.Message)">
      <summary>
            Gets a specific message from the server
            </summary>
      <param name="MessageWanted">The message that you want to pull down from the server</param>
      <returns>A new message containing the content</returns>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.Delete(Utilities.Web.Email.Pop3.Message)">
      <summary>
            Deletes a message from the server
            </summary>
      <param name="MessageToDelete">Message to delete</param>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.WriteMessage(System.String)">
      <summary>
            Writes a message to the server
            </summary>
      <param name="Message">Information to send to the server</param>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Client.GetResponse">
      <summary>
            Gets the response from the server
            Note that this uses TCP/IP to get the
            messages, which means that the entire message
            may not be found in the returned string
            (it may only be a partial message)
            </summary>
      <returns>The response from the server</returns>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Pop3Client.UseSSL">
      <summary>
            Decides whether or not we are using
            SSL to connect to the server
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Pop3Client.Server">
      <summary>
            Server location
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Pop3Client.UserName">
      <summary>
            User name used to log in
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Pop3Client.Password">
      <summary>
            Password used to log in
            </summary>
    </member>
    <member name="P:Utilities.Web.Email.Pop3.Pop3Client.Port">
      <summary>
            Port on which to connect
            </summary>
    </member>
    <member name="T:Utilities.Web.Email.Pop3.Pop3Exception">
      <summary>
            Exception class used by the Pop3Client class
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Exception.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Exception.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            </summary>
      <param name="ExceptionText">Message</param>
      <param name="Exception">Inner exception</param>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Exception.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="ExceptionText">Text to put inside the exception</param>
    </member>
    <member name="M:Utilities.Web.Email.Pop3.Pop3Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor
            </summary>
      <param name="Info">Serialization info</param>
      <param name="Context">Streaming context</param>
    </member>
    <member name="T:Utilities.Encryption.RSAEncryption">
      <summary>
            Utility class for doing RSA Encryption
            </summary>
    </member>
    <member name="M:Utilities.Encryption.RSAEncryption.Encrypt(System.String,System.String,System.Text.Encoding)">
      <summary>
            Encrypts a string using RSA
            </summary>
      <param name="Input">Input string (should be small as anything over 128 bytes can not be decrypted)</param>
      <param name="Key">Key to use for encryption</param>
      <param name="EncodingUsing">Encoding that the input string uses (defaults to UTF8)</param>
      <returns>An encrypted string (64bit string)</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Encryption.RSAEncryption.Decrypt(System.String,System.String,System.Text.Encoding)">
      <summary>
            Decrypts a string using RSA
            </summary>
      <param name="Input">Input string (should be small as anything over 128 bytes can not be decrypted)</param>
      <param name="Key">Key to use for decryption</param>
      <param name="EncodingUsing">Encoding that the result should use (defaults to UTF8)</param>
      <returns>A decrypted string</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Encryption.RSAEncryption.CreateKey(System.Boolean)">
      <summary>
            Creates a new set of keys
            </summary>
      <param name="PrivatePublic">True if private key should be included, false otherwise</param>
      <returns>XML representation of the key information</returns>
    </member>
    <member name="M:Utilities.Encryption.RSAEncryption.SignHash(System.String,System.String,System.String@,System.Text.Encoding)">
      <summary>
            Takes a string and creates a signed hash of it
            </summary>
      <param name="Input">Input string</param>
      <param name="Key">Key to encrypt/sign with</param>
      <param name="Hash">This will be filled with the unsigned hash</param>
      <param name="EncodingUsing">Encoding that the input is using (defaults to UTF8)</param>
      <returns>A signed hash of the input (64bit string)</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Input)" vb="Not IsNullOrEmpty(Input)">!string.IsNullOrEmpty(Input)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Input)</exception>
    </member>
    <member name="M:Utilities.Encryption.RSAEncryption.VerifyHash(System.String,System.String,System.String)">
      <summary>
            Verifies a signed hash against the unsigned version
            </summary>
      <param name="Hash">The unsigned hash (should be 64bit string)</param>
      <param name="SignedHash">The signed hash (should be 64bit string)</param>
      <param name="Key">The key to use in decryption</param>
      <returns>True if it is verified, false otherwise</returns>
      <requires description="Key" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Key)" vb="Not IsNullOrEmpty(Key)">!string.IsNullOrEmpty(Key)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Key)</exception>
      <requires description="Hash" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Hash)" vb="Not IsNullOrEmpty(Hash)">!string.IsNullOrEmpty(Hash)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Hash)</exception>
      <requires description="SignedHash" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(SignedHash)" vb="Not IsNullOrEmpty(SignedHash)">!string.IsNullOrEmpty(SignedHash)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(SignedHash)</exception>
    </member>
    <member name="T:Utilities.Environment.Environment">
      <summary>
            Class designed to give information
            about the current system
            </summary>
    </member>
    <member name="M:Utilities.Environment.Environment.GetSystemInformation(System.Boolean)">
      <summary>
            Gets information about the system.
            </summary>
      <param name="HTMLOutput">Should HTML output be used</param>
      <returns>An HTML formatted string containing the state of the system.</returns>
    </member>
    <member name="P:Utilities.Environment.Environment.MachineName">
      <summary>
            Name of the machine running the app
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.UserName">
      <summary>
            Gets the user name that the app is running under
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.DomainName">
      <summary>
            Name of the domain that the app is running under
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.OSName">
      <summary>
            Name of the OS running
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.OSVersion">
      <summary>
            Version information about the OS running
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.OSServicePack">
      <summary>
            The service pack running on the OS
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.OSFullName">
      <summary>
            Full name, includes service pack, version, etc.
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.StackTrace">
      <summary>
            Gets the current stack trace information
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.NumberOfProcessors">
      <summary>
            Returns the number of processors on the machine
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.TotalMemoryUsed">
      <summary>
            The total amount of memory the GC believes is used
            by the app in bytes
            </summary>
    </member>
    <member name="P:Utilities.Environment.Environment.TotalMemory">
      <summary>
            The total amount of memory that is available in bytes
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.VCalendar">
      <summary>
            Creates a VCalendar item
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.GetVCalendar">
      <summary>
            Returns the VCalendar item
            </summary>
      <returns>a string output of the VCalendar item</returns>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.GetICalendar">
      <summary>
            Returns the ICalendar item
            </summary>
      <returns>a string output of the ICalendar item</returns>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.GetHCalendar">
      <summary>
            Returns the HCalendar item
            </summary>
      <returns>A string output of the HCalendar item</returns>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.GetText">
      <summary>
            Returns the text version of the appointment
            </summary>
      <returns>A text version of the appointement</returns>
    </member>
    <member name="M:Utilities.FileFormats.VCalendar.ToString">
      <summary>
            Returns the text version of the appointment
            </summary>
      <returns>A text version of the appointement</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.CurrentTimeZone">
      <summary>
            The time zone for the calendar event
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.StartTime">
      <summary>
            The start time
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.EndTime">
      <summary>
            The end time
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.Location">
      <summary>
            The location of the event
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.Subject">
      <summary>
            The subject of the item to send
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.Description">
      <summary>
            The description of the event
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.AttendeeList">
      <summary>
            List of attendees
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.Organizer">
      <summary>
            Organizer
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.Status">
      <summary>
            Sets the status for the appointment (FREE, BUSY, etc.)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCalendar.Cancel">
      <summary>
            Determines if the calendar item is being canceled
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.VCard">
      <summary>
            Class for creating vCards
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.VCard.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.VCard.GetVCard">
      <summary>
            Gets the vCard
            </summary>
      <returns>A vCard in string format</returns>
    </member>
    <member name="M:Utilities.FileFormats.VCard.GetHCard">
      <summary>
            Gets the hCard version of the vCard
            </summary>
      <returns>A hCard in string format</returns>
    </member>
    <member name="M:Utilities.FileFormats.VCard.ToString">
      <summary>
            Gets the VCard as a string
            </summary>
      <returns>VCard as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.VCard.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.FileFormats.VCard.FirstName">
      <summary>
            First name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.LastName">
      <summary>
            Last name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.MiddleName">
      <summary>
            Middle name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Prefix">
      <summary>
            Prefix
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Suffix">
      <summary>
            Suffix
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.DirectDial">
      <summary>
            Work phone number of the individual
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Email">
      <summary>
            Email of the individual
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Title">
      <summary>
            Title of the person
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Organization">
      <summary>
            Organization the person belongs to
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Relationships">
      <summary>
            Relationship to the person (uses XFN)
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.VCard.Url">
      <summary>
            Url to the person's site
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.Relationship">
      <summary>
            Enum defining relationships (used for XFN markup)
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Friend">
      <summary>
            Friend
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Acquaintance">
      <summary>
            Acquaintance
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Contact">
      <summary>
            Contact
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Met">
      <summary>
            Met
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.CoWorker">
      <summary>
            Coworker
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Colleague">
      <summary>
            Colleague
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.CoResident">
      <summary>
            Coresident
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Neighbor">
      <summary>
            Neighbor
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Child">
      <summary>
            Child
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Parent">
      <summary>
            Parent
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Sibling">
      <summary>
            Sibling
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Spouse">
      <summary>
            Spouse
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Kin">
      <summary>
            Kin
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Muse">
      <summary>
            Muse
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Crush">
      <summary>
            Crush
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Date">
      <summary>
            Date
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Sweetheart">
      <summary>
            Sweetheart
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.Relationship.Me">
      <summary>
            Me
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.INI.INI">
      <summary>
            Class for helping with INI files
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileName">Name of the file</param>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.WriteToINI(System.String,System.String,System.String)">
      <summary>
            Writes a change to an INI file
            </summary>
      <param name="Section">Section</param>
      <param name="Key">Key</param>
      <param name="Value">Value</param>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.ReadFromINI(System.String,System.String,System.String)">
      <summary>
            Reads a value from an INI file
            </summary>
      <param name="Section">Section</param>
      <param name="Key">Key</param>
      <param name="DefaultValue">Default value if it does not exist</param>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.ToXML">
      <summary>
            Returns an XML representation of the INI file
            </summary>
      <returns>An XML representation of the INI file</returns>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.DeleteFromINI(System.String)">
      <summary>
            Deletes a section from the INI file
            </summary>
      <param name="Section">Section to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.DeleteFromINI(System.String,System.String)">
      <summary>
            Deletes a key from the INI file
            </summary>
      <param name="Section">Section the key is under</param>
      <param name="Key">Key to remove</param>
      <returns>True if it is removed, false otherwise</returns>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.ToString">
      <summary>
            Convert the INI to a string
            </summary>
      <returns>The INI file as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.INI.INI.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.FileFormats.INI.INI.FileName">
      <summary>
            Name of the file
            </summary>
    </member>
    <member name="T:Utilities.Math.Matrix">
      <summary>
            Matrix used in linear algebra
            </summary>
    </member>
    <member name="M:Utilities.Math.Matrix.#ctor(System.Int32,System.Int32,System.Double[0:,0:])">
      <summary>
            Constructor
            </summary>
      <param name="Width">Width of the matrix</param>
      <param name="Height">Height of the matrix</param>
      <param name="Values">Values to use in the matrix</param>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Equality(Utilities.Math.Matrix,Utilities.Math.Matrix)">
      <summary>
            Determines if two matrices are equal
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>True if they are equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Inequality(Utilities.Math.Matrix,Utilities.Math.Matrix)">
      <summary>
            Determines if two matrices are unequal
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>True if they are not equal, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Addition(Utilities.Math.Matrix,Utilities.Math.Matrix)">
      <summary>
            Adds two matrices
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
      <requires description="M2" exception="T:System.ArgumentNullException" csharp="M2 != (Utilities.Math.Matrix)null" vb="M2 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M2 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M2 != (Utilities.Math.Matrix)null</exception>
      <requires description="Both matrices must be the same dimensions." exception="T:System.ArgumentException" csharp="M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height" vb="M1.Width = M2.Width AndAlso M1.Height = M2.Height">M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height</requires>
      <exception cref="T:System.ArgumentException">M1.Width != M2.Width ? !false : M1.Height != M2.Height</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Subtraction(Utilities.Math.Matrix,Utilities.Math.Matrix)">
      <summary>
            Subtracts two matrices
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
      <requires description="M2" exception="T:System.ArgumentNullException" csharp="M2 != (Utilities.Math.Matrix)null" vb="M2 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M2 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M2 != (Utilities.Math.Matrix)null</exception>
      <requires description="Both matrices must be the same dimensions." exception="T:System.ArgumentException" csharp="M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height" vb="M1.Width = M2.Width AndAlso M1.Height = M2.Height">M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height</requires>
      <exception cref="T:System.ArgumentException">M1.Width != M2.Width ? !false : M1.Height != M2.Height</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_UnaryNegation(Utilities.Math.Matrix)">
      <summary>
            Negates a matrix
            </summary>
      <param name="M1">Matrix 1</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Multiply(Utilities.Math.Matrix,Utilities.Math.Matrix)">
      <summary>
            Multiplies two matrices
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="M2">Matrix 2</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
      <requires description="M2" exception="T:System.ArgumentNullException" csharp="M2 != (Utilities.Math.Matrix)null" vb="M2 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M2 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M2 != (Utilities.Math.Matrix)null</exception>
      <requires description="Both matrices must be the same dimensions." exception="T:System.ArgumentException" csharp="M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height" vb="M1.Width = M2.Width AndAlso M1.Height = M2.Height">M1.Width == M2.Width &amp;&amp; M1.Height == M2.Height</requires>
      <exception cref="T:System.ArgumentException">M1.Width != M2.Width ? !false : M1.Height != M2.Height</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Multiply(Utilities.Math.Matrix,System.Double)">
      <summary>
            Multiplies a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to multiply by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Multiply(System.Double,Utilities.Math.Matrix)">
      <summary>
            Multiplies a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to multiply by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Division(Utilities.Math.Matrix,System.Double)">
      <summary>
            Divides a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to divide by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.op_Division(System.Double,Utilities.Math.Matrix)">
      <summary>
            Divides a matrix by a value
            </summary>
      <param name="M1">Matrix 1</param>
      <param name="D">Value to divide by</param>
      <returns>The result</returns>
      <requires description="M1" exception="T:System.ArgumentNullException" csharp="M1 != (Utilities.Math.Matrix)null" vb="M1 &lt;&gt; ((Utilities.Math.Matrix)Nothing) ">M1 != (Utilities.Math.Matrix)null</requires>
      <exception cref="T:System.ArgumentNullException">!M1 != (Utilities.Math.Matrix)null</exception>
    </member>
    <member name="M:Utilities.Math.Matrix.Equals(System.Object)">
      <summary>
            Determines if the objects are equal
            </summary>
      <param name="obj">Object to check</param>
      <returns>True if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Matrix.GetHashCode">
      <summary>
            Gets the hash code for the object
            </summary>
      <returns>The hash code for the object</returns>
    </member>
    <member name="M:Utilities.Math.Matrix.ToString">
      <summary>
            Gets the string representation of the matrix
            </summary>
      <returns>The matrix as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Math.Matrix.Transpose">
      <summary>
            Transposes the matrix
            </summary>
      <returns>Returns a new transposed matrix</returns>
    </member>
    <member name="M:Utilities.Math.Matrix.Determinant">
      <summary>
            Gets the determinant of a square matrix
            </summary>
      <returns>The determinant of a square matrix</returns>
      <requires description="The determinant can not be calculated for a non square matrix" exception="T:System.InvalidOperationException" csharp="this.Width == this.Height" vb="Me.Width = Me.Height">this.Width == this.Height</requires>
      <exception cref="T:System.InvalidOperationException">this.Width != this.Height</exception>
    </member>
    <member name="P:Utilities.Math.Matrix.Width">
      <summary>
            Width of the matrix
            </summary>
    </member>
    <member name="P:Utilities.Math.Matrix.Height">
      <summary>
            Height of the matrix
            </summary>
    </member>
    <member name="P:Utilities.Math.Matrix.Item(System.Int32,System.Int32)">
      <summary>
            Sets the values of the matrix
            </summary>
      <param name="X">X position</param>
      <param name="Y">Y position</param>
      <returns>the value at a point in the matrix</returns>
      <getter>
        <requires description="X" exception="T:System.ArgumentOutOfRangeException" csharp="X &gt;= 0 &amp;&amp; !(X &gt; this.Width)" vb="X &gt;= 0 AndAlso Not X &gt; Me.Width">X &gt;= 0 &amp;&amp; !(X &gt; this.Width)</requires>
        <requires description="Y" exception="T:System.ArgumentOutOfRangeException" csharp="Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)" vb="Y &gt;= 0 AndAlso Not Y &gt; Me.Height">Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)</requires>
      </getter>
      <exception cref="T:System.ArgumentOutOfRangeException">X &lt; 0 ? !false : X &gt; this.Width</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Y &lt; 0 ? !false : Y &gt; this.Height</exception>
      <setter>
        <requires description="X" exception="T:System.ArgumentOutOfRangeException" csharp="X &gt;= 0 &amp;&amp; !(X &gt; this.Width)" vb="X &gt;= 0 AndAlso Not X &gt; Me.Width">X &gt;= 0 &amp;&amp; !(X &gt; this.Width)</requires>
        <requires description="Y" exception="T:System.ArgumentOutOfRangeException" csharp="Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)" vb="Y &gt;= 0 AndAlso Not Y &gt; Me.Height">Y &gt;= 0 &amp;&amp; !(Y &gt; this.Height)</requires>
      </setter>
      <exception cref="T:System.ArgumentOutOfRangeException">X &lt; 0 ? !false : X &gt; this.Width</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Y &lt; 0 ? !false : Y &gt; this.Height</exception>
    </member>
    <member name="P:Utilities.Math.Matrix.Values">
      <summary>
            Values for the matrix
            </summary>
    </member>
    <member name="T:Utilities.Math.Vector3">
      <summary>
            Vector class (holds three items)
            </summary>
    </member>
    <member name="M:Utilities.Math.Vector3.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="X">X direction</param>
      <param name="Y">Y direction</param>
      <param name="Z">Z direction</param>
    </member>
    <member name="M:Utilities.Math.Vector3.Normalize">
      <summary>
            Normalizes the vector
            </summary>
    </member>
    <member name="M:Utilities.Math.Vector3.ToString">
      <summary>
            To string function
            </summary>
      <returns>String representation of the vector</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.Math.Vector3.GetHashCode">
      <summary>
            Gets the hash code
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.Equals(System.Object)">
      <summary>
            Determines if the items are equal
            </summary>
      <param name="obj">Object to compare</param>
      <returns>true if they are, false otherwise</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Addition(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Addition
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Subtraction(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Subtraction
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_UnaryNegation(Utilities.Math.Vector3)">
      <summary>
            Negation
            </summary>
      <param name="V1">Item 1</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_LessThan(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Less than
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_LessThanOrEqual(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Less than or equal
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_GreaterThan(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Greater than
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_GreaterThanOrEqual(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Greater than or equal
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Equality(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Equals
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Inequality(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Not equals
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Division(Utilities.Math.Vector3,System.Double)">
      <summary>
            Division
            </summary>
      <param name="V1">Item 1</param>
      <param name="D">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Multiply(Utilities.Math.Vector3,System.Double)">
      <summary>
            Multiplication
            </summary>
      <param name="V1">Item 1</param>
      <param name="D">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Multiply(System.Double,Utilities.Math.Vector3)">
      <summary>
            Multiplication
            </summary>
      <param name="V1">Item 1</param>
      <param name="D">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.op_Multiply(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Does a cross product
            </summary>
      <param name="V1">Item 1</param>
      <param name="V2">Item 2</param>
      <returns>The resulting vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.DotProduct(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Does a dot product
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <returns>a dot product</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.Interpolate(Utilities.Math.Vector3,Utilities.Math.Vector3,System.Double)">
      <summary>
            Interpolates between the vectors
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <param name="Control">Percent to move between 1 and 2</param>
      <returns>The interpolated vector</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.Distance(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            The distance between two vectors
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <returns>Distance between the vectors</returns>
    </member>
    <member name="M:Utilities.Math.Vector3.Angle(Utilities.Math.Vector3,Utilities.Math.Vector3)">
      <summary>
            Determines the angle between the vectors
            </summary>
      <param name="V1">Vector 1</param>
      <param name="V2">Vector 2</param>
      <returns>Angle between the vectors</returns>
    </member>
    <member name="P:Utilities.Math.Vector3.Array">
      <summary>
            Used for converting this to an array and back
            </summary>
    </member>
    <member name="P:Utilities.Math.Vector3.Magnitude">
      <summary>
            Returns the magnitude of the vector
            </summary>
    </member>
    <member name="P:Utilities.Math.Vector3.X">
      <summary>
            X value
            </summary>
    </member>
    <member name="P:Utilities.Math.Vector3.Y">
      <summary>
            Y Value
            </summary>
    </member>
    <member name="P:Utilities.Math.Vector3.Z">
      <summary>
            Z value
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.Filter">
      <summary>
            Used when applying convolution filters to an image
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Filter.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Width">Width</param>
      <param name="Height">Height</param>
    </member>
    <member name="M:Utilities.Media.Image.Filter.ApplyFilter(System.Drawing.Bitmap)">
      <summary>
            Applies the filter to the input image
            </summary>
      <param name="Input">input image</param>
      <returns>Returns a separate image with the filter applied</returns>
      <requires description="Input" exception="T:System.ArgumentNullException" csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        new Utilities.Media.Image.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = this;&#xD;&#xA;    }&#xD;&#xA;    return Input != null; })()" vb="(() =&gt; {&#xD;&#xA;    New Utilities.Media.Image.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = Me&#xD;&#xA;    return Input &lt;&gt; Nothing; })()">(() =&gt; {
    {
        new Utilities.Media.Image.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = this;
    }
    return Input != null; })()</requires>
      <exception cref="T:System.ArgumentNullException">!(() =&gt; {
    {
        (new Utilities.Media.Image.Filter.&lt;&gt;c__DisplayClass1().&lt;&gt;4__this = this);
    }
    return (Input != null); })()</exception>
    </member>
    <member name="P:Utilities.Media.Image.Filter.MyFilter">
      <summary>
            The actual filter array
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Filter.Width">
      <summary>
            Width of the filter box
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Filter.Height">
      <summary>
            Height of the filter box
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Filter.Offset">
      <summary>
            Amount to add to the red, blue, and green values
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Filter.Absolute">
      <summary>
            Determines if we should take the absolute value prior to clamping
            </summary>
    </member>
    <member name="T:Utilities.LDAP.Directory">
      <summary>
            Class for helping with AD
            </summary>
    </member>
    <member name="M:Utilities.LDAP.Directory.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="UserName">User name used to log in</param>
      <param name="Password">Password used to log in</param>
      <param name="Path">Path of the LDAP server</param>
      <param name="Query">Query to use in the search</param>
    </member>
    <member name="M:Utilities.LDAP.Directory.Authenticate">
      <summary>
            Checks to see if the person was authenticated
            </summary>
      <returns>true if they were authenticated properly, false otherwise</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.Close">
      <summary>
            Closes the directory
            </summary>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindActiveGroupMembers(System.String,System.Boolean)">
      <summary>
            Returns a group's list of members who are active
            </summary>
      <param name="GroupName">The group's name</param>
      <param name="Recursive">Should sub groups' members be added instead of the sub group itself?</param>
      <returns>A list of the members</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindActiveGroups(System.String,System.Object[])">
      <summary>
            Finds all active groups
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all active groups' entries</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindActiveUsers(System.String,System.Object[])">
      <summary>
            Finds all active users
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all active users' entries</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindActiveUsersAndGroups(System.String,System.Object[])">
      <summary>
            Finds all active users and groups
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all active groups' entries</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindAll">
      <summary>
            Finds all entries that match the query
            </summary>
      <returns>A list of all entries that match the query</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindComputers(System.String,System.Object[])">
      <summary>
            Finds all computers
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all computers meeting the specified Filter</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindGroupMembers(System.String,System.Boolean)">
      <summary>
            Returns a group's list of members
            </summary>
      <param name="GroupName">The group's name</param>
      <param name="Recursive">Should sub groups' members be added instead of the sub group itself?</param>
      <returns>A list of the members</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindGroup(System.String)">
      <summary>
            Finds a specific group
            </summary>
      <param name="GroupName">Name of the group to find</param>
      <returns>The group specified</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindGroups(System.String,System.Object[])">
      <summary>
            Finds all groups
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all groups meeting the specified Filter</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindOne">
      <summary>
            Finds one entry that matches the query
            </summary>
      <returns>A single entry matching the query</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindUsersAndGroups(System.String,System.Object[])">
      <summary>
            Finds all users and groups
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all users and groups meeting the specified Filter</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindUserByUserName(System.String)">
      <summary>
            Finds a user by his user name
            </summary>
      <param name="UserName">User name to search by</param>
      <returns>The user's entry</returns>
      <requires description="UserName" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(UserName)" vb="Not IsNullOrEmpty(UserName)">!string.IsNullOrEmpty(UserName)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(UserName)</exception>
    </member>
    <member name="M:Utilities.LDAP.Directory.FindUsers(System.String,System.Object[])">
      <summary>
            Finds all users
            </summary>
      <param name="Filter">Filter used to modify the query</param>
      <param name="args">Additional arguments (used in string formatting</param>
      <returns>A list of all users meeting the specified Filter</returns>
    </member>
    <member name="M:Utilities.LDAP.Directory.Dispose">
      <summary>
            Disposes of the directory object
            </summary>
    </member>
    <member name="M:Utilities.LDAP.Directory.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="M:Utilities.LDAP.Directory.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Directory.Path">
      <summary>
            Path of the server
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Directory.UserName">
      <summary>
            User name used to log in
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Directory.Password">
      <summary>
            Password used to log in
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Directory.Query">
      <summary>
            The query that is being made
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Directory.SortBy">
      <summary>
            Decides what to sort the information by
            </summary>
    </member>
    <member name="T:Utilities.LDAP.Entry">
      <summary>
            Directory entry class
            </summary>
    </member>
    <member name="M:Utilities.LDAP.Entry.#ctor(System.DirectoryServices.DirectoryEntry)">
      <summary>
            Constructor
            </summary>
      <param name="DirectoryEntry">Directory entry for the item</param>
    </member>
    <member name="M:Utilities.LDAP.Entry.Save">
      <summary>
            Saves any changes that have been made
            </summary>
      <requires description="DirectoryEntry shouldn't be null" exception="T:System.InvalidOperationException" csharp="this.DirectoryEntry != null" vb="Me.DirectoryEntry &lt;&gt; Nothing">this.DirectoryEntry != null</requires>
      <exception cref="T:System.InvalidOperationException">this.DirectoryEntry == null</exception>
    </member>
    <member name="M:Utilities.LDAP.Entry.GetValue(System.String)">
      <summary>
            Gets a value from the entry
            </summary>
      <param name="Property">Property you want the information about</param>
      <returns>an object containing the property's information</returns>
    </member>
    <member name="M:Utilities.LDAP.Entry.GetValue(System.String,System.Int32)">
      <summary>
            Gets a value from the entry
            </summary>
      <param name="Property">Property you want the information about</param>
      <param name="Index">Index of the property to return</param>
      <returns>an object containing the property's information</returns>
    </member>
    <member name="M:Utilities.LDAP.Entry.SetValue(System.String,System.Object)">
      <summary>
            Sets a property of the entry to a specific value
            </summary>
      <param name="Property">Property of the entry to set</param>
      <param name="Value">Value to set the property to</param>
    </member>
    <member name="M:Utilities.LDAP.Entry.SetValue(System.String,System.Int32,System.Object)">
      <summary>
            Sets a property of the entry to a specific value
            </summary>
      <param name="Property">Property of the entry to set</param>
      <param name="Index">Index of the property to set</param>
      <param name="Value">Value to set the property to</param>
    </member>
    <member name="M:Utilities.LDAP.Entry.ToString">
      <summary>
            Exports the entry as a string
            </summary>
      <returns>The entry as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.LDAP.Entry.Dispose">
      <summary>
            Disposes the object
            </summary>
    </member>
    <member name="M:Utilities.LDAP.Entry.Dispose(System.Boolean)">
      <summary>
            Disposes of the objects
            </summary>
      <param name="Disposing">True to dispose of all resources, false only disposes of native resources</param>
    </member>
    <member name="M:Utilities.LDAP.Entry.Finalize">
      <summary>
            Destructor
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.DirectoryEntry">
      <summary>
            Actual base directory entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.Email">
      <summary>
            Email property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.DistinguishedName">
      <summary>
            distinguished name property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.CountryCode">
      <summary>
            country code property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.Company">
      <summary>
            company property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.MemberOf">
      <summary>
            MemberOf property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.DisplayName">
      <summary>
            display name property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.Initials">
      <summary>
            initials property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.Title">
      <summary>
            title property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.SamAccountName">
      <summary>
            samaccountname property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.GivenName">
      <summary>
            givenname property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.CN">
      <summary>
            cn property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.Name">
      <summary>
            name property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.Office">
      <summary>
            office property for this entry
            </summary>
    </member>
    <member name="P:Utilities.LDAP.Entry.TelephoneNumber">
      <summary>
            telephone number property for this entry
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.Procedural.CellularMap">
      <summary>
            A cellular map creator
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.CellularMap.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Seed">Seed for random generation</param>
      <param name="Width">Width of the image</param>
      <param name="Height">Height of the image</param>
      <param name="NumberOfPoints">Number of cells</param>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.CellularMap.CalculateDistances">
      <summary>
            Calculate the distance between the points
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.CellularMap.FindClosestPoint(System.Int32,System.Int32)">
      <summary>
            Finds the closest cell center
            </summary>
      <param name="x">x axis</param>
      <param name="y">y axis</param>
    </member>
    <member name="P:Utilities.Media.Image.Procedural.CellularMap.ClosestPoint">
      <summary>
            List of closest cells
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Procedural.CellularMap.Distances">
      <summary>
            Distances to the closest cell
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Procedural.CellularMap.MinDistance">
      <summary>
            Minimum distance to a point
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Procedural.CellularMap.MaxDistance">
      <summary>
            Maximum distance to a point
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.Procedural.Point">
      <summary>
            Individual point
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.Procedural.Point.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Procedural.Point.X">
      <summary>
            X axis
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.Procedural.Point.Y">
      <summary>
            Y axis
            </summary>
    </member>
    <member name="T:Utilities.Media.Image.RGBHistogram">
      <summary>
            Class used to create an RGB Histogram
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.RGBHistogram.#ctor(System.Drawing.Bitmap)">
      <summary>
            Constructor
            </summary>
      <param name="Image">Image to load</param>
    </member>
    <member name="M:Utilities.Media.Image.RGBHistogram.LoadImage(System.Drawing.Bitmap)">
      <summary>
            Loads an image
            </summary>
      <param name="ImageUsing">Image to load</param>
      <requires description="ImageUsing" exception="T:System.ArgumentNullException" csharp="ImageUsing != null" vb="ImageUsing &lt;&gt; Nothing">ImageUsing != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageUsing == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.RGBHistogram.Normalize">
      <summary>
            Normalizes the histogram
            </summary>
    </member>
    <member name="M:Utilities.Media.Image.RGBHistogram.Equalize">
      <summary>
            Equalizes the histogram
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.RGBHistogram.R">
      <summary>
            Red values
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.RGBHistogram.G">
      <summary>
            Green values
            </summary>
    </member>
    <member name="P:Utilities.Media.Image.RGBHistogram.B">
      <summary>
            Blue values
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.OPMLHelper.Body">
      <summary>
            Body class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Body.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Body.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XmlElement containing the body information</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Body.ToString">
      <summary>
            Converts the body to a string
            </summary>
      <returns>The body as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Body.Outlines">
      <summary>
            List of outlines
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.OPMLHelper.Head">
      <summary>
            Head class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Head.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Head.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XmlElement containing the header information</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Head.ToString">
      <summary>
            Converts the head to a string
            </summary>
      <returns>The head as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Head.Title">
      <summary>
            Title of the OPML document
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Head.DateCreated">
      <summary>
            Date it was created
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Head.DateModified">
      <summary>
            Date it was last modified
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Head.OwnerName">
      <summary>
            Owner of the file
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Head.OwnerEmail">
      <summary>
            Owner's email address
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Head.Docs">
      <summary>
            Location of the OPML spec
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.OPMLHelper.OPML">
      <summary>
            OPML class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.OPML.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.OPML.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Location">Location of the OPML file</param>
      <requires description="Location" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Location)" vb="Not IsNullOrEmpty(Location)">!string.IsNullOrEmpty(Location)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Location)</exception>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.OPML.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Constructor
            </summary>
      <param name="Document">XmlDocument containing the OPML file</param>
      <requires description="Document" exception="T:System.ArgumentNullException" csharp="Document != null" vb="Document &lt;&gt; Nothing">Document != null</requires>
      <exception cref="T:System.ArgumentNullException">Document == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.OPML.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.OPML.ToString">
      <summary>
            Converts the file to a string
            </summary>
      <returns>The file as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.OPML.Body">
      <summary>
            Body of the file
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.OPML.Head">
      <summary>
            Header information
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.OPMLHelper.Outline">
      <summary>
            Outline class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Outline.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Outline.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructors
            </summary>
      <param name="Element">Element containing outline information</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.OPMLHelper.Outline.ToString">
      <summary>
            Converts the outline to a string
            </summary>
      <returns>The outline as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Outlines">
      <summary>
            Outline list
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.XMLUrl">
      <summary>
            Url of the XML file
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Version">
      <summary>
            Version number
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Title">
      <summary>
            Title of the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Language">
      <summary>
            Language used
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Type">
      <summary>
            Type
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.HTMLUrl">
      <summary>
            HTML Url
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Text">
      <summary>
            Text
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.OPMLHelper.Outline.Description">
      <summary>
            Description
            </summary>
    </member>
    <member name="T:Utilities.Web.PingBack.Manager">
      <summary>
            Handles ping backs, track backs, and pinging services
            </summary>
    </member>
    <member name="M:Utilities.Web.PingBack.Manager.PingServices(System.Collections.Generic.IEnumerable{System.Uri},System.Uri,System.String,System.Boolean)">
      <summary>
            Pings services such as technorati, etc.
            </summary>
      <param name="Services">List of services</param>
      <param name="Blog">URI of your blog</param>
      <param name="BlogName">Name of the blog</param>
      <param name="Threaded">If true this is done in a seperate thread,
            if false it will wait for it to end</param>
    </member>
    <member name="T:Utilities.Web.PingBack.PingBack">
      <summary>
            Handles ping backs
            </summary>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.SendPingBack(Utilities.Web.PingBack.PingBackMessage)">
      <summary>
            Sends a ping back
            </summary>
      <param name="Message">Message to send</param>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.GetPingBack(System.Web.HttpContext)">
      <summary>
            Gets a ping back
            </summary>
      <param name="Context">The HttpContext for this item</param>
      <returns>The ping back message</returns>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.GetPingBack(System.Web.HttpRequest)">
      <summary>
            Gets a ping back
            </summary>
      <param name="Request">The HttpRequest for this item</param>
      <returns>The ping back message</returns>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.SendSuccess(System.Web.HttpContext)">
      <summary>
            Sends a success message.
            </summary>
      <param name="Context">HttpContext of the item</param>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.SendError(System.Web.HttpContext,System.Int32,System.String)">
      <summary>
            Sends an error message
            </summary>
      <param name="Context">Context of the item</param>
      <param name="Code">Error code</param>
      <param name="ErrorMessage">Error Message</param>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.SendSuccess(System.Web.HttpResponse)">
      <summary>
            Sends a success message.
            </summary>
      <param name="Response">Response for the item</param>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBack.SendError(System.Web.HttpResponse,System.Int32,System.String)">
      <summary>
            Sends an error message
            </summary>
      <param name="Response">Response object</param>
      <param name="Code">Error code</param>
      <param name="ErrorMessage">Error message</param>
    </member>
    <member name="T:Utilities.Web.PingBack.PingBackMessage">
      <summary>
            Message class used for pingbacks
            </summary>
    </member>
    <member name="M:Utilities.Web.PingBack.PingBackMessage.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.PingBackMessage.Source">
      <summary>
            Source Location
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.PingBackMessage.Target">
      <summary>
            Target location
            </summary>
    </member>
    <member name="T:Utilities.Web.PingBack.TrackBack">
      <summary>
            Handles track backs
            </summary>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.SendTrackBack(Utilities.Web.PingBack.TrackBackMessage)">
      <summary>
            Sends a track back message
            </summary>
      <param name="Message">Message to send</param>
      <requires description="Message" exception="T:System.ArgumentNullException" csharp="Message != null" vb="Message &lt;&gt; Nothing">Message != null</requires>
      <exception cref="T:System.ArgumentNullException">Message == null</exception>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.GetTrackBack(System.Web.HttpContext)">
      <summary>
            Gets a trackback message
            </summary>
      <param name="Context">Context object</param>
      <returns>A trackback message</returns>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.GetTrackBack(System.Web.HttpRequest)">
      <summary>
            Gets a trackback message
            </summary>
      <param name="Request">Request object</param>
      <returns>A trackback message</returns>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.SendSuccess(System.Web.HttpContext)">
      <summary>
            Send a success message
            </summary>
      <param name="Context">Context object</param>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.SendSuccess(System.Web.HttpResponse)">
      <summary>
            Send a success message
            </summary>
      <param name="Response">Response object</param>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.SendError(System.Web.HttpContext,System.String)">
      <summary>
            Sends an error message
            </summary>
      <param name="Context">Context Object</param>
      <param name="ErrorMessage">Error message to send</param>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBack.SendError(System.Web.HttpResponse,System.String)">
      <summary>
            Sends an error message
            </summary>
      <param name="Response">Response Object</param>
      <param name="ErrorMessage">Error message to send</param>
    </member>
    <member name="T:Utilities.Web.PingBack.TrackBackMessage">
      <summary>
            Track back message class
            </summary>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBackMessage.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.PingBack.TrackBackMessage.ToString">
      <summary>
            Writes out the message (used for sending)
            </summary>
      <returns>A string with the message information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.Web.PingBack.TrackBackMessage.ID">
      <summary>
            ID of the item (most likely this is not set)
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.TrackBackMessage.Title">
      <summary>
            Title of the post linking to you
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.TrackBackMessage.PostUrl">
      <summary>
            URL of the post linking to you
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.TrackBackMessage.Excerpt">
      <summary>
            Excerpt from the post linking to you
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.TrackBackMessage.BlogName">
      <summary>
            Name of the blog linking to you
            </summary>
    </member>
    <member name="P:Utilities.Web.PingBack.TrackBackMessage.NotificationURL">
      <summary>
            URL to send the message notification to.
            Only used for sending the message and filled in
            automatically.
            </summary>
    </member>
    <member name="T:Utilities.Random.Random">
      <summary>
            Utility class for handling random
            information.
            </summary>
    </member>
    <member name="M:Utilities.Random.Random.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Random.Random.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="Seed">Seed value</param>
    </member>
    <member name="M:Utilities.Random.Random.ThreadSafeNext(System.Int32,System.Int32)">
      <summary>
            A thread safe version of a random number generation
            </summary>
      <param name="Min">Minimum value</param>
      <param name="Max">Maximum value</param>
      <returns>A randomly generated value</returns>
    </member>
    <member name="T:Utilities.FileFormats.RSD.API">
      <summary>
            API class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSD.API.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSD.API.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing the API info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSD.API.ToString">
      <summary>
            To string function
            </summary>
      <returns>The API info</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSD.API.Name">
      <summary>
            Name of the API
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSD.API.Preferred">
      <summary>
            Is this API preferred?
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSD.API.APILink">
      <summary>
            Link to the API
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSD.API.BlogID">
      <summary>
            Link to the blog
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSD.APIs">
      <summary>
            APIs for the RSD format
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSD.APIs.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSD.APIs.#ctor(System.Xml.Linq.XElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">Element containing the info</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSD.APIs.ToString">
      <summary>
            To string function
            </summary>
      <returns>APIs list</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSD.APIs.APIList">
      <summary>
            List of APIs
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSD.RSD">
      <summary>
            Basic helper for RSD
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSD.RSD.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSD.RSD.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="FileContent">Content of the RSD file</param>
      <requires description="FileContent" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(FileContent)" vb="Not IsNullOrEmpty(FileContent)">!string.IsNullOrEmpty(FileContent)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(FileContent)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSD.RSD.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="M:Utilities.FileFormats.RSD.RSD.ToString">
      <summary>
            Outputs the RSD file
            </summary>
      <returns>return the properly formatted RSD file</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSD.RSD.EngineName">
      <summary>
            Engine name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSD.RSD.EngineLink">
      <summary>
            Link to the engine
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSD.RSD.HomePageLink">
      <summary>
            Link to the home page
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSD.RSD.APIs">
      <summary>
            API definitions
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.Channel">
      <summary>
            Channel item for RSS feeds
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Channel.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Channel.#ctor(System.Xml.XmlElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML representation of the channel</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
      <requires description="Element is not a channel" exception="T:System.ArgumentException" csharp="Element.Name.Equals(&quot;channel&quot;, 1)" vb="Element.Name.Equals(&quot;channel&quot;, 1)">Element.Name.Equals("channel", 1)</requires>
      <exception cref="T:System.ArgumentException">!Element.Name.Equals("channel", 1)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Channel.ToString">
      <summary>
            Converts the channel to a string
            </summary>
      <returns>The channel as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Explicit">
      <summary>
            Determines if this is explicit or not
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Items">
      <summary>
            Items for this channel
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Title">
      <summary>
            Title of the channel
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Link">
      <summary>
            Link to the website
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Description">
      <summary>
            Description of the channel
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Copyright">
      <summary>
            Copyright info
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Language">
      <summary>
            Language it is in
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.WebMaster">
      <summary>
            Web Master info
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.PubDate">
      <summary>
            Date the channel was published
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Categories">
      <summary>
            Categories associated with this channel
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Docs">
      <summary>
            Document describing the file format
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.Cloud">
      <summary>
            Cloud information
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.TTL">
      <summary>
            Time to live... Amount of time between updates.
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Channel.ImageUrl">
      <summary>
            Url pointing to the image/logo associated with the channel
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.Document">
      <summary>
            RSS document class
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="Location">Location of the RSS feed to load</param>
      <requires description="Location" exception="T:System.ArgumentNullException" csharp="!IsNullOrEmpty(Location)" vb="Not IsNullOrEmpty(Location)">!string.IsNullOrEmpty(Location)</requires>
      <exception cref="T:System.ArgumentNullException">string.IsNullOrEmpty(Location)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.#ctor(System.Xml.XmlDocument)">
      <summary>
            Constructor
            </summary>
      <param name="Document">XML document containing an RSS feed</param>
      <requires description="Document" exception="T:System.ArgumentNullException" csharp="Document != null" vb="Document &lt;&gt; Nothing">Document != null</requires>
      <exception cref="T:System.ArgumentNullException">Document == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.ToString">
      <summary>
            string representation of the RSS feed.
            </summary>
      <returns>An rss formatted string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.Copy(Utilities.FileFormats.RSSHelper.Document)">
      <summary>
            Copies one document's channels to another
            </summary>
      <param name="CopyFrom">RSS document to copy from</param>
      <requires description="CopyFrom" exception="T:System.ArgumentNullException" csharp="CopyFrom != null" vb="CopyFrom &lt;&gt; Nothing">CopyFrom != null</requires>
      <exception cref="T:System.ArgumentNullException">CopyFrom == null</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.LoadFromData(System.String)">
      <summary>
            Loads the object from the data specified
            </summary>
      <param name="Data">Data to load into the object</param>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Document.Channels">
      <summary>
            Channels for the RSS feed
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.Enclosure">
      <summary>
            Enclosure class for RSS feeds (used for pod casting)
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Enclosure.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Enclosure.#ctor(System.Xml.XmlElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element holding info for the enclosure</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
      <requires description="Element is not a enclosure" exception="T:System.ArgumentException" csharp="Element.Name.Equals(&quot;enclosure&quot;, 1)" vb="Element.Name.Equals(&quot;enclosure&quot;, 1)">Element.Name.Equals("enclosure", 1)</requires>
      <exception cref="T:System.ArgumentException">!Element.Name.Equals("enclosure", 1)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Enclosure.ToString">
      <summary>
            to string item. Used for outputting the item to RSS.
            </summary>
      <returns>A string formatted for RSS output</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Enclosure.Url">
      <summary>
            Location of the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Enclosure.Length">
      <summary>
            Size in bytes
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Enclosure.Type">
      <summary>
            File type
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.Item">
      <summary>
            Item class for RSS feeds
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Item.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Item.#ctor(System.Xml.XmlElement)">
      <summary>
            Constructor
            </summary>
      <param name="Element">XML element containing the item content</param>
      <requires description="Element" exception="T:System.ArgumentNullException" csharp="Element != null" vb="Element &lt;&gt; Nothing">Element != null</requires>
      <exception cref="T:System.ArgumentNullException">Element == null</exception>
      <requires description="Element is not a item" exception="T:System.ArgumentException" csharp="Element.Name.Equals(&quot;item&quot;, 1)" vb="Element.Name.Equals(&quot;item&quot;, 1)">Element.Name.Equals("item", 1)</requires>
      <exception cref="T:System.ArgumentException">!Element.Name.Equals("item", 1)</exception>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Item.ToString">
      <summary>
            Outputs a string ready for RSS
            </summary>
      <returns>A string formatted for RSS</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.GUID">
      <summary>
            GUID for the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Thumbnail">
      <summary>
            Thumbnail information
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Title">
      <summary>
            Title of the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Link">
      <summary>
            Link to its location
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Description">
      <summary>
            Description of the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Author">
      <summary>
            Author of the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Categories">
      <summary>
            Categories associated with the item
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.PubDate">
      <summary>
            Date it was published
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.RSSHelper.Item.Enclosure">
      <summary>
            Enclosure (used for podcasting)
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.RSSHelper.RSS">
      <summary>
            Utility class used by RSS classes.
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.RSS.StripIllegalCharacters(System.String)">
      <summary>
            Strips illegal characters from RSS items
            </summary>
      <param name="Original">Original text</param>
      <returns>string stripped of certain characters.</returns>
    </member>
    <member name="T:Utilities.Web.Ping.Ping">
      <summary>
            Class used to ping another computer
            </summary>
    </member>
    <member name="M:Utilities.Web.Ping.Ping.PingHost(System.String,System.Int32)">
      <summary>
            Does a ping against the host specified
            </summary>
      <param name="Address">Address of the host</param>
      <param name="TimeOut">Timeout in ms (optional)</param>
      <returns>True if a response is received, false otherwise</returns>
    </member>
    <member name="T:Utilities.Web.WebBrowserHelper.WebBrowserHelper">
      <summary>
            Class for clearing the cache
            </summary>
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.FindFirstUrlCacheGroup(System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int64@,System.IntPtr)">
      <summary>
            Finds first url cache group
            </summary>
      <param name="dwFlags" />
      <param name="dwFilter" />
      <param name="lpSearchCondition" />
      <param name="dwSearchCondition" />
      <param name="lpGroupId" />
      <param name="lpReserved" />
      <returns />
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.FindNextUrlCacheGroup(System.IntPtr,System.Int64@,System.IntPtr)">
      <summary>
            Finds next URL Cache Group
            </summary>
      <param name="hFind" />
      <param name="lpGroupId" />
      <param name="lpReserved" />
      <returns />
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.DeleteUrlCacheGroup(System.Int64,System.Int32,System.IntPtr)">
      <summary>
            Deletes an URL from a Cache group
            </summary>
      <param name="GroupId" />
      <param name="dwFlags" />
      <param name="lpReserved" />
      <returns />
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.FindFirstUrlCacheEntry(System.String,System.IntPtr,System.Int32@)">
      <summary>
            Find first URL cache entry
            </summary>
      <param name="lpszUrlSearchPattern" />
      <param name="lpFirstCacheEntryInfo" />
      <param name="lpdwFirstCacheEntryInfoBufferSize" />
      <returns />
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.FindNextUrlCacheEntry(System.IntPtr,System.IntPtr,System.Int32@)">
      <summary>
            Find nexxt URL cache entry
            </summary>
      <param name="hFind" />
      <param name="lpNextCacheEntryInfo" />
      <param name="lpdwNextCacheEntryInfoBufferSize" />
      <returns />
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.DeleteUrlCacheEntry(System.IntPtr)">
      <summary>
            Deletes an URL cache entry
            </summary>
      <param name="lpszUrlName" />
      <returns />
    </member>
    <member name="M:Utilities.Web.WebBrowserHelper.WebBrowserHelper.ClearCache">
      <summary>
            Clears the cache of the web browser
            </summary>
    </member>
    <member name="T:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA">
      <summary>
            For PInvoke: Contains information about an entry in the Internet cache
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwStructSize">
      <summary>
            Struct size
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.lpszSourceUrlName">
      <summary>
            Source URL name
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.lpszLocalFileName">
      <summary>
            Local file name
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.CacheEntryType">
      <summary>
            Entry type
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwUseCount">
      <summary>
            Use count
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwHitRate">
      <summary>
            Hit rate
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwSizeLow">
      <summary>
            Size low
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwSizeHigh">
      <summary>
            Size high
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.LastModifiedTime">
      <summary>
            Last modified time
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.ExpireTime">
      <summary>
            Expire time
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.LastAccessTime">
      <summary>
            Last access time
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.LastSyncTime">
      <summary>
            Last sync time
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.lpHeaderInfo">
      <summary>
            Header info
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwHeaderInfoSize">
      <summary>
            Header info size
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.lpszFileExtension">
      <summary>
            File extension
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwReserved">
      <summary>
            Reserved
            </summary>
    </member>
    <member name="F:Utilities.Web.WebBrowserHelper.WebBrowserHelper.INTERNET_CACHE_ENTRY_INFOA.dwExemptDelta">
      <summary>
            Exempt delta
            </summary>
    </member>
    <member name="T:Utilities.Web.WebPageThumbnail.WebPageThumbnail">
      <summary>
            Class for taking a screen shot of a web page
            </summary>
    </member>
    <member name="M:Utilities.Web.WebPageThumbnail.WebPageThumbnail.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.Web.WebPageThumbnail.WebPageThumbnail.GenerateBitmap(System.String,System.String,System.Int32,System.Int32)">
      <summary>
            Generates a screen shot of a web site
            </summary>
      <param name="FileName">File name to save as</param>
      <param name="Url">Url to take the screen shot of</param>
      <param name="Width">Width of the image (-1 for full size)</param>
      <param name="Height">Height of the image (-1 for full size)</param>
    </member>
    <member name="M:Utilities.Web.WebPageThumbnail.WebPageThumbnail.CreateBrowser">
      <summary>
            Creates the browser
            </summary>
    </member>
    <member name="M:Utilities.Web.WebPageThumbnail.WebPageThumbnail.Browser_DocumentCompleted(System.Object,System.Windows.Forms.WebBrowserDocumentCompletedEventArgs)">
      <summary>
            Called when the browser is completed
            </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="T:Utilities.FileFormats.XFN.People">
      <summary>
            Contains an individual's information
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XFN.People.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XFN.People.ToString">
      <summary>
            Returns an HTML formatted string containing the information
            </summary>
      <returns>An HTML formatted string containing the information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.XFN.People.Name">
      <summary>
            Person's name
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.XFN.People.URL">
      <summary>
            Person's URL
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.XFN.People.Relationships">
      <summary>
            Person's relationships
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.XFN.XFNList">
      <summary>
            List used for displaying XFN data
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XFN.XFNList.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XFN.XFNList.ToString">
      <summary>
            Returns an HTML formatted string containing the information
            </summary>
      <returns>An HTML formatted string containing the information</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.XFN.XFNList.People">
      <summary>
            List of people
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.XFN.Relationship">
      <summary>
            Enum defining relationships (used for XFN markup)
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Friend">
      <summary>
            Friend
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Acquaintance">
      <summary>
            Acquaintance
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Contact">
      <summary>
            Contact
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Met">
      <summary>
            Met
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.CoWorker">
      <summary>
            Coworker
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Colleague">
      <summary>
            Colleague
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.CoResident">
      <summary>
            Coresident
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Neighbor">
      <summary>
            Neighbor
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Child">
      <summary>
            Child
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Parent">
      <summary>
            Parent
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Sibling">
      <summary>
            Sibling
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Spouse">
      <summary>
            Spouse
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Kin">
      <summary>
            Kin
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Muse">
      <summary>
            Muse
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Crush">
      <summary>
            Crush
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Date">
      <summary>
            Date
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Sweetheart">
      <summary>
            Sweetheart
            </summary>
    </member>
    <member name="F:Utilities.FileFormats.XFN.Relationship.Me">
      <summary>
            Me
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.XMDP.Property">
      <summary>
            Class for holding the individual properties and their
            descriptions.
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XMDP.Property.#ctor">
      <summary>
            Constructors
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XMDP.Property.ToString">
      <summary>
            Converts the property to a string
            </summary>
      <returns>The property as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.XMDP.Property.Name">
      <summary>
            Name of the property
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.XMDP.Property.Description">
      <summary>
            Description of the property
            </summary>
    </member>
    <member name="P:Utilities.FileFormats.XMDP.Property.Properties">
      <summary>
            List of sub properties (only used for rel type when you need to
            define new link types)
            </summary>
    </member>
    <member name="T:Utilities.FileFormats.XMDP.XMDP">
      <summary>
            Class for creating XMDP pages
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XMDP.XMDP.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.XMDP.XMDP.ToString">
      <summary>
            Converts the file to a string
            </summary>
      <returns>The XMDP file as a string</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="P:Utilities.FileFormats.XMDP.XMDP.Properties">
      <summary>
            Properties to be included
            </summary>
    </member>
    <member name="M:Utilities.FileFormats.RSSHelper.Document.Load(System.Xml.XmlDocument)">
      <requires description="Document" exception="T:System.ArgumentNullException" csharp="Document != null" vb="Document &lt;&gt; Nothing">Document != null</requires>
      <exception cref="T:System.ArgumentNullException">Document == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GetHeight(System.Int32,System.Int32,System.Drawing.Imaging.BitmapData,System.Int32)">
      <requires description="BlackAndWhiteData" exception="T:System.ArgumentNullException" csharp="BlackAndWhiteData != null" vb="BlackAndWhiteData &lt;&gt; Nothing">BlackAndWhiteData != null</requires>
      <exception cref="T:System.ArgumentNullException">BlackAndWhiteData == null</exception>
    </member>
    <member name="M:Utilities.Media.Image.ExtensionMethods.BitmapExtensions.GetMinMaxPixel(System.Drawing.Color@,System.Drawing.Color@,System.Drawing.Imaging.BitmapData,System.Int32)">
      <requires description="ImageData" exception="T:System.ArgumentNullException" csharp="ImageData != null" vb="ImageData &lt;&gt; Nothing">ImageData != null</requires>
      <exception cref="T:System.ArgumentNullException">ImageData == null</exception>
    </member>
  </members>
</doc>